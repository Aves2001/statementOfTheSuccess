/*
 * This combined file was created by the DataTables downloader builder:
 *   https://datatables.net/download
 *
 * To rebuild or modify this file with the latest versions of the included
 * software please visit:
 *   https://datatables.net/download/#bs5/dt-1.13.4/e-2.1.2/b-2.3.6/date-1.4.1/fh-3.3.2/sb-1.4.2
 *
 * Included libraries:
 *   DataTables 1.13.4, Editor 2.1.2, Buttons 2.3.6, DateTime 1.4.1, FixedHeader 3.3.2, SearchBuilder 1.4.2
 */

/*! DataTables 1.13.4
 * ©2008-2023 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     DataTables
 * @description Paginate, search and order HTML tables
 * @version     1.13.4
 * @author      SpryMedia Ltd
 * @contact     www.datatables.net
 * @copyright   SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

/*jslint evil: true, undef: true, browser: true */
/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/

(function( factory ) {
	"use strict";

	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		// jQuery's factory checks for a global window - if it isn't present then it
		// returns a factory function that expects the window object
		var jq = require('jquery');

		if (typeof window !== 'undefined') {
			module.exports = function (root, $) {
				if ( ! root ) {
					// CommonJS environments without a window global must pass a
					// root. This will give an error otherwise
					root = window;
				}

				if ( ! $ ) {
					$ = jq( root );
				}

				return factory( $, root, root.document );
			};
		}
		else {
			return factory( jq, window, window.document );
		}
	}
	else {
		// Browser
		window.DataTable = factory( jQuery, window, document );
	}
}
(function( $, window, document, undefined ) {
	"use strict";

	
	var DataTable = function ( selector, options )
	{
		// Check if called with a window or jQuery object for DOM less applications
		// This is for backwards compatibility
		if (DataTable.factory(selector, options)) {
			return DataTable;
		}
	
		// When creating with `new`, create a new DataTable, returning the API instance
		if (this instanceof DataTable) {
			return $(selector).DataTable(options);
		}
		else {
			// Argument switching
			options = selector;
		}
	
		/**
		 * Perform a jQuery selector action on the table's TR elements (from the tbody) and
		 * return the resulting jQuery object.
		 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
		 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
		 *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
		 *    criterion ("applied") or all TR elements (i.e. no filter).
		 *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
		 *    Can be either 'current', whereby the current sorting of the table is used, or
		 *    'original' whereby the original order the data was read into the table is used.
		 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
		 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
		 *    'current' and filter is 'applied', regardless of what they might be given as.
		 *  @returns {object} jQuery object, filtered by the given selector.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Highlight every second row
		 *      oTable.$('tr:odd').css('backgroundColor', 'blue');
		 *    } );
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Filter to rows with 'Webkit' in them, add a background colour and then
		 *      // remove the filter, thus highlighting the 'Webkit' rows only.
		 *      oTable.fnFilter('Webkit');
		 *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
		 *      oTable.fnFilter('');
		 *    } );
		 */
		this.$ = function ( sSelector, oOpts )
		{
			return this.api(true).$( sSelector, oOpts );
		};
		
		
		/**
		 * Almost identical to $ in operation, but in this case returns the data for the matched
		 * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
		 * rather than any descendants, so the data can be obtained for the row/cell. If matching
		 * rows are found, the data returned is the original data array/object that was used to
		 * create the row (or a generated array if from a DOM source).
		 *
		 * This method is often useful in-combination with $ where both functions are given the
		 * same parameters and the array indexes will match identically.
		 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
		 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
		 *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
		 *    criterion ("applied") or all elements (i.e. no filter).
		 *  @param {string} [oOpts.order=current] Order of the data in the processed array.
		 *    Can be either 'current', whereby the current sorting of the table is used, or
		 *    'original' whereby the original order the data was read into the table is used.
		 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
		 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
		 *    'current' and filter is 'applied', regardless of what they might be given as.
		 *  @returns {array} Data for the matched elements. If any elements, as a result of the
		 *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
		 *    entry in the array.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Get the data from the first row in the table
		 *      var data = oTable._('tr:first');
		 *
		 *      // Do something useful with the data
		 *      alert( "First cell is: "+data[0] );
		 *    } );
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Filter to 'Webkit' and get all data for
		 *      oTable.fnFilter('Webkit');
		 *      var data = oTable._('tr', {"search": "applied"});
		 *
		 *      // Do something with the data
		 *      alert( data.length+" rows matched the search" );
		 *    } );
		 */
		this._ = function ( sSelector, oOpts )
		{
			return this.api(true).rows( sSelector, oOpts ).data();
		};
		
		
		/**
		 * Create a DataTables Api instance, with the currently selected tables for
		 * the Api's context.
		 * @param {boolean} [traditional=false] Set the API instance's context to be
		 *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
		 *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
		 *   or if all tables captured in the jQuery object should be used.
		 * @return {DataTables.Api}
		 */
		this.api = function ( traditional )
		{
			return traditional ?
				new _Api(
					_fnSettingsFromNode( this[ _ext.iApiIndex ] )
				) :
				new _Api( this );
		};
		
		
		/**
		 * Add a single new row or multiple rows of data to the table. Please note
		 * that this is suitable for client-side processing only - if you are using
		 * server-side processing (i.e. "bServerSide": true), then to add data, you
		 * must add it to the data source, i.e. the server-side, through an Ajax call.
		 *  @param {array|object} data The data to be added to the table. This can be:
		 *    <ul>
		 *      <li>1D array of data - add a single row with the data provided</li>
		 *      <li>2D array of arrays - add multiple rows in a single call</li>
		 *      <li>object - data object when using <i>mData</i></li>
		 *      <li>array of objects - multiple data objects when using <i>mData</i></li>
		 *    </ul>
		 *  @param {bool} [redraw=true] redraw the table or not
		 *  @returns {array} An array of integers, representing the list of indexes in
		 *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
		 *    the table.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    // Global var for counter
		 *    var giCount = 2;
		 *
		 *    $(document).ready(function() {
		 *      $('#example').dataTable();
		 *    } );
		 *
		 *    function fnClickAddRow() {
		 *      $('#example').dataTable().fnAddData( [
		 *        giCount+".1",
		 *        giCount+".2",
		 *        giCount+".3",
		 *        giCount+".4" ]
		 *      );
		 *
		 *      giCount++;
		 *    }
		 */
		this.fnAddData = function( data, redraw )
		{
			var api = this.api( true );
		
			/* Check if we want to add multiple rows or not */
			var rows = Array.isArray(data) && ( Array.isArray(data[0]) || $.isPlainObject(data[0]) ) ?
				api.rows.add( data ) :
				api.row.add( data );
		
			if ( redraw === undefined || redraw ) {
				api.draw();
			}
		
			return rows.flatten().toArray();
		};
		
		
		/**
		 * This function will make DataTables recalculate the column sizes, based on the data
		 * contained in the table and the sizes applied to the columns (in the DOM, CSS or
		 * through the sWidth parameter). This can be useful when the width of the table's
		 * parent element changes (for example a window resize).
		 *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false
		 *      } );
		 *
		 *      $(window).on('resize', function () {
		 *        oTable.fnAdjustColumnSizing();
		 *      } );
		 *    } );
		 */
		this.fnAdjustColumnSizing = function ( bRedraw )
		{
			var api = this.api( true ).columns.adjust();
			var settings = api.settings()[0];
			var scroll = settings.oScroll;
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw( false );
			}
			else if ( scroll.sX !== "" || scroll.sY !== "" ) {
				/* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
				_fnScrollDraw( settings );
			}
		};
		
		
		/**
		 * Quickly and simply clear a table
		 *  @param {bool} [bRedraw=true] redraw the table or not
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
		 *      oTable.fnClearTable();
		 *    } );
		 */
		this.fnClearTable = function( bRedraw )
		{
			var api = this.api( true ).clear();
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw();
			}
		};
		
		
		/**
		 * The exact opposite of 'opening' a row, this function will close any rows which
		 * are currently 'open'.
		 *  @param {node} nTr the table row to 'close'
		 *  @returns {int} 0 on success, or 1 if failed (can't find the row)
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnClose = function( nTr )
		{
			this.api( true ).row( nTr ).child.hide();
		};
		
		
		/**
		 * Remove a row for the table
		 *  @param {mixed} target The index of the row from aoData to be deleted, or
		 *    the TR element you want to delete
		 *  @param {function|null} [callBack] Callback function
		 *  @param {bool} [redraw=true] Redraw the table or not
		 *  @returns {array} The row that was deleted
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Immediately remove the first row
		 *      oTable.fnDeleteRow( 0 );
		 *    } );
		 */
		this.fnDeleteRow = function( target, callback, redraw )
		{
			var api = this.api( true );
			var rows = api.rows( target );
			var settings = rows.settings()[0];
			var data = settings.aoData[ rows[0][0] ];
		
			rows.remove();
		
			if ( callback ) {
				callback.call( this, settings, data );
			}
		
			if ( redraw === undefined || redraw ) {
				api.draw();
			}
		
			return data;
		};
		
		
		/**
		 * Restore the table to it's original state in the DOM by removing all of DataTables
		 * enhancements, alterations to the DOM structure of the table and event listeners.
		 *  @param {boolean} [remove=false] Completely remove the table from the DOM
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnDestroy();
		 *    } );
		 */
		this.fnDestroy = function ( remove )
		{
			this.api( true ).destroy( remove );
		};
		
		
		/**
		 * Redraw the table
		 *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
		 *      oTable.fnDraw();
		 *    } );
		 */
		this.fnDraw = function( complete )
		{
			// Note that this isn't an exact match to the old call to _fnDraw - it takes
			// into account the new data, but can hold position.
			this.api( true ).draw( complete );
		};
		
		
		/**
		 * Filter the input based on data
		 *  @param {string} sInput String to filter the table on
		 *  @param {int|null} [iColumn] Column to limit filtering to
		 *  @param {bool} [bRegex=false] Treat as regular expression or not
		 *  @param {bool} [bSmart=true] Perform smart filtering or not
		 *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
		 *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Sometime later - filter...
		 *      oTable.fnFilter( 'test string' );
		 *    } );
		 */
		this.fnFilter = function( sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive )
		{
			var api = this.api( true );
		
			if ( iColumn === null || iColumn === undefined ) {
				api.search( sInput, bRegex, bSmart, bCaseInsensitive );
			}
			else {
				api.column( iColumn ).search( sInput, bRegex, bSmart, bCaseInsensitive );
			}
		
			api.draw();
		};
		
		
		/**
		 * Get the data for the whole table, an individual row or an individual cell based on the
		 * provided parameters.
		 *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
		 *    a TR node then the data source for the whole row will be returned. If given as a
		 *    TD/TH cell node then iCol will be automatically calculated and the data for the
		 *    cell returned. If given as an integer, then this is treated as the aoData internal
		 *    data index for the row (see fnGetPosition) and the data for that row used.
		 *  @param {int} [col] Optional column index that you want the data of.
		 *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
		 *    returned. If mRow is defined, just data for that row, and is iCol is
		 *    defined, only data for the designated cell is returned.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    // Row data
		 *    $(document).ready(function() {
		 *      oTable = $('#example').dataTable();
		 *
		 *      oTable.$('tr').click( function () {
		 *        var data = oTable.fnGetData( this );
		 *        // ... do something with the array / object of data for the row
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Individual cell data
		 *    $(document).ready(function() {
		 *      oTable = $('#example').dataTable();
		 *
		 *      oTable.$('td').click( function () {
		 *        var sData = oTable.fnGetData( this );
		 *        alert( 'The cell clicked on had the value of '+sData );
		 *      } );
		 *    } );
		 */
		this.fnGetData = function( src, col )
		{
			var api = this.api( true );
		
			if ( src !== undefined ) {
				var type = src.nodeName ? src.nodeName.toLowerCase() : '';
		
				return col !== undefined || type == 'td' || type == 'th' ?
					api.cell( src, col ).data() :
					api.row( src ).data() || null;
			}
		
			return api.data().toArray();
		};
		
		
		/**
		 * Get an array of the TR nodes that are used in the table's body. Note that you will
		 * typically want to use the '$' API method in preference to this as it is more
		 * flexible.
		 *  @param {int} [iRow] Optional row index for the TR element you want
		 *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
		 *    in the table's body, or iRow is defined, just the TR element requested.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Get the nodes from the table
		 *      var nNodes = oTable.fnGetNodes( );
		 *    } );
		 */
		this.fnGetNodes = function( iRow )
		{
			var api = this.api( true );
		
			return iRow !== undefined ?
				api.row( iRow ).node() :
				api.rows().nodes().flatten().toArray();
		};
		
		
		/**
		 * Get the array indexes of a particular cell from it's DOM element
		 * and column index including hidden columns
		 *  @param {node} node this can either be a TR, TD or TH in the table's body
		 *  @returns {int} If nNode is given as a TR, then a single index is returned, or
		 *    if given as a cell, an array of [row index, column index (visible),
		 *    column index (all)] is given.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example tbody td').click( function () {
		 *        // Get the position of the current data from the node
		 *        var aPos = oTable.fnGetPosition( this );
		 *
		 *        // Get the data array for this row
		 *        var aData = oTable.fnGetData( aPos[0] );
		 *
		 *        // Update the data array and return the value
		 *        aData[ aPos[1] ] = 'clicked';
		 *        this.innerHTML = 'clicked';
		 *      } );
		 *
		 *      // Init DataTables
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnGetPosition = function( node )
		{
			var api = this.api( true );
			var nodeName = node.nodeName.toUpperCase();
		
			if ( nodeName == 'TR' ) {
				return api.row( node ).index();
			}
			else if ( nodeName == 'TD' || nodeName == 'TH' ) {
				var cell = api.cell( node ).index();
		
				return [
					cell.row,
					cell.columnVisible,
					cell.column
				];
			}
			return null;
		};
		
		
		/**
		 * Check to see if a row is 'open' or not.
		 *  @param {node} nTr the table row to check
		 *  @returns {boolean} true if the row is currently open, false otherwise
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnIsOpen = function( nTr )
		{
			return this.api( true ).row( nTr ).child.isShown();
		};
		
		
		/**
		 * This function will place a new row directly after a row which is currently
		 * on display on the page, with the HTML contents that is passed into the
		 * function. This can be used, for example, to ask for confirmation that a
		 * particular record should be deleted.
		 *  @param {node} nTr The table row to 'open'
		 *  @param {string|node|jQuery} mHtml The HTML to put into the row
		 *  @param {string} sClass Class to give the new TD cell
		 *  @returns {node} The row opened. Note that if the table row passed in as the
		 *    first parameter, is not found in the table, this method will silently
		 *    return.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnOpen = function( nTr, mHtml, sClass )
		{
			return this.api( true )
				.row( nTr )
				.child( mHtml, sClass )
				.show()
				.child()[0];
		};
		
		
		/**
		 * Change the pagination - provides the internal logic for pagination in a simple API
		 * function. With this function you can have a DataTables table go to the next,
		 * previous, first or last pages.
		 *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
		 *    or page number to jump to (integer), note that page 0 is the first page.
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnPageChange( 'next' );
		 *    } );
		 */
		this.fnPageChange = function ( mAction, bRedraw )
		{
			var api = this.api( true ).page( mAction );
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw(false);
			}
		};
		
		
		/**
		 * Show a particular column
		 *  @param {int} iCol The column whose display should be changed
		 *  @param {bool} bShow Show (true) or hide (false) the column
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Hide the second column after initialisation
		 *      oTable.fnSetColumnVis( 1, false );
		 *    } );
		 */
		this.fnSetColumnVis = function ( iCol, bShow, bRedraw )
		{
			var api = this.api( true ).column( iCol ).visible( bShow );
		
			if ( bRedraw === undefined || bRedraw ) {
				api.columns.adjust().draw();
			}
		};
		
		
		/**
		 * Get the settings for a particular table for external manipulation
		 *  @returns {object} DataTables settings object. See
		 *    {@link DataTable.models.oSettings}
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      var oSettings = oTable.fnSettings();
		 *
		 *      // Show an example parameter from the settings
		 *      alert( oSettings._iDisplayStart );
		 *    } );
		 */
		this.fnSettings = function()
		{
			return _fnSettingsFromNode( this[_ext.iApiIndex] );
		};
		
		
		/**
		 * Sort the table by a particular column
		 *  @param {int} iCol the data index to sort on. Note that this will not match the
		 *    'display index' if you have hidden data entries
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Sort immediately with columns 0 and 1
		 *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
		 *    } );
		 */
		this.fnSort = function( aaSort )
		{
			this.api( true ).order( aaSort ).draw();
		};
		
		
		/**
		 * Attach a sort listener to an element for a given column
		 *  @param {node} nNode the element to attach the sort listener to
		 *  @param {int} iColumn the column that a click on this node will sort on
		 *  @param {function} [fnCallback] callback function when sort is run
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Sort on column 1, when 'sorter' is clicked on
		 *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
		 *    } );
		 */
		this.fnSortListener = function( nNode, iColumn, fnCallback )
		{
			this.api( true ).order.listener( nNode, iColumn, fnCallback );
		};
		
		
		/**
		 * Update a table cell or row - this method will accept either a single value to
		 * update the cell with, an array of values with one element for each column or
		 * an object in the same format as the original data source. The function is
		 * self-referencing in order to make the multi column updates easier.
		 *  @param {object|array|string} mData Data to update the cell/row with
		 *  @param {node|int} mRow TR element you want to update or the aoData index
		 *  @param {int} [iColumn] The column to update, give as null or undefined to
		 *    update a whole row.
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @param {bool} [bAction=true] Perform pre-draw actions or not
		 *  @returns {int} 0 on success, 1 on error
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
		 *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
		 *    } );
		 */
		this.fnUpdate = function( mData, mRow, iColumn, bRedraw, bAction )
		{
			var api = this.api( true );
		
			if ( iColumn === undefined || iColumn === null ) {
				api.row( mRow ).data( mData );
			}
			else {
				api.cell( mRow, iColumn ).data( mData );
			}
		
			if ( bAction === undefined || bAction ) {
				api.columns.adjust();
			}
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw();
			}
			return 0;
		};
		
		
		/**
		 * Provide a common method for plug-ins to check the version of DataTables being used, in order
		 * to ensure compatibility.
		 *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
		 *    formats "X" and "X.Y" are also acceptable.
		 *  @returns {boolean} true if this version of DataTables is greater or equal to the required
		 *    version, or false if this version of DataTales is not suitable
		 *  @method
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      alert( oTable.fnVersionCheck( '1.9.0' ) );
		 *    } );
		 */
		this.fnVersionCheck = _ext.fnVersionCheck;
		
	
		var _that = this;
		var emptyInit = options === undefined;
		var len = this.length;
	
		if ( emptyInit ) {
			options = {};
		}
	
		this.oApi = this.internal = _ext.internal;
	
		// Extend with old style plug-in API methods
		for ( var fn in DataTable.ext.internal ) {
			if ( fn ) {
				this[fn] = _fnExternApiFunc(fn);
			}
		}
	
		this.each(function() {
			// For each initialisation we want to give it a clean initialisation
			// object that can be bashed around
			var o = {};
			var oInit = len > 1 ? // optimisation for single table case
				_fnExtend( o, options, true ) :
				options;
	
			/*global oInit,_that,emptyInit*/
			var i=0, iLen, j, jLen, k, kLen;
			var sId = this.getAttribute( 'id' );
			var bInitHandedOff = false;
			var defaults = DataTable.defaults;
			var $this = $(this);
			
			
			/* Sanity check */
			if ( this.nodeName.toLowerCase() != 'table' )
			{
				_fnLog( null, 0, 'Non-table node initialisation ('+this.nodeName+')', 2 );
				return;
			}
			
			/* Backwards compatibility for the defaults */
			_fnCompatOpts( defaults );
			_fnCompatCols( defaults.column );
			
			/* Convert the camel-case defaults to Hungarian */
			_fnCamelToHungarian( defaults, defaults, true );
			_fnCamelToHungarian( defaults.column, defaults.column, true );
			
			/* Setting up the initialisation object */
			_fnCamelToHungarian( defaults, $.extend( oInit, $this.data() ), true );
			
			
			
			/* Check to see if we are re-initialising a table */
			var allSettings = DataTable.settings;
			for ( i=0, iLen=allSettings.length ; i<iLen ; i++ )
			{
				var s = allSettings[i];
			
				/* Base check on table node */
				if (
					s.nTable == this ||
					(s.nTHead && s.nTHead.parentNode == this) ||
					(s.nTFoot && s.nTFoot.parentNode == this)
				) {
					var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
					var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;
			
					if ( emptyInit || bRetrieve )
					{
						return s.oInstance;
					}
					else if ( bDestroy )
					{
						s.oInstance.fnDestroy();
						break;
					}
					else
					{
						_fnLog( s, 0, 'Cannot reinitialise DataTable', 3 );
						return;
					}
				}
			
				/* If the element we are initialising has the same ID as a table which was previously
				 * initialised, but the table nodes don't match (from before) then we destroy the old
				 * instance by simply deleting it. This is under the assumption that the table has been
				 * destroyed by other methods. Anyone using non-id selectors will need to do this manually
				 */
				if ( s.sTableId == this.id )
				{
					allSettings.splice( i, 1 );
					break;
				}
			}
			
			/* Ensure the table has an ID - required for accessibility */
			if ( sId === null || sId === "" )
			{
				sId = "DataTables_Table_"+(DataTable.ext._unique++);
				this.id = sId;
			}
			
			/* Create the settings object for this table and set some of the default parameters */
			var oSettings = $.extend( true, {}, DataTable.models.oSettings, {
				"sDestroyWidth": $this[0].style.width,
				"sInstance":     sId,
				"sTableId":      sId
			} );
			oSettings.nTable = this;
			oSettings.oApi   = _that.internal;
			oSettings.oInit  = oInit;
			
			allSettings.push( oSettings );
			
			// Need to add the instance after the instance after the settings object has been added
			// to the settings array, so we can self reference the table instance if more than one
			oSettings.oInstance = (_that.length===1) ? _that : $this.dataTable();
			
			// Backwards compatibility, before we apply all the defaults
			_fnCompatOpts( oInit );
			_fnLanguageCompat( oInit.oLanguage );
			
			// If the length menu is given, but the init display length is not, use the length menu
			if ( oInit.aLengthMenu && ! oInit.iDisplayLength )
			{
				oInit.iDisplayLength = Array.isArray( oInit.aLengthMenu[0] ) ?
					oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
			}
			
			// Apply the defaults and init options to make a single init object will all
			// options defined from defaults and instance options.
			oInit = _fnExtend( $.extend( true, {}, defaults ), oInit );
			
			
			// Map the initialisation options onto the settings object
			_fnMap( oSettings.oFeatures, oInit, [
				"bPaginate",
				"bLengthChange",
				"bFilter",
				"bSort",
				"bSortMulti",
				"bInfo",
				"bProcessing",
				"bAutoWidth",
				"bSortClasses",
				"bServerSide",
				"bDeferRender"
			] );
			_fnMap( oSettings, oInit, [
				"asStripeClasses",
				"ajax",
				"fnServerData",
				"fnFormatNumber",
				"sServerMethod",
				"aaSorting",
				"aaSortingFixed",
				"aLengthMenu",
				"sPaginationType",
				"sAjaxSource",
				"sAjaxDataProp",
				"iStateDuration",
				"sDom",
				"bSortCellsTop",
				"iTabIndex",
				"fnStateLoadCallback",
				"fnStateSaveCallback",
				"renderer",
				"searchDelay",
				"rowId",
				[ "iCookieDuration", "iStateDuration" ], // backwards compat
				[ "oSearch", "oPreviousSearch" ],
				[ "aoSearchCols", "aoPreSearchCols" ],
				[ "iDisplayLength", "_iDisplayLength" ]
			] );
			_fnMap( oSettings.oScroll, oInit, [
				[ "sScrollX", "sX" ],
				[ "sScrollXInner", "sXInner" ],
				[ "sScrollY", "sY" ],
				[ "bScrollCollapse", "bCollapse" ]
			] );
			_fnMap( oSettings.oLanguage, oInit, "fnInfoCallback" );
			
			/* Callback functions which are array driven */
			_fnCallbackReg( oSettings, 'aoDrawCallback',       oInit.fnDrawCallback,      'user' );
			_fnCallbackReg( oSettings, 'aoServerParams',       oInit.fnServerParams,      'user' );
			_fnCallbackReg( oSettings, 'aoStateSaveParams',    oInit.fnStateSaveParams,   'user' );
			_fnCallbackReg( oSettings, 'aoStateLoadParams',    oInit.fnStateLoadParams,   'user' );
			_fnCallbackReg( oSettings, 'aoStateLoaded',        oInit.fnStateLoaded,       'user' );
			_fnCallbackReg( oSettings, 'aoRowCallback',        oInit.fnRowCallback,       'user' );
			_fnCallbackReg( oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow,        'user' );
			_fnCallbackReg( oSettings, 'aoHeaderCallback',     oInit.fnHeaderCallback,    'user' );
			_fnCallbackReg( oSettings, 'aoFooterCallback',     oInit.fnFooterCallback,    'user' );
			_fnCallbackReg( oSettings, 'aoInitComplete',       oInit.fnInitComplete,      'user' );
			_fnCallbackReg( oSettings, 'aoPreDrawCallback',    oInit.fnPreDrawCallback,   'user' );
			
			oSettings.rowIdFn = _fnGetObjectDataFn( oInit.rowId );
			
			/* Browser support detection */
			_fnBrowserDetect( oSettings );
			
			var oClasses = oSettings.oClasses;
			
			$.extend( oClasses, DataTable.ext.classes, oInit.oClasses );
			$this.addClass( oClasses.sTable );
			
			
			if ( oSettings.iInitDisplayStart === undefined )
			{
				/* Display start point, taking into account the save saving */
				oSettings.iInitDisplayStart = oInit.iDisplayStart;
				oSettings._iDisplayStart = oInit.iDisplayStart;
			}
			
			if ( oInit.iDeferLoading !== null )
			{
				oSettings.bDeferLoading = true;
				var tmp = Array.isArray( oInit.iDeferLoading );
				oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
				oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
			}
			
			/* Language definitions */
			var oLanguage = oSettings.oLanguage;
			$.extend( true, oLanguage, oInit.oLanguage );
			
			if ( oLanguage.sUrl )
			{
				/* Get the language definitions from a file - because this Ajax call makes the language
				 * get async to the remainder of this function we use bInitHandedOff to indicate that
				 * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
				 */
				$.ajax( {
					dataType: 'json',
					url: oLanguage.sUrl,
					success: function ( json ) {
						_fnCamelToHungarian( defaults.oLanguage, json );
						_fnLanguageCompat( json );
						$.extend( true, oLanguage, json, oSettings.oInit.oLanguage );
			
						_fnCallbackFire( oSettings, null, 'i18n', [oSettings]);
						_fnInitialise( oSettings );
					},
					error: function () {
						// Error occurred loading language file, continue on as best we can
						_fnInitialise( oSettings );
					}
				} );
				bInitHandedOff = true;
			}
			else {
				_fnCallbackFire( oSettings, null, 'i18n', [oSettings]);
			}
			
			/*
			 * Stripes
			 */
			if ( oInit.asStripeClasses === null )
			{
				oSettings.asStripeClasses =[
					oClasses.sStripeOdd,
					oClasses.sStripeEven
				];
			}
			
			/* Remove row stripe classes if they are already on the table row */
			var stripeClasses = oSettings.asStripeClasses;
			var rowOne = $this.children('tbody').find('tr').eq(0);
			if ( $.inArray( true, $.map( stripeClasses, function(el, i) {
				return rowOne.hasClass(el);
			} ) ) !== -1 ) {
				$('tbody tr', this).removeClass( stripeClasses.join(' ') );
				oSettings.asDestroyStripes = stripeClasses.slice();
			}
			
			/*
			 * Columns
			 * See if we should load columns automatically or use defined ones
			 */
			var anThs = [];
			var aoColumnsInit;
			var nThead = this.getElementsByTagName('thead');
			if ( nThead.length !== 0 )
			{
				_fnDetectHeader( oSettings.aoHeader, nThead[0] );
				anThs = _fnGetUniqueThs( oSettings );
			}
			
			/* If not given a column array, generate one with nulls */
			if ( oInit.aoColumns === null )
			{
				aoColumnsInit = [];
				for ( i=0, iLen=anThs.length ; i<iLen ; i++ )
				{
					aoColumnsInit.push( null );
				}
			}
			else
			{
				aoColumnsInit = oInit.aoColumns;
			}
			
			/* Add the columns */
			for ( i=0, iLen=aoColumnsInit.length ; i<iLen ; i++ )
			{
				_fnAddColumn( oSettings, anThs ? anThs[i] : null );
			}
			
			/* Apply the column definitions */
			_fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
				_fnColumnOptions( oSettings, iCol, oDef );
			} );
			
			/* HTML5 attribute detection - build an mData object automatically if the
			 * attributes are found
			 */
			if ( rowOne.length ) {
				var a = function ( cell, name ) {
					return cell.getAttribute( 'data-'+name ) !== null ? name : null;
				};
			
				$( rowOne[0] ).children('th, td').each( function (i, cell) {
					var col = oSettings.aoColumns[i];
			
					if (! col) {
						_fnLog( oSettings, 0, 'Incorrect column count', 18 );
					}
			
					if ( col.mData === i ) {
						var sort = a( cell, 'sort' ) || a( cell, 'order' );
						var filter = a( cell, 'filter' ) || a( cell, 'search' );
			
						if ( sort !== null || filter !== null ) {
							col.mData = {
								_:      i+'.display',
								sort:   sort !== null   ? i+'.@data-'+sort   : undefined,
								type:   sort !== null   ? i+'.@data-'+sort   : undefined,
								filter: filter !== null ? i+'.@data-'+filter : undefined
							};
							col._isArrayHost = true;
			
							_fnColumnOptions( oSettings, i );
						}
					}
				} );
			}
			
			var features = oSettings.oFeatures;
			var loadedInit = function () {
				/*
				 * Sorting
				 * @todo For modularisation (1.11) this needs to do into a sort start up handler
				 */
			
				// If aaSorting is not defined, then we use the first indicator in asSorting
				// in case that has been altered, so the default sort reflects that option
				if ( oInit.aaSorting === undefined ) {
					var sorting = oSettings.aaSorting;
					for ( i=0, iLen=sorting.length ; i<iLen ; i++ ) {
						sorting[i][1] = oSettings.aoColumns[ i ].asSorting[0];
					}
				}
			
				/* Do a first pass on the sorting classes (allows any size changes to be taken into
				 * account, and also will apply sorting disabled classes if disabled
				 */
				_fnSortingClasses( oSettings );
			
				if ( features.bSort ) {
					_fnCallbackReg( oSettings, 'aoDrawCallback', function () {
						if ( oSettings.bSorted ) {
							var aSort = _fnSortFlatten( oSettings );
							var sortedColumns = {};
			
							$.each( aSort, function (i, val) {
								sortedColumns[ val.src ] = val.dir;
							} );
			
							_fnCallbackFire( oSettings, null, 'order', [oSettings, aSort, sortedColumns] );
							_fnSortAria( oSettings );
						}
					} );
				}
			
				_fnCallbackReg( oSettings, 'aoDrawCallback', function () {
					if ( oSettings.bSorted || _fnDataSource( oSettings ) === 'ssp' || features.bDeferRender ) {
						_fnSortingClasses( oSettings );
					}
				}, 'sc' );
			
			
				/*
				 * Final init
				 * Cache the header, body and footer as required, creating them if needed
				 */
			
				// Work around for Webkit bug 83867 - store the caption-side before removing from doc
				var captions = $this.children('caption').each( function () {
					this._captionSide = $(this).css('caption-side');
				} );
			
				var thead = $this.children('thead');
				if ( thead.length === 0 ) {
					thead = $('<thead/>').appendTo($this);
				}
				oSettings.nTHead = thead[0];
			
				var tbody = $this.children('tbody');
				if ( tbody.length === 0 ) {
					tbody = $('<tbody/>').insertAfter(thead);
				}
				oSettings.nTBody = tbody[0];
			
				var tfoot = $this.children('tfoot');
				if ( tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") ) {
					// If we are a scrolling table, and no footer has been given, then we need to create
					// a tfoot element for the caption element to be appended to
					tfoot = $('<tfoot/>').appendTo($this);
				}
			
				if ( tfoot.length === 0 || tfoot.children().length === 0 ) {
					$this.addClass( oClasses.sNoFooter );
				}
				else if ( tfoot.length > 0 ) {
					oSettings.nTFoot = tfoot[0];
					_fnDetectHeader( oSettings.aoFooter, oSettings.nTFoot );
				}
			
				/* Check if there is data passing into the constructor */
				if ( oInit.aaData ) {
					for ( i=0 ; i<oInit.aaData.length ; i++ ) {
						_fnAddData( oSettings, oInit.aaData[ i ] );
					}
				}
				else if ( oSettings.bDeferLoading || _fnDataSource( oSettings ) == 'dom' ) {
					/* Grab the data from the page - only do this when deferred loading or no Ajax
					 * source since there is no point in reading the DOM data if we are then going
					 * to replace it with Ajax data
					 */
					_fnAddTr( oSettings, $(oSettings.nTBody).children('tr') );
				}
			
				/* Copy the data index array */
				oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
			
				/* Initialisation complete - table can be drawn */
				oSettings.bInitialised = true;
			
				/* Check if we need to initialise the table (it might not have been handed off to the
				 * language processor)
				 */
				if ( bInitHandedOff === false ) {
					_fnInitialise( oSettings );
				}
			};
			
			/* Must be done after everything which can be overridden by the state saving! */
			_fnCallbackReg( oSettings, 'aoDrawCallback', _fnSaveState, 'state_save' );
			
			if ( oInit.bStateSave )
			{
				features.bStateSave = true;
				_fnLoadState( oSettings, oInit, loadedInit );
			}
			else {
				loadedInit();
			}
			
		} );
		_that = null;
		return this;
	};
	
	
	/*
	 * It is useful to have variables which are scoped locally so only the
	 * DataTables functions can access them and they don't leak into global space.
	 * At the same time these functions are often useful over multiple files in the
	 * core and API, so we list, or at least document, all variables which are used
	 * by DataTables as private variables here. This also ensures that there is no
	 * clashing of variable names and that they can easily referenced for reuse.
	 */
	
	
	// Defined else where
	//  _selector_run
	//  _selector_opts
	//  _selector_first
	//  _selector_row_indexes
	
	var _ext; // DataTable.ext
	var _Api; // DataTable.Api
	var _api_register; // DataTable.Api.register
	var _api_registerPlural; // DataTable.Api.registerPlural
	
	var _re_dic = {};
	var _re_new_lines = /[\r\n\u2028]/g;
	var _re_html = /<.*?>/g;
	
	// This is not strict ISO8601 - Date.parse() is quite lax, although
	// implementations differ between browsers.
	var _re_date = /^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/;
	
	// Escape regular expression special characters
	var _re_escape_regex = new RegExp( '(\\' + [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-' ].join('|\\') + ')', 'g' );
	
	// http://en.wikipedia.org/wiki/Foreign_exchange_market
	// - \u20BD - Russian ruble.
	// - \u20a9 - South Korean Won
	// - \u20BA - Turkish Lira
	// - \u20B9 - Indian Rupee
	// - R - Brazil (R$) and South Africa
	// - fr - Swiss Franc
	// - kr - Swedish krona, Norwegian krone and Danish krone
	// - \u2009 is thin space and \u202F is narrow no-break space, both used in many
	// - Ƀ - Bitcoin
	// - Ξ - Ethereum
	//   standards as thousands separators.
	var _re_formatted_numeric = /['\u00A0,$£€¥%\u2009\u202F\u20BD\u20a9\u20BArfkɃΞ]/gi;
	
	
	var _empty = function ( d ) {
		return !d || d === true || d === '-' ? true : false;
	};
	
	
	var _intVal = function ( s ) {
		var integer = parseInt( s, 10 );
		return !isNaN(integer) && isFinite(s) ? integer : null;
	};
	
	// Convert from a formatted number with characters other than `.` as the
	// decimal place, to a Javascript number
	var _numToDecimal = function ( num, decimalPoint ) {
		// Cache created regular expressions for speed as this function is called often
		if ( ! _re_dic[ decimalPoint ] ) {
			_re_dic[ decimalPoint ] = new RegExp( _fnEscapeRegex( decimalPoint ), 'g' );
		}
		return typeof num === 'string' && decimalPoint !== '.' ?
			num.replace( /\./g, '' ).replace( _re_dic[ decimalPoint ], '.' ) :
			num;
	};
	
	
	var _isNumber = function ( d, decimalPoint, formatted ) {
		let type = typeof d;
		var strType = type === 'string';
	
		if ( type === 'number' || type === 'bigint') {
			return true;
		}
	
		// If empty return immediately so there must be a number if it is a
		// formatted string (this stops the string "k", or "kr", etc being detected
		// as a formatted number for currency
		if ( _empty( d ) ) {
			return true;
		}
	
		if ( decimalPoint && strType ) {
			d = _numToDecimal( d, decimalPoint );
		}
	
		if ( formatted && strType ) {
			d = d.replace( _re_formatted_numeric, '' );
		}
	
		return !isNaN( parseFloat(d) ) && isFinite( d );
	};
	
	
	// A string without HTML in it can be considered to be HTML still
	var _isHtml = function ( d ) {
		return _empty( d ) || typeof d === 'string';
	};
	
	
	var _htmlNumeric = function ( d, decimalPoint, formatted ) {
		if ( _empty( d ) ) {
			return true;
		}
	
		var html = _isHtml( d );
		return ! html ?
			null :
			_isNumber( _stripHtml( d ), decimalPoint, formatted ) ?
				true :
				null;
	};
	
	
	var _pluck = function ( a, prop, prop2 ) {
		var out = [];
		var i=0, ien=a.length;
	
		// Could have the test in the loop for slightly smaller code, but speed
		// is essential here
		if ( prop2 !== undefined ) {
			for ( ; i<ien ; i++ ) {
				if ( a[i] && a[i][ prop ] ) {
					out.push( a[i][ prop ][ prop2 ] );
				}
			}
		}
		else {
			for ( ; i<ien ; i++ ) {
				if ( a[i] ) {
					out.push( a[i][ prop ] );
				}
			}
		}
	
		return out;
	};
	
	
	// Basically the same as _pluck, but rather than looping over `a` we use `order`
	// as the indexes to pick from `a`
	var _pluck_order = function ( a, order, prop, prop2 )
	{
		var out = [];
		var i=0, ien=order.length;
	
		// Could have the test in the loop for slightly smaller code, but speed
		// is essential here
		if ( prop2 !== undefined ) {
			for ( ; i<ien ; i++ ) {
				if ( a[ order[i] ][ prop ] ) {
					out.push( a[ order[i] ][ prop ][ prop2 ] );
				}
			}
		}
		else {
			for ( ; i<ien ; i++ ) {
				out.push( a[ order[i] ][ prop ] );
			}
		}
	
		return out;
	};
	
	
	var _range = function ( len, start )
	{
		var out = [];
		var end;
	
		if ( start === undefined ) {
			start = 0;
			end = len;
		}
		else {
			end = start;
			start = len;
		}
	
		for ( var i=start ; i<end ; i++ ) {
			out.push( i );
		}
	
		return out;
	};
	
	
	var _removeEmpty = function ( a )
	{
		var out = [];
	
		for ( var i=0, ien=a.length ; i<ien ; i++ ) {
			if ( a[i] ) { // careful - will remove all falsy values!
				out.push( a[i] );
			}
		}
	
		return out;
	};
	
	
	var _stripHtml = function ( d ) {
		return d.replace( _re_html, '' );
	};
	
	
	/**
	 * Determine if all values in the array are unique. This means we can short
	 * cut the _unique method at the cost of a single loop. A sorted array is used
	 * to easily check the values.
	 *
	 * @param  {array} src Source array
	 * @return {boolean} true if all unique, false otherwise
	 * @ignore
	 */
	var _areAllUnique = function ( src ) {
		if ( src.length < 2 ) {
			return true;
		}
	
		var sorted = src.slice().sort();
		var last = sorted[0];
	
		for ( var i=1, ien=sorted.length ; i<ien ; i++ ) {
			if ( sorted[i] === last ) {
				return false;
			}
	
			last = sorted[i];
		}
	
		return true;
	};
	
	
	/**
	 * Find the unique elements in a source array.
	 *
	 * @param  {array} src Source array
	 * @return {array} Array of unique items
	 * @ignore
	 */
	var _unique = function ( src )
	{
		if ( _areAllUnique( src ) ) {
			return src.slice();
		}
	
		// A faster unique method is to use object keys to identify used values,
		// but this doesn't work with arrays or objects, which we must also
		// consider. See jsperf.com/compare-array-unique-versions/4 for more
		// information.
		var
			out = [],
			val,
			i, ien=src.length,
			j, k=0;
	
		again: for ( i=0 ; i<ien ; i++ ) {
			val = src[i];
	
			for ( j=0 ; j<k ; j++ ) {
				if ( out[j] === val ) {
					continue again;
				}
			}
	
			out.push( val );
			k++;
		}
	
		return out;
	};
	
	// Surprisingly this is faster than [].concat.apply
	// https://jsperf.com/flatten-an-array-loop-vs-reduce/2
	var _flatten = function (out, val) {
		if (Array.isArray(val)) {
			for (var i=0 ; i<val.length ; i++) {
				_flatten(out, val[i]);
			}
		}
		else {
			out.push(val);
		}
	  
		return out;
	}
	
	var _includes = function (search, start) {
		if (start === undefined) {
			start = 0;
		}
	
		return this.indexOf(search, start) !== -1;	
	};
	
	// Array.isArray polyfill.
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray
	if (! Array.isArray) {
	    Array.isArray = function(arg) {
	        return Object.prototype.toString.call(arg) === '[object Array]';
	    };
	}
	
	if (! Array.prototype.includes) {
		Array.prototype.includes = _includes;
	}
	
	// .trim() polyfill
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim
	if (!String.prototype.trim) {
	  String.prototype.trim = function () {
	    return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
	  };
	}
	
	if (! String.prototype.includes) {
		String.prototype.includes = _includes;
	}
	
	/**
	 * DataTables utility methods
	 * 
	 * This namespace provides helper methods that DataTables uses internally to
	 * create a DataTable, but which are not exclusively used only for DataTables.
	 * These methods can be used by extension authors to save the duplication of
	 * code.
	 *
	 *  @namespace
	 */
	DataTable.util = {
		/**
		 * Throttle the calls to a function. Arguments and context are maintained
		 * for the throttled function.
		 *
		 * @param {function} fn Function to be called
		 * @param {integer} freq Call frequency in mS
		 * @return {function} Wrapped function
		 */
		throttle: function ( fn, freq ) {
			var
				frequency = freq !== undefined ? freq : 200,
				last,
				timer;
	
			return function () {
				var
					that = this,
					now  = +new Date(),
					args = arguments;
	
				if ( last && now < last + frequency ) {
					clearTimeout( timer );
	
					timer = setTimeout( function () {
						last = undefined;
						fn.apply( that, args );
					}, frequency );
				}
				else {
					last = now;
					fn.apply( that, args );
				}
			};
		},
	
	
		/**
		 * Escape a string such that it can be used in a regular expression
		 *
		 *  @param {string} val string to escape
		 *  @returns {string} escaped string
		 */
		escapeRegex: function ( val ) {
			return val.replace( _re_escape_regex, '\\$1' );
		},
	
		/**
		 * Create a function that will write to a nested object or array
		 * @param {*} source JSON notation string
		 * @returns Write function
		 */
		set: function ( source ) {
			if ( $.isPlainObject( source ) ) {
				/* Unlike get, only the underscore (global) option is used for for
				 * setting data since we don't know the type here. This is why an object
				 * option is not documented for `mData` (which is read/write), but it is
				 * for `mRender` which is read only.
				 */
				return DataTable.util.set( source._ );
			}
			else if ( source === null ) {
				// Nothing to do when the data source is null
				return function () {};
			}
			else if ( typeof source === 'function' ) {
				return function (data, val, meta) {
					source( data, 'set', val, meta );
				};
			}
			else if ( typeof source === 'string' && (source.indexOf('.') !== -1 ||
					  source.indexOf('[') !== -1 || source.indexOf('(') !== -1) )
			{
				// Like the get, we need to get data from a nested object
				var setData = function (data, val, src) {
					var a = _fnSplitObjNotation( src ), b;
					var aLast = a[a.length-1];
					var arrayNotation, funcNotation, o, innerSrc;
		
					for ( var i=0, iLen=a.length-1 ; i<iLen ; i++ ) {
						// Protect against prototype pollution
						if (a[i] === '__proto__' || a[i] === 'constructor') {
							throw new Error('Cannot set prototype values');
						}
		
						// Check if we are dealing with an array notation request
						arrayNotation = a[i].match(__reArray);
						funcNotation = a[i].match(__reFn);
		
						if ( arrayNotation ) {
							a[i] = a[i].replace(__reArray, '');
							data[ a[i] ] = [];
		
							// Get the remainder of the nested object to set so we can recurse
							b = a.slice();
							b.splice( 0, i+1 );
							innerSrc = b.join('.');
		
							// Traverse each entry in the array setting the properties requested
							if ( Array.isArray( val ) ) {
								for ( var j=0, jLen=val.length ; j<jLen ; j++ ) {
									o = {};
									setData( o, val[j], innerSrc );
									data[ a[i] ].push( o );
								}
							}
							else {
								// We've been asked to save data to an array, but it
								// isn't array data to be saved. Best that can be done
								// is to just save the value.
								data[ a[i] ] = val;
							}
		
							// The inner call to setData has already traversed through the remainder
							// of the source and has set the data, thus we can exit here
							return;
						}
						else if ( funcNotation ) {
							// Function call
							a[i] = a[i].replace(__reFn, '');
							data = data[ a[i] ]( val );
						}
		
						// If the nested object doesn't currently exist - since we are
						// trying to set the value - create it
						if ( data[ a[i] ] === null || data[ a[i] ] === undefined ) {
							data[ a[i] ] = {};
						}
						data = data[ a[i] ];
					}
		
					// Last item in the input - i.e, the actual set
					if ( aLast.match(__reFn ) ) {
						// Function call
						data = data[ aLast.replace(__reFn, '') ]( val );
					}
					else {
						// If array notation is used, we just want to strip it and use the property name
						// and assign the value. If it isn't used, then we get the result we want anyway
						data[ aLast.replace(__reArray, '') ] = val;
					}
				};
		
				return function (data, val) { // meta is also passed in, but not used
					return setData( data, val, source );
				};
			}
			else {
				// Array or flat object mapping
				return function (data, val) { // meta is also passed in, but not used
					data[source] = val;
				};
			}
		},
	
		/**
		 * Create a function that will read nested objects from arrays, based on JSON notation
		 * @param {*} source JSON notation string
		 * @returns Value read
		 */
		get: function ( source ) {
			if ( $.isPlainObject( source ) ) {
				// Build an object of get functions, and wrap them in a single call
				var o = {};
				$.each( source, function (key, val) {
					if ( val ) {
						o[key] = DataTable.util.get( val );
					}
				} );
		
				return function (data, type, row, meta) {
					var t = o[type] || o._;
					return t !== undefined ?
						t(data, type, row, meta) :
						data;
				};
			}
			else if ( source === null ) {
				// Give an empty string for rendering / sorting etc
				return function (data) { // type, row and meta also passed, but not used
					return data;
				};
			}
			else if ( typeof source === 'function' ) {
				return function (data, type, row, meta) {
					return source( data, type, row, meta );
				};
			}
			else if ( typeof source === 'string' && (source.indexOf('.') !== -1 ||
					  source.indexOf('[') !== -1 || source.indexOf('(') !== -1) )
			{
				/* If there is a . in the source string then the data source is in a
				 * nested object so we loop over the data for each level to get the next
				 * level down. On each loop we test for undefined, and if found immediately
				 * return. This allows entire objects to be missing and sDefaultContent to
				 * be used if defined, rather than throwing an error
				 */
				var fetchData = function (data, type, src) {
					var arrayNotation, funcNotation, out, innerSrc;
		
					if ( src !== "" ) {
						var a = _fnSplitObjNotation( src );
		
						for ( var i=0, iLen=a.length ; i<iLen ; i++ ) {
							// Check if we are dealing with special notation
							arrayNotation = a[i].match(__reArray);
							funcNotation = a[i].match(__reFn);
		
							if ( arrayNotation ) {
								// Array notation
								a[i] = a[i].replace(__reArray, '');
		
								// Condition allows simply [] to be passed in
								if ( a[i] !== "" ) {
									data = data[ a[i] ];
								}
								out = [];
		
								// Get the remainder of the nested object to get
								a.splice( 0, i+1 );
								innerSrc = a.join('.');
		
								// Traverse each entry in the array getting the properties requested
								if ( Array.isArray( data ) ) {
									for ( var j=0, jLen=data.length ; j<jLen ; j++ ) {
										out.push( fetchData( data[j], type, innerSrc ) );
									}
								}
		
								// If a string is given in between the array notation indicators, that
								// is used to join the strings together, otherwise an array is returned
								var join = arrayNotation[0].substring(1, arrayNotation[0].length-1);
								data = (join==="") ? out : out.join(join);
		
								// The inner call to fetchData has already traversed through the remainder
								// of the source requested, so we exit from the loop
								break;
							}
							else if ( funcNotation ) {
								// Function call
								a[i] = a[i].replace(__reFn, '');
								data = data[ a[i] ]();
								continue;
							}
		
							if ( data === null || data[ a[i] ] === undefined ) {
								return undefined;
							}
	
							data = data[ a[i] ];
						}
					}
		
					return data;
				};
		
				return function (data, type) { // row and meta also passed, but not used
					return fetchData( data, type, source );
				};
			}
			else {
				// Array or flat object mapping
				return function (data, type) { // row and meta also passed, but not used
					return data[source];
				};
			}
		}
	};
	
	
	
	/**
	 * Create a mapping object that allows camel case parameters to be looked up
	 * for their Hungarian counterparts. The mapping is stored in a private
	 * parameter called `_hungarianMap` which can be accessed on the source object.
	 *  @param {object} o
	 *  @memberof DataTable#oApi
	 */
	function _fnHungarianMap ( o )
	{
		var
			hungarian = 'a aa ai ao as b fn i m o s ',
			match,
			newKey,
			map = {};
	
		$.each( o, function (key, val) {
			match = key.match(/^([^A-Z]+?)([A-Z])/);
	
			if ( match && hungarian.indexOf(match[1]+' ') !== -1 )
			{
				newKey = key.replace( match[0], match[2].toLowerCase() );
				map[ newKey ] = key;
	
				if ( match[1] === 'o' )
				{
					_fnHungarianMap( o[key] );
				}
			}
		} );
	
		o._hungarianMap = map;
	}
	
	
	/**
	 * Convert from camel case parameters to Hungarian, based on a Hungarian map
	 * created by _fnHungarianMap.
	 *  @param {object} src The model object which holds all parameters that can be
	 *    mapped.
	 *  @param {object} user The object to convert from camel case to Hungarian.
	 *  @param {boolean} force When set to `true`, properties which already have a
	 *    Hungarian value in the `user` object will be overwritten. Otherwise they
	 *    won't be.
	 *  @memberof DataTable#oApi
	 */
	function _fnCamelToHungarian ( src, user, force )
	{
		if ( ! src._hungarianMap ) {
			_fnHungarianMap( src );
		}
	
		var hungarianKey;
	
		$.each( user, function (key, val) {
			hungarianKey = src._hungarianMap[ key ];
	
			if ( hungarianKey !== undefined && (force || user[hungarianKey] === undefined) )
			{
				// For objects, we need to buzz down into the object to copy parameters
				if ( hungarianKey.charAt(0) === 'o' )
				{
					// Copy the camelCase options over to the hungarian
					if ( ! user[ hungarianKey ] ) {
						user[ hungarianKey ] = {};
					}
					$.extend( true, user[hungarianKey], user[key] );
	
					_fnCamelToHungarian( src[hungarianKey], user[hungarianKey], force );
				}
				else {
					user[hungarianKey] = user[ key ];
				}
			}
		} );
	}
	
	
	/**
	 * Language compatibility - when certain options are given, and others aren't, we
	 * need to duplicate the values over, in order to provide backwards compatibility
	 * with older language files.
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnLanguageCompat( lang )
	{
		// Note the use of the Hungarian notation for the parameters in this method as
		// this is called after the mapping of camelCase to Hungarian
		var defaults = DataTable.defaults.oLanguage;
	
		// Default mapping
		var defaultDecimal = defaults.sDecimal;
		if ( defaultDecimal ) {
			_addNumericSort( defaultDecimal );
		}
	
		if ( lang ) {
			var zeroRecords = lang.sZeroRecords;
	
			// Backwards compatibility - if there is no sEmptyTable given, then use the same as
			// sZeroRecords - assuming that is given.
			if ( ! lang.sEmptyTable && zeroRecords &&
				defaults.sEmptyTable === "No data available in table" )
			{
				_fnMap( lang, lang, 'sZeroRecords', 'sEmptyTable' );
			}
	
			// Likewise with loading records
			if ( ! lang.sLoadingRecords && zeroRecords &&
				defaults.sLoadingRecords === "Loading..." )
			{
				_fnMap( lang, lang, 'sZeroRecords', 'sLoadingRecords' );
			}
	
			// Old parameter name of the thousands separator mapped onto the new
			if ( lang.sInfoThousands ) {
				lang.sThousands = lang.sInfoThousands;
			}
	
			var decimal = lang.sDecimal;
			if ( decimal && defaultDecimal !== decimal ) {
				_addNumericSort( decimal );
			}
		}
	}
	
	
	/**
	 * Map one parameter onto another
	 *  @param {object} o Object to map
	 *  @param {*} knew The new parameter name
	 *  @param {*} old The old parameter name
	 */
	var _fnCompatMap = function ( o, knew, old ) {
		if ( o[ knew ] !== undefined ) {
			o[ old ] = o[ knew ];
		}
	};
	
	
	/**
	 * Provide backwards compatibility for the main DT options. Note that the new
	 * options are mapped onto the old parameters, so this is an external interface
	 * change only.
	 *  @param {object} init Object to map
	 */
	function _fnCompatOpts ( init )
	{
		_fnCompatMap( init, 'ordering',      'bSort' );
		_fnCompatMap( init, 'orderMulti',    'bSortMulti' );
		_fnCompatMap( init, 'orderClasses',  'bSortClasses' );
		_fnCompatMap( init, 'orderCellsTop', 'bSortCellsTop' );
		_fnCompatMap( init, 'order',         'aaSorting' );
		_fnCompatMap( init, 'orderFixed',    'aaSortingFixed' );
		_fnCompatMap( init, 'paging',        'bPaginate' );
		_fnCompatMap( init, 'pagingType',    'sPaginationType' );
		_fnCompatMap( init, 'pageLength',    'iDisplayLength' );
		_fnCompatMap( init, 'searching',     'bFilter' );
	
		// Boolean initialisation of x-scrolling
		if ( typeof init.sScrollX === 'boolean' ) {
			init.sScrollX = init.sScrollX ? '100%' : '';
		}
		if ( typeof init.scrollX === 'boolean' ) {
			init.scrollX = init.scrollX ? '100%' : '';
		}
	
		// Column search objects are in an array, so it needs to be converted
		// element by element
		var searchCols = init.aoSearchCols;
	
		if ( searchCols ) {
			for ( var i=0, ien=searchCols.length ; i<ien ; i++ ) {
				if ( searchCols[i] ) {
					_fnCamelToHungarian( DataTable.models.oSearch, searchCols[i] );
				}
			}
		}
	}
	
	
	/**
	 * Provide backwards compatibility for column options. Note that the new options
	 * are mapped onto the old parameters, so this is an external interface change
	 * only.
	 *  @param {object} init Object to map
	 */
	function _fnCompatCols ( init )
	{
		_fnCompatMap( init, 'orderable',     'bSortable' );
		_fnCompatMap( init, 'orderData',     'aDataSort' );
		_fnCompatMap( init, 'orderSequence', 'asSorting' );
		_fnCompatMap( init, 'orderDataType', 'sortDataType' );
	
		// orderData can be given as an integer
		var dataSort = init.aDataSort;
		if ( typeof dataSort === 'number' && ! Array.isArray( dataSort ) ) {
			init.aDataSort = [ dataSort ];
		}
	}
	
	
	/**
	 * Browser feature detection for capabilities, quirks
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnBrowserDetect( settings )
	{
		// We don't need to do this every time DataTables is constructed, the values
		// calculated are specific to the browser and OS configuration which we
		// don't expect to change between initialisations
		if ( ! DataTable.__browser ) {
			var browser = {};
			DataTable.__browser = browser;
	
			// Scrolling feature / quirks detection
			var n = $('<div/>')
				.css( {
					position: 'fixed',
					top: 0,
					left: $(window).scrollLeft()*-1, // allow for scrolling
					height: 1,
					width: 1,
					overflow: 'hidden'
				} )
				.append(
					$('<div/>')
						.css( {
							position: 'absolute',
							top: 1,
							left: 1,
							width: 100,
							overflow: 'scroll'
						} )
						.append(
							$('<div/>')
								.css( {
									width: '100%',
									height: 10
								} )
						)
				)
				.appendTo( 'body' );
	
			var outer = n.children();
			var inner = outer.children();
	
			// Numbers below, in order, are:
			// inner.offsetWidth, inner.clientWidth, outer.offsetWidth, outer.clientWidth
			//
			// IE6 XP:                           100 100 100  83
			// IE7 Vista:                        100 100 100  83
			// IE 8+ Windows:                     83  83 100  83
			// Evergreen Windows:                 83  83 100  83
			// Evergreen Mac with scrollbars:     85  85 100  85
			// Evergreen Mac without scrollbars: 100 100 100 100
	
			// Get scrollbar width
			browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
	
			// IE6/7 will oversize a width 100% element inside a scrolling element, to
			// include the width of the scrollbar, while other browsers ensure the inner
			// element is contained without forcing scrolling
			browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100;
	
			// In rtl text layout, some browsers (most, but not all) will place the
			// scrollbar on the left, rather than the right.
			browser.bScrollbarLeft = Math.round( inner.offset().left ) !== 1;
	
			// IE8- don't provide height and width for getBoundingClientRect
			browser.bBounding = n[0].getBoundingClientRect().width ? true : false;
	
			n.remove();
		}
	
		$.extend( settings.oBrowser, DataTable.__browser );
		settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
	}
	
	
	/**
	 * Array.prototype reduce[Right] method, used for browsers which don't support
	 * JS 1.6. Done this way to reduce code size, since we iterate either way
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnReduce ( that, fn, init, start, end, inc )
	{
		var
			i = start,
			value,
			isSet = false;
	
		if ( init !== undefined ) {
			value = init;
			isSet = true;
		}
	
		while ( i !== end ) {
			if ( ! that.hasOwnProperty(i) ) {
				continue;
			}
	
			value = isSet ?
				fn( value, that[i], i, that ) :
				that[i];
	
			isSet = true;
			i += inc;
		}
	
		return value;
	}
	
	/**
	 * Add a column to the list used for the table with default values
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} nTh The th element for this column
	 *  @memberof DataTable#oApi
	 */
	function _fnAddColumn( oSettings, nTh )
	{
		// Add column to aoColumns array
		var oDefaults = DataTable.defaults.column;
		var iCol = oSettings.aoColumns.length;
		var oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {
			"nTh": nTh ? nTh : document.createElement('th'),
			"sTitle":    oDefaults.sTitle    ? oDefaults.sTitle    : nTh ? nTh.innerHTML : '',
			"aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
			"mData": oDefaults.mData ? oDefaults.mData : iCol,
			idx: iCol
		} );
		oSettings.aoColumns.push( oCol );
	
		// Add search object for column specific search. Note that the `searchCols[ iCol ]`
		// passed into extend can be undefined. This allows the user to give a default
		// with only some of the parameters defined, and also not give a default
		var searchCols = oSettings.aoPreSearchCols;
		searchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch, searchCols[ iCol ] );
	
		// Use the default column options function to initialise classes etc
		_fnColumnOptions( oSettings, iCol, $(nTh).data() );
	}
	
	
	/**
	 * Apply options for a column
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iCol column index to consider
	 *  @param {object} oOptions object with sType, bVisible and bSearchable etc
	 *  @memberof DataTable#oApi
	 */
	function _fnColumnOptions( oSettings, iCol, oOptions )
	{
		var oCol = oSettings.aoColumns[ iCol ];
		var oClasses = oSettings.oClasses;
		var th = $(oCol.nTh);
	
		// Try to get width information from the DOM. We can't get it from CSS
		// as we'd need to parse the CSS stylesheet. `width` option can override
		if ( ! oCol.sWidthOrig ) {
			// Width attribute
			oCol.sWidthOrig = th.attr('width') || null;
	
			// Style attribute
			var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);
			if ( t ) {
				oCol.sWidthOrig = t[1];
			}
		}
	
		/* User specified column options */
		if ( oOptions !== undefined && oOptions !== null )
		{
			// Backwards compatibility
			_fnCompatCols( oOptions );
	
			// Map camel case parameters to their Hungarian counterparts
			_fnCamelToHungarian( DataTable.defaults.column, oOptions, true );
	
			/* Backwards compatibility for mDataProp */
			if ( oOptions.mDataProp !== undefined && !oOptions.mData )
			{
				oOptions.mData = oOptions.mDataProp;
			}
	
			if ( oOptions.sType )
			{
				oCol._sManualType = oOptions.sType;
			}
	
			// `class` is a reserved word in Javascript, so we need to provide
			// the ability to use a valid name for the camel case input
			if ( oOptions.className && ! oOptions.sClass )
			{
				oOptions.sClass = oOptions.className;
			}
			if ( oOptions.sClass ) {
				th.addClass( oOptions.sClass );
			}
	
			var origClass = oCol.sClass;
	
			$.extend( oCol, oOptions );
			_fnMap( oCol, oOptions, "sWidth", "sWidthOrig" );
	
			// Merge class from previously defined classes with this one, rather than just
			// overwriting it in the extend above
			if (origClass !== oCol.sClass) {
				oCol.sClass = origClass + ' ' + oCol.sClass;
			}
	
			/* iDataSort to be applied (backwards compatibility), but aDataSort will take
			 * priority if defined
			 */
			if ( oOptions.iDataSort !== undefined )
			{
				oCol.aDataSort = [ oOptions.iDataSort ];
			}
			_fnMap( oCol, oOptions, "aDataSort" );
		}
	
		/* Cache the data get and set functions for speed */
		var mDataSrc = oCol.mData;
		var mData = _fnGetObjectDataFn( mDataSrc );
		var mRender = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : null;
	
		var attrTest = function( src ) {
			return typeof src === 'string' && src.indexOf('@') !== -1;
		};
		oCol._bAttrSrc = $.isPlainObject( mDataSrc ) && (
			attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
		);
		oCol._setter = null;
	
		oCol.fnGetData = function (rowData, type, meta) {
			var innerData = mData( rowData, type, undefined, meta );
	
			return mRender && type ?
				mRender( innerData, type, rowData, meta ) :
				innerData;
		};
		oCol.fnSetData = function ( rowData, val, meta ) {
			return _fnSetObjectDataFn( mDataSrc )( rowData, val, meta );
		};
	
		// Indicate if DataTables should read DOM data as an object or array
		// Used in _fnGetRowElements
		if ( typeof mDataSrc !== 'number' && ! oCol._isArrayHost ) {
			oSettings._rowReadObject = true;
		}
	
		/* Feature sorting overrides column specific when off */
		if ( !oSettings.oFeatures.bSort )
		{
			oCol.bSortable = false;
			th.addClass( oClasses.sSortableNone ); // Have to add class here as order event isn't called
		}
	
		/* Check that the class assignment is correct for sorting */
		var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
		var bDesc = $.inArray('desc', oCol.asSorting) !== -1;
		if ( !oCol.bSortable || (!bAsc && !bDesc) )
		{
			oCol.sSortingClass = oClasses.sSortableNone;
			oCol.sSortingClassJUI = "";
		}
		else if ( bAsc && !bDesc )
		{
			oCol.sSortingClass = oClasses.sSortableAsc;
			oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
		}
		else if ( !bAsc && bDesc )
		{
			oCol.sSortingClass = oClasses.sSortableDesc;
			oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
		}
		else
		{
			oCol.sSortingClass = oClasses.sSortable;
			oCol.sSortingClassJUI = oClasses.sSortJUI;
		}
	}
	
	
	/**
	 * Adjust the table column widths for new data. Note: you would probably want to
	 * do a redraw after calling this function!
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnAdjustColumnSizing ( settings )
	{
		/* Not interested in doing column width calculation if auto-width is disabled */
		if ( settings.oFeatures.bAutoWidth !== false )
		{
			var columns = settings.aoColumns;
	
			_fnCalculateColumnWidths( settings );
			for ( var i=0 , iLen=columns.length ; i<iLen ; i++ )
			{
				columns[i].nTh.style.width = columns[i].sWidth;
			}
		}
	
		var scroll = settings.oScroll;
		if ( scroll.sY !== '' || scroll.sX !== '')
		{
			_fnScrollDraw( settings );
		}
	
		_fnCallbackFire( settings, null, 'column-sizing', [settings] );
	}
	
	
	/**
	 * Convert the index of a visible column to the index in the data array (take account
	 * of hidden columns)
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iMatch Visible column index to lookup
	 *  @returns {int} i the data index
	 *  @memberof DataTable#oApi
	 */
	function _fnVisibleToColumnIndex( oSettings, iMatch )
	{
		var aiVis = _fnGetColumns( oSettings, 'bVisible' );
	
		return typeof aiVis[iMatch] === 'number' ?
			aiVis[iMatch] :
			null;
	}
	
	
	/**
	 * Convert the index of an index in the data array and convert it to the visible
	 *   column index (take account of hidden columns)
	 *  @param {int} iMatch Column index to lookup
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {int} i the data index
	 *  @memberof DataTable#oApi
	 */
	function _fnColumnIndexToVisible( oSettings, iMatch )
	{
		var aiVis = _fnGetColumns( oSettings, 'bVisible' );
		var iPos = $.inArray( iMatch, aiVis );
	
		return iPos !== -1 ? iPos : null;
	}
	
	
	/**
	 * Get the number of visible columns
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {int} i the number of visible columns
	 *  @memberof DataTable#oApi
	 */
	function _fnVisbleColumns( oSettings )
	{
		var vis = 0;
	
		// No reduce in IE8, use a loop for now
		$.each( oSettings.aoColumns, function ( i, col ) {
			if ( col.bVisible && $(col.nTh).css('display') !== 'none' ) {
				vis++;
			}
		} );
	
		return vis;
	}
	
	
	/**
	 * Get an array of column indexes that match a given property
	 *  @param {object} oSettings dataTables settings object
	 *  @param {string} sParam Parameter in aoColumns to look for - typically
	 *    bVisible or bSearchable
	 *  @returns {array} Array of indexes with matched properties
	 *  @memberof DataTable#oApi
	 */
	function _fnGetColumns( oSettings, sParam )
	{
		var a = [];
	
		$.map( oSettings.aoColumns, function(val, i) {
			if ( val[sParam] ) {
				a.push( i );
			}
		} );
	
		return a;
	}
	
	
	/**
	 * Calculate the 'type' of a column
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnColumnTypes ( settings )
	{
		var columns = settings.aoColumns;
		var data = settings.aoData;
		var types = DataTable.ext.type.detect;
		var i, ien, j, jen, k, ken;
		var col, cell, detectedType, cache;
	
		// For each column, spin over the 
		for ( i=0, ien=columns.length ; i<ien ; i++ ) {
			col = columns[i];
			cache = [];
	
			if ( ! col.sType && col._sManualType ) {
				col.sType = col._sManualType;
			}
			else if ( ! col.sType ) {
				for ( j=0, jen=types.length ; j<jen ; j++ ) {
					for ( k=0, ken=data.length ; k<ken ; k++ ) {
						// Use a cache array so we only need to get the type data
						// from the formatter once (when using multiple detectors)
						if ( cache[k] === undefined ) {
							cache[k] = _fnGetCellData( settings, k, i, 'type' );
						}
	
						detectedType = types[j]( cache[k], settings );
	
						// If null, then this type can't apply to this column, so
						// rather than testing all cells, break out. There is an
						// exception for the last type which is `html`. We need to
						// scan all rows since it is possible to mix string and HTML
						// types
						if ( ! detectedType && j !== types.length-1 ) {
							break;
						}
	
						// Only a single match is needed for html type since it is
						// bottom of the pile and very similar to string - but it
						// must not be empty
						if ( detectedType === 'html' && ! _empty(cache[k]) ) {
							break;
						}
					}
	
					// Type is valid for all data points in the column - use this
					// type
					if ( detectedType ) {
						col.sType = detectedType;
						break;
					}
				}
	
				// Fall back - if no type was detected, always use string
				if ( ! col.sType ) {
					col.sType = 'string';
				}
			}
		}
	}
	
	
	/**
	 * Take the column definitions and static columns arrays and calculate how
	 * they relate to column indexes. The callback function will then apply the
	 * definition found for a column to a suitable configuration object.
	 *  @param {object} oSettings dataTables settings object
	 *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
	 *  @param {array} aoCols The aoColumns array that defines columns individually
	 *  @param {function} fn Callback function - takes two parameters, the calculated
	 *    column index and the definition for that column.
	 *  @memberof DataTable#oApi
	 */
	function _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, fn )
	{
		var i, iLen, j, jLen, k, kLen, def;
		var columns = oSettings.aoColumns;
	
		// Column definitions with aTargets
		if ( aoColDefs )
		{
			/* Loop over the definitions array - loop in reverse so first instance has priority */
			for ( i=aoColDefs.length-1 ; i>=0 ; i-- )
			{
				def = aoColDefs[i];
	
				/* Each definition can target multiple columns, as it is an array */
				var aTargets = def.target !== undefined
					? def.target
					: def.targets !== undefined
						? def.targets
						: def.aTargets;
	
				if ( ! Array.isArray( aTargets ) )
				{
					aTargets = [ aTargets ];
				}
	
				for ( j=0, jLen=aTargets.length ; j<jLen ; j++ )
				{
					if ( typeof aTargets[j] === 'number' && aTargets[j] >= 0 )
					{
						/* Add columns that we don't yet know about */
						while( columns.length <= aTargets[j] )
						{
							_fnAddColumn( oSettings );
						}
	
						/* Integer, basic index */
						fn( aTargets[j], def );
					}
					else if ( typeof aTargets[j] === 'number' && aTargets[j] < 0 )
					{
						/* Negative integer, right to left column counting */
						fn( columns.length+aTargets[j], def );
					}
					else if ( typeof aTargets[j] === 'string' )
					{
						/* Class name matching on TH element */
						for ( k=0, kLen=columns.length ; k<kLen ; k++ )
						{
							if ( aTargets[j] == "_all" ||
							     $(columns[k].nTh).hasClass( aTargets[j] ) )
							{
								fn( k, def );
							}
						}
					}
				}
			}
		}
	
		// Statically defined columns array
		if ( aoCols )
		{
			for ( i=0, iLen=aoCols.length ; i<iLen ; i++ )
			{
				fn( i, aoCols[i] );
			}
		}
	}
	
	/**
	 * Add a data array to the table, creating DOM node etc. This is the parallel to
	 * _fnGatherData, but for adding rows from a Javascript source, rather than a
	 * DOM source.
	 *  @param {object} oSettings dataTables settings object
	 *  @param {array} aData data array to be added
	 *  @param {node} [nTr] TR element to add to the table - optional. If not given,
	 *    DataTables will create a row automatically
	 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
	 *    if nTr is.
	 *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
	 *  @memberof DataTable#oApi
	 */
	function _fnAddData ( oSettings, aDataIn, nTr, anTds )
	{
		/* Create the object for storing information about this new row */
		var iRow = oSettings.aoData.length;
		var oData = $.extend( true, {}, DataTable.models.oRow, {
			src: nTr ? 'dom' : 'data',
			idx: iRow
		} );
	
		oData._aData = aDataIn;
		oSettings.aoData.push( oData );
	
		/* Create the cells */
		var nTd, sThisType;
		var columns = oSettings.aoColumns;
	
		// Invalidate the column types as the new data needs to be revalidated
		for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
		{
			columns[i].sType = null;
		}
	
		/* Add to the display array */
		oSettings.aiDisplayMaster.push( iRow );
	
		var id = oSettings.rowIdFn( aDataIn );
		if ( id !== undefined ) {
			oSettings.aIds[ id ] = oData;
		}
	
		/* Create the DOM information, or register it if already present */
		if ( nTr || ! oSettings.oFeatures.bDeferRender )
		{
			_fnCreateTr( oSettings, iRow, nTr, anTds );
		}
	
		return iRow;
	}
	
	
	/**
	 * Add one or more TR elements to the table. Generally we'd expect to
	 * use this for reading data from a DOM sourced table, but it could be
	 * used for an TR element. Note that if a TR is given, it is used (i.e.
	 * it is not cloned).
	 *  @param {object} settings dataTables settings object
	 *  @param {array|node|jQuery} trs The TR element(s) to add to the table
	 *  @returns {array} Array of indexes for the added rows
	 *  @memberof DataTable#oApi
	 */
	function _fnAddTr( settings, trs )
	{
		var row;
	
		// Allow an individual node to be passed in
		if ( ! (trs instanceof $) ) {
			trs = $(trs);
		}
	
		return trs.map( function (i, el) {
			row = _fnGetRowElements( settings, el );
			return _fnAddData( settings, row.data, el, row.cells );
		} );
	}
	
	
	/**
	 * Take a TR element and convert it to an index in aoData
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} n the TR element to find
	 *  @returns {int} index if the node is found, null if not
	 *  @memberof DataTable#oApi
	 */
	function _fnNodeToDataIndex( oSettings, n )
	{
		return (n._DT_RowIndex!==undefined) ? n._DT_RowIndex : null;
	}
	
	
	/**
	 * Take a TD element and convert it into a column data index (not the visible index)
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iRow The row number the TD/TH can be found in
	 *  @param {node} n The TD/TH element to find
	 *  @returns {int} index if the node is found, -1 if not
	 *  @memberof DataTable#oApi
	 */
	function _fnNodeToColumnIndex( oSettings, iRow, n )
	{
		return $.inArray( n, oSettings.aoData[ iRow ].anCells );
	}
	
	
	/**
	 * Get the data for a given cell from the internal cache, taking into account data mapping
	 *  @param {object} settings dataTables settings object
	 *  @param {int} rowIdx aoData row id
	 *  @param {int} colIdx Column index
	 *  @param {string} type data get type ('display', 'type' 'filter|search' 'sort|order')
	 *  @returns {*} Cell data
	 *  @memberof DataTable#oApi
	 */
	function _fnGetCellData( settings, rowIdx, colIdx, type )
	{
		if (type === 'search') {
			type = 'filter';
		}
		else if (type === 'order') {
			type = 'sort';
		}
	
		var draw           = settings.iDraw;
		var col            = settings.aoColumns[colIdx];
		var rowData        = settings.aoData[rowIdx]._aData;
		var defaultContent = col.sDefaultContent;
		var cellData       = col.fnGetData( rowData, type, {
			settings: settings,
			row:      rowIdx,
			col:      colIdx
		} );
	
		if ( cellData === undefined ) {
			if ( settings.iDrawError != draw && defaultContent === null ) {
				_fnLog( settings, 0, "Requested unknown parameter "+
					(typeof col.mData=='function' ? '{function}' : "'"+col.mData+"'")+
					" for row "+rowIdx+", column "+colIdx, 4 );
				settings.iDrawError = draw;
			}
			return defaultContent;
		}
	
		// When the data source is null and a specific data type is requested (i.e.
		// not the original data), we can use default column data
		if ( (cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined ) {
			cellData = defaultContent;
		}
		else if ( typeof cellData === 'function' ) {
			// If the data source is a function, then we run it and use the return,
			// executing in the scope of the data object (for instances)
			return cellData.call( rowData );
		}
	
		if ( cellData === null && type === 'display' ) {
			return '';
		}
	
		if ( type === 'filter' ) {
			var fomatters = DataTable.ext.type.search;
	
			if ( fomatters[ col.sType ] ) {
				cellData = fomatters[ col.sType ]( cellData );
			}
		}
	
		return cellData;
	}
	
	
	/**
	 * Set the value for a specific cell, into the internal data cache
	 *  @param {object} settings dataTables settings object
	 *  @param {int} rowIdx aoData row id
	 *  @param {int} colIdx Column index
	 *  @param {*} val Value to set
	 *  @memberof DataTable#oApi
	 */
	function _fnSetCellData( settings, rowIdx, colIdx, val )
	{
		var col     = settings.aoColumns[colIdx];
		var rowData = settings.aoData[rowIdx]._aData;
	
		col.fnSetData( rowData, val, {
			settings: settings,
			row:      rowIdx,
			col:      colIdx
		}  );
	}
	
	
	// Private variable that is used to match action syntax in the data property object
	var __reArray = /\[.*?\]$/;
	var __reFn = /\(\)$/;
	
	/**
	 * Split string on periods, taking into account escaped periods
	 * @param  {string} str String to split
	 * @return {array} Split string
	 */
	function _fnSplitObjNotation( str )
	{
		return $.map( str.match(/(\\.|[^\.])+/g) || [''], function ( s ) {
			return s.replace(/\\\./g, '.');
		} );
	}
	
	
	/**
	 * Return a function that can be used to get data from a source object, taking
	 * into account the ability to use nested objects as a source
	 *  @param {string|int|function} mSource The data source for the object
	 *  @returns {function} Data get function
	 *  @memberof DataTable#oApi
	 */
	var _fnGetObjectDataFn = DataTable.util.get;
	
	
	/**
	 * Return a function that can be used to set data from a source object, taking
	 * into account the ability to use nested objects as a source
	 *  @param {string|int|function} mSource The data source for the object
	 *  @returns {function} Data set function
	 *  @memberof DataTable#oApi
	 */
	var _fnSetObjectDataFn = DataTable.util.set;
	
	
	/**
	 * Return an array with the full table data
	 *  @param {object} oSettings dataTables settings object
	 *  @returns array {array} aData Master data array
	 *  @memberof DataTable#oApi
	 */
	function _fnGetDataMaster ( settings )
	{
		return _pluck( settings.aoData, '_aData' );
	}
	
	
	/**
	 * Nuke the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnClearTable( settings )
	{
		settings.aoData.length = 0;
		settings.aiDisplayMaster.length = 0;
		settings.aiDisplay.length = 0;
		settings.aIds = {};
	}
	
	
	 /**
	 * Take an array of integers (index array) and remove a target integer (value - not
	 * the key!)
	 *  @param {array} a Index array to target
	 *  @param {int} iTarget value to find
	 *  @memberof DataTable#oApi
	 */
	function _fnDeleteIndex( a, iTarget, splice )
	{
		var iTargetIndex = -1;
	
		for ( var i=0, iLen=a.length ; i<iLen ; i++ )
		{
			if ( a[i] == iTarget )
			{
				iTargetIndex = i;
			}
			else if ( a[i] > iTarget )
			{
				a[i]--;
			}
		}
	
		if ( iTargetIndex != -1 && splice === undefined )
		{
			a.splice( iTargetIndex, 1 );
		}
	}
	
	
	/**
	 * Mark cached data as invalid such that a re-read of the data will occur when
	 * the cached data is next requested. Also update from the data source object.
	 *
	 * @param {object} settings DataTables settings object
	 * @param {int}    rowIdx   Row index to invalidate
	 * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
	 *     or 'data'
	 * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
	 *     row will be invalidated
	 * @memberof DataTable#oApi
	 *
	 * @todo For the modularisation of v1.11 this will need to become a callback, so
	 *   the sort and filter methods can subscribe to it. That will required
	 *   initialisation options for sorting, which is why it is not already baked in
	 */
	function _fnInvalidate( settings, rowIdx, src, colIdx )
	{
		var row = settings.aoData[ rowIdx ];
		var i, ien;
		var cellWrite = function ( cell, col ) {
			// This is very frustrating, but in IE if you just write directly
			// to innerHTML, and elements that are overwritten are GC'ed,
			// even if there is a reference to them elsewhere
			while ( cell.childNodes.length ) {
				cell.removeChild( cell.firstChild );
			}
	
			cell.innerHTML = _fnGetCellData( settings, rowIdx, col, 'display' );
		};
	
		// Are we reading last data from DOM or the data object?
		if ( src === 'dom' || ((! src || src === 'auto') && row.src === 'dom') ) {
			// Read the data from the DOM
			row._aData = _fnGetRowElements(
					settings, row, colIdx, colIdx === undefined ? undefined : row._aData
				)
				.data;
		}
		else {
			// Reading from data object, update the DOM
			var cells = row.anCells;
	
			if ( cells ) {
				if ( colIdx !== undefined ) {
					cellWrite( cells[colIdx], colIdx );
				}
				else {
					for ( i=0, ien=cells.length ; i<ien ; i++ ) {
						cellWrite( cells[i], i );
					}
				}
			}
		}
	
		// For both row and cell invalidation, the cached data for sorting and
		// filtering is nulled out
		row._aSortData = null;
		row._aFilterData = null;
	
		// Invalidate the type for a specific column (if given) or all columns since
		// the data might have changed
		var cols = settings.aoColumns;
		if ( colIdx !== undefined ) {
			cols[ colIdx ].sType = null;
		}
		else {
			for ( i=0, ien=cols.length ; i<ien ; i++ ) {
				cols[i].sType = null;
			}
	
			// Update DataTables special `DT_*` attributes for the row
			_fnRowAttributes( settings, row );
		}
	}
	
	
	/**
	 * Build a data source object from an HTML row, reading the contents of the
	 * cells that are in the row.
	 *
	 * @param {object} settings DataTables settings object
	 * @param {node|object} TR element from which to read data or existing row
	 *   object from which to re-read the data from the cells
	 * @param {int} [colIdx] Optional column index
	 * @param {array|object} [d] Data source object. If `colIdx` is given then this
	 *   parameter should also be given and will be used to write the data into.
	 *   Only the column in question will be written
	 * @returns {object} Object with two parameters: `data` the data read, in
	 *   document order, and `cells` and array of nodes (they can be useful to the
	 *   caller, so rather than needing a second traversal to get them, just return
	 *   them from here).
	 * @memberof DataTable#oApi
	 */
	function _fnGetRowElements( settings, row, colIdx, d )
	{
		var
			tds = [],
			td = row.firstChild,
			name, col, o, i=0, contents,
			columns = settings.aoColumns,
			objectRead = settings._rowReadObject;
	
		// Allow the data object to be passed in, or construct
		d = d !== undefined ?
			d :
			objectRead ?
				{} :
				[];
	
		var attr = function ( str, td  ) {
			if ( typeof str === 'string' ) {
				var idx = str.indexOf('@');
	
				if ( idx !== -1 ) {
					var attr = str.substring( idx+1 );
					var setter = _fnSetObjectDataFn( str );
					setter( d, td.getAttribute( attr ) );
				}
			}
		};
	
		// Read data from a cell and store into the data object
		var cellProcess = function ( cell ) {
			if ( colIdx === undefined || colIdx === i ) {
				col = columns[i];
				contents = (cell.innerHTML).trim();
	
				if ( col && col._bAttrSrc ) {
					var setter = _fnSetObjectDataFn( col.mData._ );
					setter( d, contents );
	
					attr( col.mData.sort, cell );
					attr( col.mData.type, cell );
					attr( col.mData.filter, cell );
				}
				else {
					// Depending on the `data` option for the columns the data can
					// be read to either an object or an array.
					if ( objectRead ) {
						if ( ! col._setter ) {
							// Cache the setter function
							col._setter = _fnSetObjectDataFn( col.mData );
						}
						col._setter( d, contents );
					}
					else {
						d[i] = contents;
					}
				}
			}
	
			i++;
		};
	
		if ( td ) {
			// `tr` element was passed in
			while ( td ) {
				name = td.nodeName.toUpperCase();
	
				if ( name == "TD" || name == "TH" ) {
					cellProcess( td );
					tds.push( td );
				}
	
				td = td.nextSibling;
			}
		}
		else {
			// Existing row object passed in
			tds = row.anCells;
	
			for ( var j=0, jen=tds.length ; j<jen ; j++ ) {
				cellProcess( tds[j] );
			}
		}
	
		// Read the ID from the DOM if present
		var rowNode = row.firstChild ? row : row.nTr;
	
		if ( rowNode ) {
			var id = rowNode.getAttribute( 'id' );
	
			if ( id ) {
				_fnSetObjectDataFn( settings.rowId )( d, id );
			}
		}
	
		return {
			data: d,
			cells: tds
		};
	}
	/**
	 * Create a new TR element (and it's TD children) for a row
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iRow Row to consider
	 *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
	 *    DataTables will create a row automatically
	 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
	 *    if nTr is.
	 *  @memberof DataTable#oApi
	 */
	function _fnCreateTr ( oSettings, iRow, nTrIn, anTds )
	{
		var
			row = oSettings.aoData[iRow],
			rowData = row._aData,
			cells = [],
			nTr, nTd, oCol,
			i, iLen, create;
	
		if ( row.nTr === null )
		{
			nTr = nTrIn || document.createElement('tr');
	
			row.nTr = nTr;
			row.anCells = cells;
	
			/* Use a private property on the node to allow reserve mapping from the node
			 * to the aoData array for fast look up
			 */
			nTr._DT_RowIndex = iRow;
	
			/* Special parameters can be given by the data source to be used on the row */
			_fnRowAttributes( oSettings, row );
	
			/* Process each column */
			for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				oCol = oSettings.aoColumns[i];
				create = nTrIn ? false : true;
	
				nTd = create ? document.createElement( oCol.sCellType ) : anTds[i];
	
				if (! nTd) {
					_fnLog( oSettings, 0, 'Incorrect column count', 18 );
				}
	
				nTd._DT_CellIndex = {
					row: iRow,
					column: i
				};
				
				cells.push( nTd );
	
				// Need to create the HTML if new, or if a rendering function is defined
				if ( create || ((oCol.mRender || oCol.mData !== i) &&
					 (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i+'.display')
				)) {
					nTd.innerHTML = _fnGetCellData( oSettings, iRow, i, 'display' );
				}
	
				/* Add user defined class */
				if ( oCol.sClass )
				{
					nTd.className += ' '+oCol.sClass;
				}
	
				// Visibility - add or remove as required
				if ( oCol.bVisible && ! nTrIn )
				{
					nTr.appendChild( nTd );
				}
				else if ( ! oCol.bVisible && nTrIn )
				{
					nTd.parentNode.removeChild( nTd );
				}
	
				if ( oCol.fnCreatedCell )
				{
					oCol.fnCreatedCell.call( oSettings.oInstance,
						nTd, _fnGetCellData( oSettings, iRow, i ), rowData, iRow, i
					);
				}
			}
	
			_fnCallbackFire( oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow, cells] );
		}
	}
	
	
	/**
	 * Add attributes to a row based on the special `DT_*` parameters in a data
	 * source object.
	 *  @param {object} settings DataTables settings object
	 *  @param {object} DataTables row object for the row to be modified
	 *  @memberof DataTable#oApi
	 */
	function _fnRowAttributes( settings, row )
	{
		var tr = row.nTr;
		var data = row._aData;
	
		if ( tr ) {
			var id = settings.rowIdFn( data );
	
			if ( id ) {
				tr.id = id;
			}
	
			if ( data.DT_RowClass ) {
				// Remove any classes added by DT_RowClass before
				var a = data.DT_RowClass.split(' ');
				row.__rowc = row.__rowc ?
					_unique( row.__rowc.concat( a ) ) :
					a;
	
				$(tr)
					.removeClass( row.__rowc.join(' ') )
					.addClass( data.DT_RowClass );
			}
	
			if ( data.DT_RowAttr ) {
				$(tr).attr( data.DT_RowAttr );
			}
	
			if ( data.DT_RowData ) {
				$(tr).data( data.DT_RowData );
			}
		}
	}
	
	
	/**
	 * Create the HTML header for the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnBuildHead( oSettings )
	{
		var i, ien, cell, row, column;
		var thead = oSettings.nTHead;
		var tfoot = oSettings.nTFoot;
		var createHeader = $('th, td', thead).length === 0;
		var classes = oSettings.oClasses;
		var columns = oSettings.aoColumns;
	
		if ( createHeader ) {
			row = $('<tr/>').appendTo( thead );
		}
	
		for ( i=0, ien=columns.length ; i<ien ; i++ ) {
			column = columns[i];
			cell = $( column.nTh ).addClass( column.sClass );
	
			if ( createHeader ) {
				cell.appendTo( row );
			}
	
			// 1.11 move into sorting
			if ( oSettings.oFeatures.bSort ) {
				cell.addClass( column.sSortingClass );
	
				if ( column.bSortable !== false ) {
					cell
						.attr( 'tabindex', oSettings.iTabIndex )
						.attr( 'aria-controls', oSettings.sTableId );
	
					_fnSortAttachListener( oSettings, column.nTh, i );
				}
			}
	
			if ( column.sTitle != cell[0].innerHTML ) {
				cell.html( column.sTitle );
			}
	
			_fnRenderer( oSettings, 'header' )(
				oSettings, cell, column, classes
			);
		}
	
		if ( createHeader ) {
			_fnDetectHeader( oSettings.aoHeader, thead );
		}
	
		/* Deal with the footer - add classes if required */
		$(thead).children('tr').children('th, td').addClass( classes.sHeaderTH );
		$(tfoot).children('tr').children('th, td').addClass( classes.sFooterTH );
	
		// Cache the footer cells. Note that we only take the cells from the first
		// row in the footer. If there is more than one row the user wants to
		// interact with, they need to use the table().foot() method. Note also this
		// allows cells to be used for multiple columns using colspan
		if ( tfoot !== null ) {
			var cells = oSettings.aoFooter[0];
	
			for ( i=0, ien=cells.length ; i<ien ; i++ ) {
				column = columns[i];
	
				if (column) {
					column.nTf = cells[i].cell;
		
					if ( column.sClass ) {
						$(column.nTf).addClass( column.sClass );
					}
				}
				else {
					_fnLog( oSettings, 0, 'Incorrect column count', 18 );
				}
			}
		}
	}
	
	
	/**
	 * Draw the header (or footer) element based on the column visibility states. The
	 * methodology here is to use the layout array from _fnDetectHeader, modified for
	 * the instantaneous column visibility, to construct the new layout. The grid is
	 * traversed over cell at a time in a rows x columns grid fashion, although each
	 * cell insert can cover multiple elements in the grid - which is tracks using the
	 * aApplied array. Cell inserts in the grid will only occur where there isn't
	 * already a cell in that position.
	 *  @param {object} oSettings dataTables settings object
	 *  @param array {objects} aoSource Layout array from _fnDetectHeader
	 *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
	 *  @memberof DataTable#oApi
	 */
	function _fnDrawHead( oSettings, aoSource, bIncludeHidden )
	{
		var i, iLen, j, jLen, k, kLen, n, nLocalTr;
		var aoLocal = [];
		var aApplied = [];
		var iColumns = oSettings.aoColumns.length;
		var iRowspan, iColspan;
	
		if ( ! aoSource )
		{
			return;
		}
	
		if (  bIncludeHidden === undefined )
		{
			bIncludeHidden = false;
		}
	
		/* Make a copy of the master layout array, but without the visible columns in it */
		for ( i=0, iLen=aoSource.length ; i<iLen ; i++ )
		{
			aoLocal[i] = aoSource[i].slice();
			aoLocal[i].nTr = aoSource[i].nTr;
	
			/* Remove any columns which are currently hidden */
			for ( j=iColumns-1 ; j>=0 ; j-- )
			{
				if ( !oSettings.aoColumns[j].bVisible && !bIncludeHidden )
				{
					aoLocal[i].splice( j, 1 );
				}
			}
	
			/* Prep the applied array - it needs an element for each row */
			aApplied.push( [] );
		}
	
		for ( i=0, iLen=aoLocal.length ; i<iLen ; i++ )
		{
			nLocalTr = aoLocal[i].nTr;
	
			/* All cells are going to be replaced, so empty out the row */
			if ( nLocalTr )
			{
				while( (n = nLocalTr.firstChild) )
				{
					nLocalTr.removeChild( n );
				}
			}
	
			for ( j=0, jLen=aoLocal[i].length ; j<jLen ; j++ )
			{
				iRowspan = 1;
				iColspan = 1;
	
				/* Check to see if there is already a cell (row/colspan) covering our target
				 * insert point. If there is, then there is nothing to do.
				 */
				if ( aApplied[i][j] === undefined )
				{
					nLocalTr.appendChild( aoLocal[i][j].cell );
					aApplied[i][j] = 1;
	
					/* Expand the cell to cover as many rows as needed */
					while ( aoLocal[i+iRowspan] !== undefined &&
					        aoLocal[i][j].cell == aoLocal[i+iRowspan][j].cell )
					{
						aApplied[i+iRowspan][j] = 1;
						iRowspan++;
					}
	
					/* Expand the cell to cover as many columns as needed */
					while ( aoLocal[i][j+iColspan] !== undefined &&
					        aoLocal[i][j].cell == aoLocal[i][j+iColspan].cell )
					{
						/* Must update the applied array over the rows for the columns */
						for ( k=0 ; k<iRowspan ; k++ )
						{
							aApplied[i+k][j+iColspan] = 1;
						}
						iColspan++;
					}
	
					/* Do the actual expansion in the DOM */
					$(aoLocal[i][j].cell)
						.attr('rowspan', iRowspan)
						.attr('colspan', iColspan);
				}
			}
		}
	}
	
	
	/**
	 * Insert the required TR nodes into the table for display
	 *  @param {object} oSettings dataTables settings object
	 *  @param ajaxComplete true after ajax call to complete rendering
	 *  @memberof DataTable#oApi
	 */
	function _fnDraw( oSettings, ajaxComplete )
	{
		// Allow for state saving and a custom start position
		_fnStart( oSettings );
	
		/* Provide a pre-callback function which can be used to cancel the draw is false is returned */
		var aPreDraw = _fnCallbackFire( oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings] );
		if ( $.inArray( false, aPreDraw ) !== -1 )
		{
			_fnProcessingDisplay( oSettings, false );
			return;
		}
	
		var anRows = [];
		var iRowCount = 0;
		var asStripeClasses = oSettings.asStripeClasses;
		var iStripes = asStripeClasses.length;
		var oLang = oSettings.oLanguage;
		var bServerSide = _fnDataSource( oSettings ) == 'ssp';
		var aiDisplay = oSettings.aiDisplay;
		var iDisplayStart = oSettings._iDisplayStart;
		var iDisplayEnd = oSettings.fnDisplayEnd();
	
		oSettings.bDrawing = true;
	
		/* Server-side processing draw intercept */
		if ( oSettings.bDeferLoading )
		{
			oSettings.bDeferLoading = false;
			oSettings.iDraw++;
			_fnProcessingDisplay( oSettings, false );
		}
		else if ( !bServerSide )
		{
			oSettings.iDraw++;
		}
		else if ( !oSettings.bDestroying && !ajaxComplete)
		{
			_fnAjaxUpdate( oSettings );
			return;
		}
	
		if ( aiDisplay.length !== 0 )
		{
			var iStart = bServerSide ? 0 : iDisplayStart;
			var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
	
			for ( var j=iStart ; j<iEnd ; j++ )
			{
				var iDataIndex = aiDisplay[j];
				var aoData = oSettings.aoData[ iDataIndex ];
				if ( aoData.nTr === null )
				{
					_fnCreateTr( oSettings, iDataIndex );
				}
	
				var nRow = aoData.nTr;
	
				/* Remove the old striping classes and then add the new one */
				if ( iStripes !== 0 )
				{
					var sStripe = asStripeClasses[ iRowCount % iStripes ];
					if ( aoData._sRowStripe != sStripe )
					{
						$(nRow).removeClass( aoData._sRowStripe ).addClass( sStripe );
						aoData._sRowStripe = sStripe;
					}
				}
	
				// Row callback functions - might want to manipulate the row
				// iRowCount and j are not currently documented. Are they at all
				// useful?
				_fnCallbackFire( oSettings, 'aoRowCallback', null,
					[nRow, aoData._aData, iRowCount, j, iDataIndex] );
	
				anRows.push( nRow );
				iRowCount++;
			}
		}
		else
		{
			/* Table is empty - create a row with an empty message in it */
			var sZero = oLang.sZeroRecords;
			if ( oSettings.iDraw == 1 &&  _fnDataSource( oSettings ) == 'ajax' )
			{
				sZero = oLang.sLoadingRecords;
			}
			else if ( oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0 )
			{
				sZero = oLang.sEmptyTable;
			}
	
			anRows[ 0 ] = $( '<tr/>', { 'class': iStripes ? asStripeClasses[0] : '' } )
				.append( $('<td />', {
					'valign':  'top',
					'colSpan': _fnVisbleColumns( oSettings ),
					'class':   oSettings.oClasses.sRowEmpty
				} ).html( sZero ) )[0];
		}
	
		/* Header and footer callbacks */
		_fnCallbackFire( oSettings, 'aoHeaderCallback', 'header', [ $(oSettings.nTHead).children('tr')[0],
			_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
	
		_fnCallbackFire( oSettings, 'aoFooterCallback', 'footer', [ $(oSettings.nTFoot).children('tr')[0],
			_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
	
		var body = $(oSettings.nTBody);
	
		body.children().detach();
		body.append( $(anRows) );
	
		/* Call all required callback functions for the end of a draw */
		_fnCallbackFire( oSettings, 'aoDrawCallback', 'draw', [oSettings] );
	
		/* Draw is complete, sorting and filtering must be as well */
		oSettings.bSorted = false;
		oSettings.bFiltered = false;
		oSettings.bDrawing = false;
	}
	
	
	/**
	 * Redraw the table - taking account of the various features which are enabled
	 *  @param {object} oSettings dataTables settings object
	 *  @param {boolean} [holdPosition] Keep the current paging position. By default
	 *    the paging is reset to the first page
	 *  @memberof DataTable#oApi
	 */
	function _fnReDraw( settings, holdPosition )
	{
		var
			features = settings.oFeatures,
			sort     = features.bSort,
			filter   = features.bFilter;
	
		if ( sort ) {
			_fnSort( settings );
		}
	
		if ( filter ) {
			_fnFilterComplete( settings, settings.oPreviousSearch );
		}
		else {
			// No filtering, so we want to just use the display master
			settings.aiDisplay = settings.aiDisplayMaster.slice();
		}
	
		if ( holdPosition !== true ) {
			settings._iDisplayStart = 0;
		}
	
		// Let any modules know about the draw hold position state (used by
		// scrolling internally)
		settings._drawHold = holdPosition;
	
		_fnDraw( settings );
	
		settings._drawHold = false;
	}
	
	
	/**
	 * Add the options to the page HTML for the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnAddOptionsHtml ( oSettings )
	{
		var classes = oSettings.oClasses;
		var table = $(oSettings.nTable);
		var holding = $('<div/>').insertBefore( table ); // Holding element for speed
		var features = oSettings.oFeatures;
	
		// All DataTables are wrapped in a div
		var insert = $('<div/>', {
			id:      oSettings.sTableId+'_wrapper',
			'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' '+classes.sNoFooter)
		} );
	
		oSettings.nHolding = holding[0];
		oSettings.nTableWrapper = insert[0];
		oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
	
		/* Loop over the user set positioning and place the elements as needed */
		var aDom = oSettings.sDom.split('');
		var featureNode, cOption, nNewNode, cNext, sAttr, j;
		for ( var i=0 ; i<aDom.length ; i++ )
		{
			featureNode = null;
			cOption = aDom[i];
	
			if ( cOption == '<' )
			{
				/* New container div */
				nNewNode = $('<div/>')[0];
	
				/* Check to see if we should append an id and/or a class name to the container */
				cNext = aDom[i+1];
				if ( cNext == "'" || cNext == '"' )
				{
					sAttr = "";
					j = 2;
					while ( aDom[i+j] != cNext )
					{
						sAttr += aDom[i+j];
						j++;
					}
	
					/* Replace jQuery UI constants @todo depreciated */
					if ( sAttr == "H" )
					{
						sAttr = classes.sJUIHeader;
					}
					else if ( sAttr == "F" )
					{
						sAttr = classes.sJUIFooter;
					}
	
					/* The attribute can be in the format of "#id.class", "#id" or "class" This logic
					 * breaks the string into parts and applies them as needed
					 */
					if ( sAttr.indexOf('.') != -1 )
					{
						var aSplit = sAttr.split('.');
						nNewNode.id = aSplit[0].substr(1, aSplit[0].length-1);
						nNewNode.className = aSplit[1];
					}
					else if ( sAttr.charAt(0) == "#" )
					{
						nNewNode.id = sAttr.substr(1, sAttr.length-1);
					}
					else
					{
						nNewNode.className = sAttr;
					}
	
					i += j; /* Move along the position array */
				}
	
				insert.append( nNewNode );
				insert = $(nNewNode);
			}
			else if ( cOption == '>' )
			{
				/* End container div */
				insert = insert.parent();
			}
			// @todo Move options into their own plugins?
			else if ( cOption == 'l' && features.bPaginate && features.bLengthChange )
			{
				/* Length */
				featureNode = _fnFeatureHtmlLength( oSettings );
			}
			else if ( cOption == 'f' && features.bFilter )
			{
				/* Filter */
				featureNode = _fnFeatureHtmlFilter( oSettings );
			}
			else if ( cOption == 'r' && features.bProcessing )
			{
				/* pRocessing */
				featureNode = _fnFeatureHtmlProcessing( oSettings );
			}
			else if ( cOption == 't' )
			{
				/* Table */
				featureNode = _fnFeatureHtmlTable( oSettings );
			}
			else if ( cOption ==  'i' && features.bInfo )
			{
				/* Info */
				featureNode = _fnFeatureHtmlInfo( oSettings );
			}
			else if ( cOption == 'p' && features.bPaginate )
			{
				/* Pagination */
				featureNode = _fnFeatureHtmlPaginate( oSettings );
			}
			else if ( DataTable.ext.feature.length !== 0 )
			{
				/* Plug-in features */
				var aoFeatures = DataTable.ext.feature;
				for ( var k=0, kLen=aoFeatures.length ; k<kLen ; k++ )
				{
					if ( cOption == aoFeatures[k].cFeature )
					{
						featureNode = aoFeatures[k].fnInit( oSettings );
						break;
					}
				}
			}
	
			/* Add to the 2D features array */
			if ( featureNode )
			{
				var aanFeatures = oSettings.aanFeatures;
	
				if ( ! aanFeatures[cOption] )
				{
					aanFeatures[cOption] = [];
				}
	
				aanFeatures[cOption].push( featureNode );
				insert.append( featureNode );
			}
		}
	
		/* Built our DOM structure - replace the holding div with what we want */
		holding.replaceWith( insert );
		oSettings.nHolding = null;
	}
	
	
	/**
	 * Use the DOM source to create up an array of header cells. The idea here is to
	 * create a layout grid (array) of rows x columns, which contains a reference
	 * to the cell that that point in the grid (regardless of col/rowspan), such that
	 * any column / row could be removed and the new grid constructed
	 *  @param array {object} aLayout Array to store the calculated layout in
	 *  @param {node} nThead The header/footer element for the table
	 *  @memberof DataTable#oApi
	 */
	function _fnDetectHeader ( aLayout, nThead )
	{
		var nTrs = $(nThead).children('tr');
		var nTr, nCell;
		var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
		var bUnique;
		var fnShiftCol = function ( a, i, j ) {
			var k = a[i];
	                while ( k[j] ) {
				j++;
			}
			return j;
		};
	
		aLayout.splice( 0, aLayout.length );
	
		/* We know how many rows there are in the layout - so prep it */
		for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
		{
			aLayout.push( [] );
		}
	
		/* Calculate a layout array */
		for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
		{
			nTr = nTrs[i];
			iColumn = 0;
	
			/* For every cell in the row... */
			nCell = nTr.firstChild;
			while ( nCell ) {
				if ( nCell.nodeName.toUpperCase() == "TD" ||
				     nCell.nodeName.toUpperCase() == "TH" )
				{
					/* Get the col and rowspan attributes from the DOM and sanitise them */
					iColspan = nCell.getAttribute('colspan') * 1;
					iRowspan = nCell.getAttribute('rowspan') * 1;
					iColspan = (!iColspan || iColspan===0 || iColspan===1) ? 1 : iColspan;
					iRowspan = (!iRowspan || iRowspan===0 || iRowspan===1) ? 1 : iRowspan;
	
					/* There might be colspan cells already in this row, so shift our target
					 * accordingly
					 */
					iColShifted = fnShiftCol( aLayout, i, iColumn );
	
					/* Cache calculation for unique columns */
					bUnique = iColspan === 1 ? true : false;
	
					/* If there is col / rowspan, copy the information into the layout grid */
					for ( l=0 ; l<iColspan ; l++ )
					{
						for ( k=0 ; k<iRowspan ; k++ )
						{
							aLayout[i+k][iColShifted+l] = {
								"cell": nCell,
								"unique": bUnique
							};
							aLayout[i+k].nTr = nTr;
						}
					}
				}
				nCell = nCell.nextSibling;
			}
		}
	}
	
	
	/**
	 * Get an array of unique th elements, one for each column
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} nHeader automatically detect the layout from this node - optional
	 *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
	 *  @returns array {node} aReturn list of unique th's
	 *  @memberof DataTable#oApi
	 */
	function _fnGetUniqueThs ( oSettings, nHeader, aLayout )
	{
		var aReturn = [];
		if ( !aLayout )
		{
			aLayout = oSettings.aoHeader;
			if ( nHeader )
			{
				aLayout = [];
				_fnDetectHeader( aLayout, nHeader );
			}
		}
	
		for ( var i=0, iLen=aLayout.length ; i<iLen ; i++ )
		{
			for ( var j=0, jLen=aLayout[i].length ; j<jLen ; j++ )
			{
				if ( aLayout[i][j].unique &&
					 (!aReturn[j] || !oSettings.bSortCellsTop) )
				{
					aReturn[j] = aLayout[i][j].cell;
				}
			}
		}
	
		return aReturn;
	}
	
	/**
	 * Set the start position for draw
	 *  @param {object} oSettings dataTables settings object
	 */
	function _fnStart( oSettings )
	{
		var bServerSide = _fnDataSource( oSettings ) == 'ssp';
		var iInitDisplayStart = oSettings.iInitDisplayStart;
	
		// Check and see if we have an initial draw position from state saving
		if ( iInitDisplayStart !== undefined && iInitDisplayStart !== -1 )
		{
			oSettings._iDisplayStart = bServerSide ?
				iInitDisplayStart :
				iInitDisplayStart >= oSettings.fnRecordsDisplay() ?
					0 :
					iInitDisplayStart;
	
			oSettings.iInitDisplayStart = -1;
		}
	}
	
	/**
	 * Create an Ajax call based on the table's settings, taking into account that
	 * parameters can have multiple forms, and backwards compatibility.
	 *
	 * @param {object} oSettings dataTables settings object
	 * @param {array} data Data to send to the server, required by
	 *     DataTables - may be augmented by developer callbacks
	 * @param {function} fn Callback function to run when data is obtained
	 */
	function _fnBuildAjax( oSettings, data, fn )
	{
		// Compatibility with 1.9-, allow fnServerData and event to manipulate
		_fnCallbackFire( oSettings, 'aoServerParams', 'serverParams', [data] );
	
		// Convert to object based for 1.10+ if using the old array scheme which can
		// come from server-side processing or serverParams
		if ( data && Array.isArray(data) ) {
			var tmp = {};
			var rbracket = /(.*?)\[\]$/;
	
			$.each( data, function (key, val) {
				var match = val.name.match(rbracket);
	
				if ( match ) {
					// Support for arrays
					var name = match[0];
	
					if ( ! tmp[ name ] ) {
						tmp[ name ] = [];
					}
					tmp[ name ].push( val.value );
				}
				else {
					tmp[val.name] = val.value;
				}
			} );
			data = tmp;
		}
	
		var ajaxData;
		var ajax = oSettings.ajax;
		var instance = oSettings.oInstance;
		var callback = function ( json ) {
			var status = oSettings.jqXHR
				? oSettings.jqXHR.status
				: null;
	
			if ( json === null || (typeof status === 'number' && status == 204 ) ) {
				json = {};
				_fnAjaxDataSrc( oSettings, json, [] );
			}
	
			var error = json.error || json.sError;
			if ( error ) {
				_fnLog( oSettings, 0, error );
			}
	
			oSettings.json = json;
	
			_fnCallbackFire( oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR] );
			fn( json );
		};
	
		if ( $.isPlainObject( ajax ) && ajax.data )
		{
			ajaxData = ajax.data;
	
			var newData = typeof ajaxData === 'function' ?
				ajaxData( data, oSettings ) :  // fn can manipulate data or return
				ajaxData;                      // an object object or array to merge
	
			// If the function returned something, use that alone
			data = typeof ajaxData === 'function' && newData ?
				newData :
				$.extend( true, data, newData );
	
			// Remove the data property as we've resolved it already and don't want
			// jQuery to do it again (it is restored at the end of the function)
			delete ajax.data;
		}
	
		var baseAjax = {
			"data": data,
			"success": callback,
			"dataType": "json",
			"cache": false,
			"type": oSettings.sServerMethod,
			"error": function (xhr, error, thrown) {
				var ret = _fnCallbackFire( oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR] );
	
				if ( $.inArray( true, ret ) === -1 ) {
					if ( error == "parsererror" ) {
						_fnLog( oSettings, 0, 'Invalid JSON response', 1 );
					}
					else if ( xhr.readyState === 4 ) {
						_fnLog( oSettings, 0, 'Ajax error', 7 );
					}
				}
	
				_fnProcessingDisplay( oSettings, false );
			}
		};
	
		// Store the data submitted for the API
		oSettings.oAjaxData = data;
	
		// Allow plug-ins and external processes to modify the data
		_fnCallbackFire( oSettings, null, 'preXhr', [oSettings, data] );
	
		if ( oSettings.fnServerData )
		{
			// DataTables 1.9- compatibility
			oSettings.fnServerData.call( instance,
				oSettings.sAjaxSource,
				$.map( data, function (val, key) { // Need to convert back to 1.9 trad format
					return { name: key, value: val };
				} ),
				callback,
				oSettings
			);
		}
		else if ( oSettings.sAjaxSource || typeof ajax === 'string' )
		{
			// DataTables 1.9- compatibility
			oSettings.jqXHR = $.ajax( $.extend( baseAjax, {
				url: ajax || oSettings.sAjaxSource
			} ) );
		}
		else if ( typeof ajax === 'function' )
		{
			// Is a function - let the caller define what needs to be done
			oSettings.jqXHR = ajax.call( instance, data, callback, oSettings );
		}
		else
		{
			// Object to extend the base settings
			oSettings.jqXHR = $.ajax( $.extend( baseAjax, ajax ) );
	
			// Restore for next time around
			ajax.data = ajaxData;
		}
	}
	
	
	/**
	 * Update the table using an Ajax call
	 *  @param {object} settings dataTables settings object
	 *  @returns {boolean} Block the table drawing or not
	 *  @memberof DataTable#oApi
	 */
	function _fnAjaxUpdate( settings )
	{
		settings.iDraw++;
		_fnProcessingDisplay( settings, true );
	
		_fnBuildAjax(
			settings,
			_fnAjaxParameters( settings ),
			function(json) {
				_fnAjaxUpdateDraw( settings, json );
			}
		);
	}
	
	
	/**
	 * Build up the parameters in an object needed for a server-side processing
	 * request. Note that this is basically done twice, is different ways - a modern
	 * method which is used by default in DataTables 1.10 which uses objects and
	 * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
	 * the sAjaxSource option is used in the initialisation, or the legacyAjax
	 * option is set.
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {bool} block the table drawing or not
	 *  @memberof DataTable#oApi
	 */
	function _fnAjaxParameters( settings )
	{
		var
			columns = settings.aoColumns,
			columnCount = columns.length,
			features = settings.oFeatures,
			preSearch = settings.oPreviousSearch,
			preColSearch = settings.aoPreSearchCols,
			i, data = [], dataProp, column, columnSearch,
			sort = _fnSortFlatten( settings ),
			displayStart = settings._iDisplayStart,
			displayLength = features.bPaginate !== false ?
				settings._iDisplayLength :
				-1;
	
		var param = function ( name, value ) {
			data.push( { 'name': name, 'value': value } );
		};
	
		// DataTables 1.9- compatible method
		param( 'sEcho',          settings.iDraw );
		param( 'iColumns',       columnCount );
		param( 'sColumns',       _pluck( columns, 'sName' ).join(',') );
		param( 'iDisplayStart',  displayStart );
		param( 'iDisplayLength', displayLength );
	
		// DataTables 1.10+ method
		var d = {
			draw:    settings.iDraw,
			columns: [],
			order:   [],
			start:   displayStart,
			length:  displayLength,
			search:  {
				value: preSearch.sSearch,
				regex: preSearch.bRegex
			}
		};
	
		for ( i=0 ; i<columnCount ; i++ ) {
			column = columns[i];
			columnSearch = preColSearch[i];
			dataProp = typeof column.mData=="function" ? 'function' : column.mData ;
	
			d.columns.push( {
				data:       dataProp,
				name:       column.sName,
				searchable: column.bSearchable,
				orderable:  column.bSortable,
				search:     {
					value: columnSearch.sSearch,
					regex: columnSearch.bRegex
				}
			} );
	
			param( "mDataProp_"+i, dataProp );
	
			if ( features.bFilter ) {
				param( 'sSearch_'+i,     columnSearch.sSearch );
				param( 'bRegex_'+i,      columnSearch.bRegex );
				param( 'bSearchable_'+i, column.bSearchable );
			}
	
			if ( features.bSort ) {
				param( 'bSortable_'+i, column.bSortable );
			}
		}
	
		if ( features.bFilter ) {
			param( 'sSearch', preSearch.sSearch );
			param( 'bRegex', preSearch.bRegex );
		}
	
		if ( features.bSort ) {
			$.each( sort, function ( i, val ) {
				d.order.push( { column: val.col, dir: val.dir } );
	
				param( 'iSortCol_'+i, val.col );
				param( 'sSortDir_'+i, val.dir );
			} );
	
			param( 'iSortingCols', sort.length );
		}
	
		// If the legacy.ajax parameter is null, then we automatically decide which
		// form to use, based on sAjaxSource
		var legacy = DataTable.ext.legacy.ajax;
		if ( legacy === null ) {
			return settings.sAjaxSource ? data : d;
		}
	
		// Otherwise, if legacy has been specified then we use that to decide on the
		// form
		return legacy ? data : d;
	}
	
	
	/**
	 * Data the data from the server (nuking the old) and redraw the table
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} json json data return from the server.
	 *  @param {string} json.sEcho Tracking flag for DataTables to match requests
	 *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
	 *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
	 *  @param {array} json.aaData The data to display on this page
	 *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
	 *  @memberof DataTable#oApi
	 */
	function _fnAjaxUpdateDraw ( settings, json )
	{
		// v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
		// Support both
		var compat = function ( old, modern ) {
			return json[old] !== undefined ? json[old] : json[modern];
		};
	
		var data = _fnAjaxDataSrc( settings, json );
		var draw            = compat( 'sEcho',                'draw' );
		var recordsTotal    = compat( 'iTotalRecords',        'recordsTotal' );
		var recordsFiltered = compat( 'iTotalDisplayRecords', 'recordsFiltered' );
	
		if ( draw !== undefined ) {
			// Protect against out of sequence returns
			if ( draw*1 < settings.iDraw ) {
				return;
			}
			settings.iDraw = draw * 1;
		}
	
		// No data in returned object, so rather than an array, we show an empty table
		if ( ! data ) {
			data = [];
		}
	
		_fnClearTable( settings );
		settings._iRecordsTotal   = parseInt(recordsTotal, 10);
		settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
	
		for ( var i=0, ien=data.length ; i<ien ; i++ ) {
			_fnAddData( settings, data[i] );
		}
		settings.aiDisplay = settings.aiDisplayMaster.slice();
	
		_fnDraw( settings, true );
	
		if ( ! settings._bInitComplete ) {
			_fnInitComplete( settings, json );
		}
	
		_fnProcessingDisplay( settings, false );
	}
	
	
	/**
	 * Get the data from the JSON data source to use for drawing a table. Using
	 * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
	 * source object, or from a processing function.
	 *  @param {object} oSettings dataTables settings object
	 *  @param  {object} json Data source object / array from the server
	 *  @return {array} Array of data to use
	 */
	 function _fnAjaxDataSrc ( oSettings, json, write )
	 {
		var dataSrc = $.isPlainObject( oSettings.ajax ) && oSettings.ajax.dataSrc !== undefined ?
			oSettings.ajax.dataSrc :
			oSettings.sAjaxDataProp; // Compatibility with 1.9-.
	
		if ( ! write ) {
			if ( dataSrc === 'data' ) {
				// If the default, then we still want to support the old style, and safely ignore
				// it if possible
				return json.aaData || json[dataSrc];
			}
	
			return dataSrc !== "" ?
				_fnGetObjectDataFn( dataSrc )( json ) :
				json;
		}
	
		// set
		_fnSetObjectDataFn( dataSrc )( json, write );
	}
	
	/**
	 * Generate the node required for filtering text
	 *  @returns {node} Filter control element
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlFilter ( settings )
	{
		var classes = settings.oClasses;
		var tableId = settings.sTableId;
		var language = settings.oLanguage;
		var previousSearch = settings.oPreviousSearch;
		var features = settings.aanFeatures;
		var input = '<input type="search" class="'+classes.sFilterInput+'"/>';
	
		var str = language.sSearch;
		str = str.match(/_INPUT_/) ?
			str.replace('_INPUT_', input) :
			str+input;
	
		var filter = $('<div/>', {
				'id': ! features.f ? tableId+'_filter' : null,
				'class': classes.sFilter
			} )
			.append( $('<label/>' ).append( str ) );
	
		var searchFn = function(event) {
			/* Update all other filter input elements for the new display */
			var n = features.f;
			var val = !this.value ? "" : this.value; // mental IE8 fix :-(
			if(previousSearch.return && event.key !== "Enter") {
				return;
			}
			/* Now do the filter */
			if ( val != previousSearch.sSearch ) {
				_fnFilterComplete( settings, {
					"sSearch": val,
					"bRegex": previousSearch.bRegex,
					"bSmart": previousSearch.bSmart ,
					"bCaseInsensitive": previousSearch.bCaseInsensitive,
					"return": previousSearch.return
				} );
	
				// Need to redraw, without resorting
				settings._iDisplayStart = 0;
				_fnDraw( settings );
			}
		};
	
		var searchDelay = settings.searchDelay !== null ?
			settings.searchDelay :
			_fnDataSource( settings ) === 'ssp' ?
				400 :
				0;
	
		var jqFilter = $('input', filter)
			.val( previousSearch.sSearch )
			.attr( 'placeholder', language.sSearchPlaceholder )
			.on(
				'keyup.DT search.DT input.DT paste.DT cut.DT',
				searchDelay ?
					_fnThrottle( searchFn, searchDelay ) :
					searchFn
			)
			.on( 'mouseup', function(e) {
				// Edge fix! Edge 17 does not trigger anything other than mouse events when clicking
				// on the clear icon (Edge bug 17584515). This is safe in other browsers as `searchFn`
				// checks the value to see if it has changed. In other browsers it won't have.
				setTimeout( function () {
					searchFn.call(jqFilter[0], e);
				}, 10);
			} )
			.on( 'keypress.DT', function(e) {
				/* Prevent form submission */
				if ( e.keyCode == 13 ) {
					return false;
				}
			} )
			.attr('aria-controls', tableId);
	
		// Update the input elements whenever the table is filtered
		$(settings.nTable).on( 'search.dt.DT', function ( ev, s ) {
			if ( settings === s ) {
				// IE9 throws an 'unknown error' if document.activeElement is used
				// inside an iframe or frame...
				try {
					if ( jqFilter[0] !== document.activeElement ) {
						jqFilter.val( previousSearch.sSearch );
					}
				}
				catch ( e ) {}
			}
		} );
	
		return filter[0];
	}
	
	
	/**
	 * Filter the table using both the global filter and column based filtering
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} oSearch search information
	 *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterComplete ( oSettings, oInput, iForce )
	{
		var oPrevSearch = oSettings.oPreviousSearch;
		var aoPrevSearch = oSettings.aoPreSearchCols;
		var fnSaveFilter = function ( oFilter ) {
			/* Save the filtering values */
			oPrevSearch.sSearch = oFilter.sSearch;
			oPrevSearch.bRegex = oFilter.bRegex;
			oPrevSearch.bSmart = oFilter.bSmart;
			oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
			oPrevSearch.return = oFilter.return;
		};
		var fnRegex = function ( o ) {
			// Backwards compatibility with the bEscapeRegex option
			return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
		};
	
		// Resolve any column types that are unknown due to addition or invalidation
		// @todo As per sort - can this be moved into an event handler?
		_fnColumnTypes( oSettings );
	
		/* In server-side processing all filtering is done by the server, so no point hanging around here */
		if ( _fnDataSource( oSettings ) != 'ssp' )
		{
			/* Global filter */
			_fnFilter( oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive, oInput.return );
			fnSaveFilter( oInput );
	
			/* Now do the individual column filter */
			for ( var i=0 ; i<aoPrevSearch.length ; i++ )
			{
				_fnFilterColumn( oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),
					aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive );
			}
	
			/* Custom filtering */
			_fnFilterCustom( oSettings );
		}
		else
		{
			fnSaveFilter( oInput );
		}
	
		/* Tell the draw function we have been filtering */
		oSettings.bFiltered = true;
		_fnCallbackFire( oSettings, null, 'search', [oSettings] );
	}
	
	
	/**
	 * Apply custom filtering functions
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterCustom( settings )
	{
		var filters = DataTable.ext.search;
		var displayRows = settings.aiDisplay;
		var row, rowIdx;
	
		for ( var i=0, ien=filters.length ; i<ien ; i++ ) {
			var rows = [];
	
			// Loop over each row and see if it should be included
			for ( var j=0, jen=displayRows.length ; j<jen ; j++ ) {
				rowIdx = displayRows[ j ];
				row = settings.aoData[ rowIdx ];
	
				if ( filters[i]( settings, row._aFilterData, rowIdx, row._aData, j ) ) {
					rows.push( rowIdx );
				}
			}
	
			// So the array reference doesn't break set the results into the
			// existing array
			displayRows.length = 0;
			$.merge( displayRows, rows );
		}
	}
	
	
	/**
	 * Filter the table on a per-column basis
	 *  @param {object} oSettings dataTables settings object
	 *  @param {string} sInput string to filter on
	 *  @param {int} iColumn column to filter
	 *  @param {bool} bRegex treat search string as a regular expression or not
	 *  @param {bool} bSmart use smart filtering or not
	 *  @param {bool} bCaseInsensitive Do case insensitive matching or not
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterColumn ( settings, searchStr, colIdx, regex, smart, caseInsensitive )
	{
		if ( searchStr === '' ) {
			return;
		}
	
		var data;
		var out = [];
		var display = settings.aiDisplay;
		var rpSearch = _fnFilterCreateSearch( searchStr, regex, smart, caseInsensitive );
	
		for ( var i=0 ; i<display.length ; i++ ) {
			data = settings.aoData[ display[i] ]._aFilterData[ colIdx ];
	
			if ( rpSearch.test( data ) ) {
				out.push( display[i] );
			}
		}
	
		settings.aiDisplay = out;
	}
	
	
	/**
	 * Filter the data table based on user input and draw the table
	 *  @param {object} settings dataTables settings object
	 *  @param {string} input string to filter on
	 *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
	 *  @param {bool} regex treat as a regular expression or not
	 *  @param {bool} smart perform smart filtering or not
	 *  @param {bool} caseInsensitive Do case insensitive matching or not
	 *  @memberof DataTable#oApi
	 */
	function _fnFilter( settings, input, force, regex, smart, caseInsensitive )
	{
		var rpSearch = _fnFilterCreateSearch( input, regex, smart, caseInsensitive );
		var prevSearch = settings.oPreviousSearch.sSearch;
		var displayMaster = settings.aiDisplayMaster;
		var display, invalidated, i;
		var filtered = [];
	
		// Need to take account of custom filtering functions - always filter
		if ( DataTable.ext.search.length !== 0 ) {
			force = true;
		}
	
		// Check if any of the rows were invalidated
		invalidated = _fnFilterData( settings );
	
		// If the input is blank - we just want the full data set
		if ( input.length <= 0 ) {
			settings.aiDisplay = displayMaster.slice();
		}
		else {
			// New search - start from the master array
			if ( invalidated ||
				 force ||
				 regex ||
				 prevSearch.length > input.length ||
				 input.indexOf(prevSearch) !== 0 ||
				 settings.bSorted // On resort, the display master needs to be
				                  // re-filtered since indexes will have changed
			) {
				settings.aiDisplay = displayMaster.slice();
			}
	
			// Search the display array
			display = settings.aiDisplay;
	
			for ( i=0 ; i<display.length ; i++ ) {
				if ( rpSearch.test( settings.aoData[ display[i] ]._sFilterRow ) ) {
					filtered.push( display[i] );
				}
			}
	
			settings.aiDisplay = filtered;
		}
	}
	
	
	/**
	 * Build a regular expression object suitable for searching a table
	 *  @param {string} sSearch string to search for
	 *  @param {bool} bRegex treat as a regular expression or not
	 *  @param {bool} bSmart perform smart filtering or not
	 *  @param {bool} bCaseInsensitive Do case insensitive matching or not
	 *  @returns {RegExp} constructed object
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterCreateSearch( search, regex, smart, caseInsensitive )
	{
		search = regex ?
			search :
			_fnEscapeRegex( search );
		
		if ( smart ) {
			/* For smart filtering we want to allow the search to work regardless of
			 * word order. We also want double quoted text to be preserved, so word
			 * order is important - a la google. So this is what we want to
			 * generate:
			 * 
			 * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
			 */
			var a = $.map( search.match( /"[^"]+"|[^ ]+/g ) || [''], function ( word ) {
				if ( word.charAt(0) === '"' ) {
					var m = word.match( /^"(.*)"$/ );
					word = m ? m[1] : word;
				}
	
				return word.replace('"', '');
			} );
	
			search = '^(?=.*?'+a.join( ')(?=.*?' )+').*$';
		}
	
		return new RegExp( search, caseInsensitive ? 'i' : '' );
	}
	
	
	/**
	 * Escape a string such that it can be used in a regular expression
	 *  @param {string} sVal string to escape
	 *  @returns {string} escaped string
	 *  @memberof DataTable#oApi
	 */
	var _fnEscapeRegex = DataTable.util.escapeRegex;
	
	var __filter_div = $('<div>')[0];
	var __filter_div_textContent = __filter_div.textContent !== undefined;
	
	// Update the filtering data for each row if needed (by invalidation or first run)
	function _fnFilterData ( settings )
	{
		var columns = settings.aoColumns;
		var column;
		var i, j, ien, jen, filterData, cellData, row;
		var wasInvalidated = false;
	
		for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
			row = settings.aoData[i];
	
			if ( ! row._aFilterData ) {
				filterData = [];
	
				for ( j=0, jen=columns.length ; j<jen ; j++ ) {
					column = columns[j];
	
					if ( column.bSearchable ) {
						cellData = _fnGetCellData( settings, i, j, 'filter' );
	
						// Search in DataTables 1.10 is string based. In 1.11 this
						// should be altered to also allow strict type checking.
						if ( cellData === null ) {
							cellData = '';
						}
	
						if ( typeof cellData !== 'string' && cellData.toString ) {
							cellData = cellData.toString();
						}
					}
					else {
						cellData = '';
					}
	
					// If it looks like there is an HTML entity in the string,
					// attempt to decode it so sorting works as expected. Note that
					// we could use a single line of jQuery to do this, but the DOM
					// method used here is much faster http://jsperf.com/html-decode
					if ( cellData.indexOf && cellData.indexOf('&') !== -1 ) {
						__filter_div.innerHTML = cellData;
						cellData = __filter_div_textContent ?
							__filter_div.textContent :
							__filter_div.innerText;
					}
	
					if ( cellData.replace ) {
						cellData = cellData.replace(/[\r\n\u2028]/g, '');
					}
	
					filterData.push( cellData );
				}
	
				row._aFilterData = filterData;
				row._sFilterRow = filterData.join('  ');
				wasInvalidated = true;
			}
		}
	
		return wasInvalidated;
	}
	
	
	/**
	 * Convert from the internal Hungarian notation to camelCase for external
	 * interaction
	 *  @param {object} obj Object to convert
	 *  @returns {object} Inverted object
	 *  @memberof DataTable#oApi
	 */
	function _fnSearchToCamel ( obj )
	{
		return {
			search:          obj.sSearch,
			smart:           obj.bSmart,
			regex:           obj.bRegex,
			caseInsensitive: obj.bCaseInsensitive
		};
	}
	
	
	
	/**
	 * Convert from camelCase notation to the internal Hungarian. We could use the
	 * Hungarian convert function here, but this is cleaner
	 *  @param {object} obj Object to convert
	 *  @returns {object} Inverted object
	 *  @memberof DataTable#oApi
	 */
	function _fnSearchToHung ( obj )
	{
		return {
			sSearch:          obj.search,
			bSmart:           obj.smart,
			bRegex:           obj.regex,
			bCaseInsensitive: obj.caseInsensitive
		};
	}
	
	/**
	 * Generate the node required for the info display
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {node} Information element
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlInfo ( settings )
	{
		var
			tid = settings.sTableId,
			nodes = settings.aanFeatures.i,
			n = $('<div/>', {
				'class': settings.oClasses.sInfo,
				'id': ! nodes ? tid+'_info' : null
			} );
	
		if ( ! nodes ) {
			// Update display on each draw
			settings.aoDrawCallback.push( {
				"fn": _fnUpdateInfo,
				"sName": "information"
			} );
	
			n
				.attr( 'role', 'status' )
				.attr( 'aria-live', 'polite' );
	
			// Table is described by our info div
			$(settings.nTable).attr( 'aria-describedby', tid+'_info' );
		}
	
		return n[0];
	}
	
	
	/**
	 * Update the information elements in the display
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnUpdateInfo ( settings )
	{
		/* Show information about the table */
		var nodes = settings.aanFeatures.i;
		if ( nodes.length === 0 ) {
			return;
		}
	
		var
			lang  = settings.oLanguage,
			start = settings._iDisplayStart+1,
			end   = settings.fnDisplayEnd(),
			max   = settings.fnRecordsTotal(),
			total = settings.fnRecordsDisplay(),
			out   = total ?
				lang.sInfo :
				lang.sInfoEmpty;
	
		if ( total !== max ) {
			/* Record set after filtering */
			out += ' ' + lang.sInfoFiltered;
		}
	
		// Convert the macros
		out += lang.sInfoPostFix;
		out = _fnInfoMacros( settings, out );
	
		var callback = lang.fnInfoCallback;
		if ( callback !== null ) {
			out = callback.call( settings.oInstance,
				settings, start, end, max, total, out
			);
		}
	
		$(nodes).html( out );
	}
	
	
	function _fnInfoMacros ( settings, str )
	{
		// When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
		// internally
		var
			formatter  = settings.fnFormatNumber,
			start      = settings._iDisplayStart+1,
			len        = settings._iDisplayLength,
			vis        = settings.fnRecordsDisplay(),
			all        = len === -1;
	
		return str.
			replace(/_START_/g, formatter.call( settings, start ) ).
			replace(/_END_/g,   formatter.call( settings, settings.fnDisplayEnd() ) ).
			replace(/_MAX_/g,   formatter.call( settings, settings.fnRecordsTotal() ) ).
			replace(/_TOTAL_/g, formatter.call( settings, vis ) ).
			replace(/_PAGE_/g,  formatter.call( settings, all ? 1 : Math.ceil( start / len ) ) ).
			replace(/_PAGES_/g, formatter.call( settings, all ? 1 : Math.ceil( vis / len ) ) );
	}
	
	
	
	/**
	 * Draw the table for the first time, adding all required features
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnInitialise ( settings )
	{
		var i, iLen, iAjaxStart=settings.iInitDisplayStart;
		var columns = settings.aoColumns, column;
		var features = settings.oFeatures;
		var deferLoading = settings.bDeferLoading; // value modified by the draw
	
		/* Ensure that the table data is fully initialised */
		if ( ! settings.bInitialised ) {
			setTimeout( function(){ _fnInitialise( settings ); }, 200 );
			return;
		}
	
		/* Show the display HTML options */
		_fnAddOptionsHtml( settings );
	
		/* Build and draw the header / footer for the table */
		_fnBuildHead( settings );
		_fnDrawHead( settings, settings.aoHeader );
		_fnDrawHead( settings, settings.aoFooter );
	
		/* Okay to show that something is going on now */
		_fnProcessingDisplay( settings, true );
	
		/* Calculate sizes for columns */
		if ( features.bAutoWidth ) {
			_fnCalculateColumnWidths( settings );
		}
	
		for ( i=0, iLen=columns.length ; i<iLen ; i++ ) {
			column = columns[i];
	
			if ( column.sWidth ) {
				column.nTh.style.width = _fnStringToCss( column.sWidth );
			}
		}
	
		_fnCallbackFire( settings, null, 'preInit', [settings] );
	
		// If there is default sorting required - let's do it. The sort function
		// will do the drawing for us. Otherwise we draw the table regardless of the
		// Ajax source - this allows the table to look initialised for Ajax sourcing
		// data (show 'loading' message possibly)
		_fnReDraw( settings );
	
		// Server-side processing init complete is done by _fnAjaxUpdateDraw
		var dataSrc = _fnDataSource( settings );
		if ( dataSrc != 'ssp' || deferLoading ) {
			// if there is an ajax source load the data
			if ( dataSrc == 'ajax' ) {
				_fnBuildAjax( settings, [], function(json) {
					var aData = _fnAjaxDataSrc( settings, json );
	
					// Got the data - add it to the table
					for ( i=0 ; i<aData.length ; i++ ) {
						_fnAddData( settings, aData[i] );
					}
	
					// Reset the init display for cookie saving. We've already done
					// a filter, and therefore cleared it before. So we need to make
					// it appear 'fresh'
					settings.iInitDisplayStart = iAjaxStart;
	
					_fnReDraw( settings );
	
					_fnProcessingDisplay( settings, false );
					_fnInitComplete( settings, json );
				}, settings );
			}
			else {
				_fnProcessingDisplay( settings, false );
				_fnInitComplete( settings );
			}
		}
	}
	
	
	/**
	 * Draw the table for the first time, adding all required features
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
	 *    with client-side processing (optional)
	 *  @memberof DataTable#oApi
	 */
	function _fnInitComplete ( settings, json )
	{
		settings._bInitComplete = true;
	
		// When data was added after the initialisation (data or Ajax) we need to
		// calculate the column sizing
		if ( json || settings.oInit.aaData ) {
			_fnAdjustColumnSizing( settings );
		}
	
		_fnCallbackFire( settings, null, 'plugin-init', [settings, json] );
		_fnCallbackFire( settings, 'aoInitComplete', 'init', [settings, json] );
	}
	
	
	function _fnLengthChange ( settings, val )
	{
		var len = parseInt( val, 10 );
		settings._iDisplayLength = len;
	
		_fnLengthOverflow( settings );
	
		// Fire length change event
		_fnCallbackFire( settings, null, 'length', [settings, len] );
	}
	
	
	/**
	 * Generate the node required for user display length changing
	 *  @param {object} settings dataTables settings object
	 *  @returns {node} Display length feature node
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlLength ( settings )
	{
		var
			classes  = settings.oClasses,
			tableId  = settings.sTableId,
			menu     = settings.aLengthMenu,
			d2       = Array.isArray( menu[0] ),
			lengths  = d2 ? menu[0] : menu,
			language = d2 ? menu[1] : menu;
	
		var select = $('<select/>', {
			'name':          tableId+'_length',
			'aria-controls': tableId,
			'class':         classes.sLengthSelect
		} );
	
		for ( var i=0, ien=lengths.length ; i<ien ; i++ ) {
			select[0][ i ] = new Option(
				typeof language[i] === 'number' ?
					settings.fnFormatNumber( language[i] ) :
					language[i],
				lengths[i]
			);
		}
	
		var div = $('<div><label/></div>').addClass( classes.sLength );
		if ( ! settings.aanFeatures.l ) {
			div[0].id = tableId+'_length';
		}
	
		div.children().append(
			settings.oLanguage.sLengthMenu.replace( '_MENU_', select[0].outerHTML )
		);
	
		// Can't use `select` variable as user might provide their own and the
		// reference is broken by the use of outerHTML
		$('select', div)
			.val( settings._iDisplayLength )
			.on( 'change.DT', function(e) {
				_fnLengthChange( settings, $(this).val() );
				_fnDraw( settings );
			} );
	
		// Update node value whenever anything changes the table's length
		$(settings.nTable).on( 'length.dt.DT', function (e, s, len) {
			if ( settings === s ) {
				$('select', div).val( len );
			}
		} );
	
		return div[0];
	}
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Note that most of the paging logic is done in
	 * DataTable.ext.pager
	 */
	
	/**
	 * Generate the node required for default pagination
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {node} Pagination feature node
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlPaginate ( settings )
	{
		var
			type   = settings.sPaginationType,
			plugin = DataTable.ext.pager[ type ],
			modern = typeof plugin === 'function',
			redraw = function( settings ) {
				_fnDraw( settings );
			},
			node = $('<div/>').addClass( settings.oClasses.sPaging + type )[0],
			features = settings.aanFeatures;
	
		if ( ! modern ) {
			plugin.fnInit( settings, node, redraw );
		}
	
		/* Add a draw callback for the pagination on first instance, to update the paging display */
		if ( ! features.p )
		{
			node.id = settings.sTableId+'_paginate';
	
			settings.aoDrawCallback.push( {
				"fn": function( settings ) {
					if ( modern ) {
						var
							start      = settings._iDisplayStart,
							len        = settings._iDisplayLength,
							visRecords = settings.fnRecordsDisplay(),
							all        = len === -1,
							page = all ? 0 : Math.ceil( start / len ),
							pages = all ? 1 : Math.ceil( visRecords / len ),
							buttons = plugin(page, pages),
							i, ien;
	
						for ( i=0, ien=features.p.length ; i<ien ; i++ ) {
							_fnRenderer( settings, 'pageButton' )(
								settings, features.p[i], i, buttons, page, pages
							);
						}
					}
					else {
						plugin.fnUpdate( settings, redraw );
					}
				},
				"sName": "pagination"
			} );
		}
	
		return node;
	}
	
	
	/**
	 * Alter the display settings to change the page
	 *  @param {object} settings DataTables settings object
	 *  @param {string|int} action Paging action to take: "first", "previous",
	 *    "next" or "last" or page number to jump to (integer)
	 *  @param [bool] redraw Automatically draw the update or not
	 *  @returns {bool} true page has changed, false - no change
	 *  @memberof DataTable#oApi
	 */
	function _fnPageChange ( settings, action, redraw )
	{
		var
			start     = settings._iDisplayStart,
			len       = settings._iDisplayLength,
			records   = settings.fnRecordsDisplay();
	
		if ( records === 0 || len === -1 )
		{
			start = 0;
		}
		else if ( typeof action === "number" )
		{
			start = action * len;
	
			if ( start > records )
			{
				start = 0;
			}
		}
		else if ( action == "first" )
		{
			start = 0;
		}
		else if ( action == "previous" )
		{
			start = len >= 0 ?
				start - len :
				0;
	
			if ( start < 0 )
			{
			  start = 0;
			}
		}
		else if ( action == "next" )
		{
			if ( start + len < records )
			{
				start += len;
			}
		}
		else if ( action == "last" )
		{
			start = Math.floor( (records-1) / len) * len;
		}
		else
		{
			_fnLog( settings, 0, "Unknown paging action: "+action, 5 );
		}
	
		var changed = settings._iDisplayStart !== start;
		settings._iDisplayStart = start;
	
		if ( changed ) {
			_fnCallbackFire( settings, null, 'page', [settings] );
	
			if ( redraw ) {
				_fnDraw( settings );
			}
		}
		else {
			// No change event - paging was called, but no change
			_fnCallbackFire( settings, null, 'page-nc', [settings] );
		}
	
		return changed;
	}
	
	
	
	/**
	 * Generate the node required for the processing node
	 *  @param {object} settings dataTables settings object
	 *  @returns {node} Processing element
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlProcessing ( settings )
	{
		return $('<div/>', {
				'id': ! settings.aanFeatures.r ? settings.sTableId+'_processing' : null,
				'class': settings.oClasses.sProcessing,
				'role': 'status'
			} )
			.html( settings.oLanguage.sProcessing )
			.append('<div><div></div><div></div><div></div><div></div></div>')
			.insertBefore( settings.nTable )[0];
	}
	
	
	/**
	 * Display or hide the processing indicator
	 *  @param {object} settings dataTables settings object
	 *  @param {bool} show Show the processing indicator (true) or not (false)
	 *  @memberof DataTable#oApi
	 */
	function _fnProcessingDisplay ( settings, show )
	{
		if ( settings.oFeatures.bProcessing ) {
			$(settings.aanFeatures.r).css( 'display', show ? 'block' : 'none' );
		}
	
		_fnCallbackFire( settings, null, 'processing', [settings, show] );
	}
	
	/**
	 * Add any control elements for the table - specifically scrolling
	 *  @param {object} settings dataTables settings object
	 *  @returns {node} Node to add to the DOM
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlTable ( settings )
	{
		var table = $(settings.nTable);
	
		// Scrolling from here on in
		var scroll = settings.oScroll;
	
		if ( scroll.sX === '' && scroll.sY === '' ) {
			return settings.nTable;
		}
	
		var scrollX = scroll.sX;
		var scrollY = scroll.sY;
		var classes = settings.oClasses;
		var caption = table.children('caption');
		var captionSide = caption.length ? caption[0]._captionSide : null;
		var headerClone = $( table[0].cloneNode(false) );
		var footerClone = $( table[0].cloneNode(false) );
		var footer = table.children('tfoot');
		var _div = '<div/>';
		var size = function ( s ) {
			return !s ? null : _fnStringToCss( s );
		};
	
		if ( ! footer.length ) {
			footer = null;
		}
	
		/*
		 * The HTML structure that we want to generate in this function is:
		 *  div - scroller
		 *    div - scroll head
		 *      div - scroll head inner
		 *        table - scroll head table
		 *          thead - thead
		 *    div - scroll body
		 *      table - table (master table)
		 *        thead - thead clone for sizing
		 *        tbody - tbody
		 *    div - scroll foot
		 *      div - scroll foot inner
		 *        table - scroll foot table
		 *          tfoot - tfoot
		 */
		var scroller = $( _div, { 'class': classes.sScrollWrapper } )
			.append(
				$(_div, { 'class': classes.sScrollHead } )
					.css( {
						overflow: 'hidden',
						position: 'relative',
						border: 0,
						width: scrollX ? size(scrollX) : '100%'
					} )
					.append(
						$(_div, { 'class': classes.sScrollHeadInner } )
							.css( {
								'box-sizing': 'content-box',
								width: scroll.sXInner || '100%'
							} )
							.append(
								headerClone
									.removeAttr('id')
									.css( 'margin-left', 0 )
									.append( captionSide === 'top' ? caption : null )
									.append(
										table.children('thead')
									)
							)
					)
			)
			.append(
				$(_div, { 'class': classes.sScrollBody } )
					.css( {
						position: 'relative',
						overflow: 'auto',
						width: size( scrollX )
					} )
					.append( table )
			);
	
		if ( footer ) {
			scroller.append(
				$(_div, { 'class': classes.sScrollFoot } )
					.css( {
						overflow: 'hidden',
						border: 0,
						width: scrollX ? size(scrollX) : '100%'
					} )
					.append(
						$(_div, { 'class': classes.sScrollFootInner } )
							.append(
								footerClone
									.removeAttr('id')
									.css( 'margin-left', 0 )
									.append( captionSide === 'bottom' ? caption : null )
									.append(
										table.children('tfoot')
									)
							)
					)
			);
		}
	
		var children = scroller.children();
		var scrollHead = children[0];
		var scrollBody = children[1];
		var scrollFoot = footer ? children[2] : null;
	
		// When the body is scrolled, then we also want to scroll the headers
		if ( scrollX ) {
			$(scrollBody).on( 'scroll.DT', function (e) {
				var scrollLeft = this.scrollLeft;
	
				scrollHead.scrollLeft = scrollLeft;
	
				if ( footer ) {
					scrollFoot.scrollLeft = scrollLeft;
				}
			} );
		}
	
		$(scrollBody).css('max-height', scrollY);
		if (! scroll.bCollapse) {
			$(scrollBody).css('height', scrollY);
		}
	
		settings.nScrollHead = scrollHead;
		settings.nScrollBody = scrollBody;
		settings.nScrollFoot = scrollFoot;
	
		// On redraw - align columns
		settings.aoDrawCallback.push( {
			"fn": _fnScrollDraw,
			"sName": "scrolling"
		} );
	
		return scroller[0];
	}
	
	
	
	/**
	 * Update the header, footer and body tables for resizing - i.e. column
	 * alignment.
	 *
	 * Welcome to the most horrible function DataTables. The process that this
	 * function follows is basically:
	 *   1. Re-create the table inside the scrolling div
	 *   2. Take live measurements from the DOM
	 *   3. Apply the measurements to align the columns
	 *   4. Clean up
	 *
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnScrollDraw ( settings )
	{
		// Given that this is such a monster function, a lot of variables are use
		// to try and keep the minimised size as small as possible
		var
			scroll         = settings.oScroll,
			scrollX        = scroll.sX,
			scrollXInner   = scroll.sXInner,
			scrollY        = scroll.sY,
			barWidth       = scroll.iBarWidth,
			divHeader      = $(settings.nScrollHead),
			divHeaderStyle = divHeader[0].style,
			divHeaderInner = divHeader.children('div'),
			divHeaderInnerStyle = divHeaderInner[0].style,
			divHeaderTable = divHeaderInner.children('table'),
			divBodyEl      = settings.nScrollBody,
			divBody        = $(divBodyEl),
			divBodyStyle   = divBodyEl.style,
			divFooter      = $(settings.nScrollFoot),
			divFooterInner = divFooter.children('div'),
			divFooterTable = divFooterInner.children('table'),
			header         = $(settings.nTHead),
			table          = $(settings.nTable),
			tableEl        = table[0],
			tableStyle     = tableEl.style,
			footer         = settings.nTFoot ? $(settings.nTFoot) : null,
			browser        = settings.oBrowser,
			ie67           = browser.bScrollOversize,
			dtHeaderCells  = _pluck( settings.aoColumns, 'nTh' ),
			headerTrgEls, footerTrgEls,
			headerSrcEls, footerSrcEls,
			headerCopy, footerCopy,
			headerWidths=[], footerWidths=[],
			headerContent=[], footerContent=[],
			idx, correction, sanityWidth,
			zeroOut = function(nSizer) {
				var style = nSizer.style;
				style.paddingTop = "0";
				style.paddingBottom = "0";
				style.borderTopWidth = "0";
				style.borderBottomWidth = "0";
				style.height = 0;
			};
	
		// If the scrollbar visibility has changed from the last draw, we need to
		// adjust the column sizes as the table width will have changed to account
		// for the scrollbar
		var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
		
		if ( settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined ) {
			settings.scrollBarVis = scrollBarVis;
			_fnAdjustColumnSizing( settings );
			return; // adjust column sizing will call this function again
		}
		else {
			settings.scrollBarVis = scrollBarVis;
		}
	
		/*
		 * 1. Re-create the table inside the scrolling div
		 */
	
		// Remove the old minimised thead and tfoot elements in the inner table
		table.children('thead, tfoot').remove();
	
		if ( footer ) {
			footerCopy = footer.clone().prependTo( table );
			footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized
			footerSrcEls = footerCopy.find('tr');
			footerCopy.find('[id]').removeAttr('id');
		}
	
		// Clone the current header and footer elements and then place it into the inner table
		headerCopy = header.clone().prependTo( table );
		headerTrgEls = header.find('tr'); // original header is in its own table
		headerSrcEls = headerCopy.find('tr');
		headerCopy.find('th, td').removeAttr('tabindex');
		headerCopy.find('[id]').removeAttr('id');
	
	
		/*
		 * 2. Take live measurements from the DOM - do not alter the DOM itself!
		 */
	
		// Remove old sizing and apply the calculated column widths
		// Get the unique column headers in the newly created (cloned) header. We want to apply the
		// calculated sizes to this header
		if ( ! scrollX )
		{
			divBodyStyle.width = '100%';
			divHeader[0].style.width = '100%';
		}
	
		$.each( _fnGetUniqueThs( settings, headerCopy ), function ( i, el ) {
			idx = _fnVisibleToColumnIndex( settings, i );
			el.style.width = settings.aoColumns[idx].sWidth;
		} );
	
		if ( footer ) {
			_fnApplyToChildren( function(n) {
				n.style.width = "";
			}, footerSrcEls );
		}
	
		// Size the table as a whole
		sanityWidth = table.outerWidth();
		if ( scrollX === "" ) {
			// No x scrolling
			tableStyle.width = "100%";
	
			// IE7 will make the width of the table when 100% include the scrollbar
			// - which is shouldn't. When there is a scrollbar we need to take this
			// into account.
			if ( ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight ||
				divBody.css('overflow-y') == "scroll")
			) {
				tableStyle.width = _fnStringToCss( table.outerWidth() - barWidth);
			}
	
			// Recalculate the sanity width
			sanityWidth = table.outerWidth();
		}
		else if ( scrollXInner !== "" ) {
			// legacy x scroll inner has been given - use it
			tableStyle.width = _fnStringToCss(scrollXInner);
	
			// Recalculate the sanity width
			sanityWidth = table.outerWidth();
		}
	
		// Hidden header should have zero height, so remove padding and borders. Then
		// set the width based on the real headers
	
		// Apply all styles in one pass
		_fnApplyToChildren( zeroOut, headerSrcEls );
	
		// Read all widths in next pass
		_fnApplyToChildren( function(nSizer) {
			var style = window.getComputedStyle ?
				window.getComputedStyle(nSizer).width :
				_fnStringToCss( $(nSizer).width() );
	
			headerContent.push( nSizer.innerHTML );
			headerWidths.push( style );
		}, headerSrcEls );
	
		// Apply all widths in final pass
		_fnApplyToChildren( function(nToSize, i) {
			nToSize.style.width = headerWidths[i];
		}, headerTrgEls );
	
		$(headerSrcEls).css('height', 0);
	
		/* Same again with the footer if we have one */
		if ( footer )
		{
			_fnApplyToChildren( zeroOut, footerSrcEls );
	
			_fnApplyToChildren( function(nSizer) {
				footerContent.push( nSizer.innerHTML );
				footerWidths.push( _fnStringToCss( $(nSizer).css('width') ) );
			}, footerSrcEls );
	
			_fnApplyToChildren( function(nToSize, i) {
				nToSize.style.width = footerWidths[i];
			}, footerTrgEls );
	
			$(footerSrcEls).height(0);
		}
	
	
		/*
		 * 3. Apply the measurements
		 */
	
		// "Hide" the header and footer that we used for the sizing. We need to keep
		// the content of the cell so that the width applied to the header and body
		// both match, but we want to hide it completely. We want to also fix their
		// width to what they currently are
		_fnApplyToChildren( function(nSizer, i) {
			nSizer.innerHTML = '<div class="dataTables_sizing">'+headerContent[i]+'</div>';
			nSizer.childNodes[0].style.height = "0";
			nSizer.childNodes[0].style.overflow = "hidden";
			nSizer.style.width = headerWidths[i];
		}, headerSrcEls );
	
		if ( footer )
		{
			_fnApplyToChildren( function(nSizer, i) {
				nSizer.innerHTML = '<div class="dataTables_sizing">'+footerContent[i]+'</div>';
				nSizer.childNodes[0].style.height = "0";
				nSizer.childNodes[0].style.overflow = "hidden";
				nSizer.style.width = footerWidths[i];
			}, footerSrcEls );
		}
	
		// Sanity check that the table is of a sensible width. If not then we are going to get
		// misalignment - try to prevent this by not allowing the table to shrink below its min width
		if ( Math.round(table.outerWidth()) < Math.round(sanityWidth) )
		{
			// The min width depends upon if we have a vertical scrollbar visible or not */
			correction = ((divBodyEl.scrollHeight > divBodyEl.offsetHeight ||
				divBody.css('overflow-y') == "scroll")) ?
					sanityWidth+barWidth :
					sanityWidth;
	
			// IE6/7 are a law unto themselves...
			if ( ie67 && (divBodyEl.scrollHeight >
				divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")
			) {
				tableStyle.width = _fnStringToCss( correction-barWidth );
			}
	
			// And give the user a warning that we've stopped the table getting too small
			if ( scrollX === "" || scrollXInner !== "" ) {
				_fnLog( settings, 1, 'Possible column misalignment', 6 );
			}
		}
		else
		{
			correction = '100%';
		}
	
		// Apply to the container elements
		divBodyStyle.width = _fnStringToCss( correction );
		divHeaderStyle.width = _fnStringToCss( correction );
	
		if ( footer ) {
			settings.nScrollFoot.style.width = _fnStringToCss( correction );
		}
	
	
		/*
		 * 4. Clean up
		 */
		if ( ! scrollY ) {
			/* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
			 * the scrollbar height from the visible display, rather than adding it on. We need to
			 * set the height in order to sort this. Don't want to do it in any other browsers.
			 */
			if ( ie67 ) {
				divBodyStyle.height = _fnStringToCss( tableEl.offsetHeight+barWidth );
			}
		}
	
		/* Finally set the width's of the header and footer tables */
		var iOuterWidth = table.outerWidth();
		divHeaderTable[0].style.width = _fnStringToCss( iOuterWidth );
		divHeaderInnerStyle.width = _fnStringToCss( iOuterWidth );
	
		// Figure out if there are scrollbar present - if so then we need a the header and footer to
		// provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
		var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
		var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right' );
		divHeaderInnerStyle[ padding ] = bScrolling ? barWidth+"px" : "0px";
	
		if ( footer ) {
			divFooterTable[0].style.width = _fnStringToCss( iOuterWidth );
			divFooterInner[0].style.width = _fnStringToCss( iOuterWidth );
			divFooterInner[0].style[padding] = bScrolling ? barWidth+"px" : "0px";
		}
	
		// Correct DOM ordering for colgroup - comes before the thead
		table.children('colgroup').insertBefore( table.children('thead') );
	
		/* Adjust the position of the header in case we loose the y-scrollbar */
		divBody.trigger('scroll');
	
		// If sorting or filtering has occurred, jump the scrolling back to the top
		// only if we aren't holding the position
		if ( (settings.bSorted || settings.bFiltered) && ! settings._drawHold ) {
			divBodyEl.scrollTop = 0;
		}
	}
	
	
	
	/**
	 * Apply a given function to the display child nodes of an element array (typically
	 * TD children of TR rows
	 *  @param {function} fn Method to apply to the objects
	 *  @param array {nodes} an1 List of elements to look through for display children
	 *  @param array {nodes} an2 Another list (identical structure to the first) - optional
	 *  @memberof DataTable#oApi
	 */
	function _fnApplyToChildren( fn, an1, an2 )
	{
		var index=0, i=0, iLen=an1.length;
		var nNode1, nNode2;
	
		while ( i < iLen ) {
			nNode1 = an1[i].firstChild;
			nNode2 = an2 ? an2[i].firstChild : null;
	
			while ( nNode1 ) {
				if ( nNode1.nodeType === 1 ) {
					if ( an2 ) {
						fn( nNode1, nNode2, index );
					}
					else {
						fn( nNode1, index );
					}
	
					index++;
				}
	
				nNode1 = nNode1.nextSibling;
				nNode2 = an2 ? nNode2.nextSibling : null;
			}
	
			i++;
		}
	}
	
	
	
	var __re_html_remove = /<.*?>/g;
	
	
	/**
	 * Calculate the width of columns for the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnCalculateColumnWidths ( oSettings )
	{
		var
			table = oSettings.nTable,
			columns = oSettings.aoColumns,
			scroll = oSettings.oScroll,
			scrollY = scroll.sY,
			scrollX = scroll.sX,
			scrollXInner = scroll.sXInner,
			columnCount = columns.length,
			visibleColumns = _fnGetColumns( oSettings, 'bVisible' ),
			headerCells = $('th', oSettings.nTHead),
			tableWidthAttr = table.getAttribute('width'), // from DOM element
			tableContainer = table.parentNode,
			userInputs = false,
			i, column, columnIdx, width, outerWidth,
			browser = oSettings.oBrowser,
			ie67 = browser.bScrollOversize;
	
		var styleWidth = table.style.width;
		if ( styleWidth && styleWidth.indexOf('%') !== -1 ) {
			tableWidthAttr = styleWidth;
		}
	
		/* Convert any user input sizes into pixel sizes */
		for ( i=0 ; i<visibleColumns.length ; i++ ) {
			column = columns[ visibleColumns[i] ];
	
			if ( column.sWidth !== null ) {
				column.sWidth = _fnConvertToWidth( column.sWidthOrig, tableContainer );
	
				userInputs = true;
			}
		}
	
		/* If the number of columns in the DOM equals the number that we have to
		 * process in DataTables, then we can use the offsets that are created by
		 * the web- browser. No custom sizes can be set in order for this to happen,
		 * nor scrolling used
		 */
		if ( ie67 || ! userInputs && ! scrollX && ! scrollY &&
		     columnCount == _fnVisbleColumns( oSettings ) &&
		     columnCount == headerCells.length
		) {
			for ( i=0 ; i<columnCount ; i++ ) {
				var colIdx = _fnVisibleToColumnIndex( oSettings, i );
	
				if ( colIdx !== null ) {
					columns[ colIdx ].sWidth = _fnStringToCss( headerCells.eq(i).width() );
				}
			}
		}
		else
		{
			// Otherwise construct a single row, worst case, table with the widest
			// node in the data, assign any user defined widths, then insert it into
			// the DOM and allow the browser to do all the hard work of calculating
			// table widths
			var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
				.css( 'visibility', 'hidden' )
				.removeAttr( 'id' );
	
			// Clean up the table body
			tmpTable.find('tbody tr').remove();
			var tr = $('<tr/>').appendTo( tmpTable.find('tbody') );
	
			// Clone the table header and footer - we can't use the header / footer
			// from the cloned table, since if scrolling is active, the table's
			// real header and footer are contained in different table tags
			tmpTable.find('thead, tfoot').remove();
			tmpTable
				.append( $(oSettings.nTHead).clone() )
				.append( $(oSettings.nTFoot).clone() );
	
			// Remove any assigned widths from the footer (from scrolling)
			tmpTable.find('tfoot th, tfoot td').css('width', '');
	
			// Apply custom sizing to the cloned header
			headerCells = _fnGetUniqueThs( oSettings, tmpTable.find('thead')[0] );
	
			for ( i=0 ; i<visibleColumns.length ; i++ ) {
				column = columns[ visibleColumns[i] ];
	
				headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ?
					_fnStringToCss( column.sWidthOrig ) :
					'';
	
				// For scrollX we need to force the column width otherwise the
				// browser will collapse it. If this width is smaller than the
				// width the column requires, then it will have no effect
				if ( column.sWidthOrig && scrollX ) {
					$( headerCells[i] ).append( $('<div/>').css( {
						width: column.sWidthOrig,
						margin: 0,
						padding: 0,
						border: 0,
						height: 1
					} ) );
				}
			}
	
			// Find the widest cell for each column and put it into the table
			if ( oSettings.aoData.length ) {
				for ( i=0 ; i<visibleColumns.length ; i++ ) {
					columnIdx = visibleColumns[i];
					column = columns[ columnIdx ];
	
					$( _fnGetWidestNode( oSettings, columnIdx ) )
						.clone( false )
						.append( column.sContentPadding )
						.appendTo( tr );
				}
			}
	
			// Tidy the temporary table - remove name attributes so there aren't
			// duplicated in the dom (radio elements for example)
			$('[name]', tmpTable).removeAttr('name');
	
			// Table has been built, attach to the document so we can work with it.
			// A holding element is used, positioned at the top of the container
			// with minimal height, so it has no effect on if the container scrolls
			// or not. Otherwise it might trigger scrolling when it actually isn't
			// needed
			var holder = $('<div/>').css( scrollX || scrollY ?
					{
						position: 'absolute',
						top: 0,
						left: 0,
						height: 1,
						right: 0,
						overflow: 'hidden'
					} :
					{}
				)
				.append( tmpTable )
				.appendTo( tableContainer );
	
			// When scrolling (X or Y) we want to set the width of the table as 
			// appropriate. However, when not scrolling leave the table width as it
			// is. This results in slightly different, but I think correct behaviour
			if ( scrollX && scrollXInner ) {
				tmpTable.width( scrollXInner );
			}
			else if ( scrollX ) {
				tmpTable.css( 'width', 'auto' );
				tmpTable.removeAttr('width');
	
				// If there is no width attribute or style, then allow the table to
				// collapse
				if ( tmpTable.width() < tableContainer.clientWidth && tableWidthAttr ) {
					tmpTable.width( tableContainer.clientWidth );
				}
			}
			else if ( scrollY ) {
				tmpTable.width( tableContainer.clientWidth );
			}
			else if ( tableWidthAttr ) {
				tmpTable.width( tableWidthAttr );
			}
	
			// Get the width of each column in the constructed table - we need to
			// know the inner width (so it can be assigned to the other table's
			// cells) and the outer width so we can calculate the full width of the
			// table. This is safe since DataTables requires a unique cell for each
			// column, but if ever a header can span multiple columns, this will
			// need to be modified.
			var total = 0;
			for ( i=0 ; i<visibleColumns.length ; i++ ) {
				var cell = $(headerCells[i]);
				var border = cell.outerWidth() - cell.width();
	
				// Use getBounding... where possible (not IE8-) because it can give
				// sub-pixel accuracy, which we then want to round up!
				var bounding = browser.bBounding ?
					Math.ceil( headerCells[i].getBoundingClientRect().width ) :
					cell.outerWidth();
	
				// Total is tracked to remove any sub-pixel errors as the outerWidth
				// of the table might not equal the total given here (IE!).
				total += bounding;
	
				// Width for each column to use
				columns[ visibleColumns[i] ].sWidth = _fnStringToCss( bounding - border );
			}
	
			table.style.width = _fnStringToCss( total );
	
			// Finished with the table - ditch it
			holder.remove();
		}
	
		// If there is a width attr, we want to attach an event listener which
		// allows the table sizing to automatically adjust when the window is
		// resized. Use the width attr rather than CSS, since we can't know if the
		// CSS is a relative value or absolute - DOM read is always px.
		if ( tableWidthAttr ) {
			table.style.width = _fnStringToCss( tableWidthAttr );
		}
	
		if ( (tableWidthAttr || scrollX) && ! oSettings._reszEvt ) {
			var bindResize = function () {
				$(window).on('resize.DT-'+oSettings.sInstance, _fnThrottle( function () {
					_fnAdjustColumnSizing( oSettings );
				} ) );
			};
	
			// IE6/7 will crash if we bind a resize event handler on page load.
			// To be removed in 1.11 which drops IE6/7 support
			if ( ie67 ) {
				setTimeout( bindResize, 1000 );
			}
			else {
				bindResize();
			}
	
			oSettings._reszEvt = true;
		}
	}
	
	
	/**
	 * Throttle the calls to a function. Arguments and context are maintained for
	 * the throttled function
	 *  @param {function} fn Function to be called
	 *  @param {int} [freq=200] call frequency in mS
	 *  @returns {function} wrapped function
	 *  @memberof DataTable#oApi
	 */
	var _fnThrottle = DataTable.util.throttle;
	
	
	/**
	 * Convert a CSS unit width to pixels (e.g. 2em)
	 *  @param {string} width width to be converted
	 *  @param {node} parent parent to get the with for (required for relative widths) - optional
	 *  @returns {int} width in pixels
	 *  @memberof DataTable#oApi
	 */
	function _fnConvertToWidth ( width, parent )
	{
		if ( ! width ) {
			return 0;
		}
	
		var n = $('<div/>')
			.css( 'width', _fnStringToCss( width ) )
			.appendTo( parent || document.body );
	
		var val = n[0].offsetWidth;
		n.remove();
	
		return val;
	}
	
	
	/**
	 * Get the widest node
	 *  @param {object} settings dataTables settings object
	 *  @param {int} colIdx column of interest
	 *  @returns {node} widest table node
	 *  @memberof DataTable#oApi
	 */
	function _fnGetWidestNode( settings, colIdx )
	{
		var idx = _fnGetMaxLenString( settings, colIdx );
		if ( idx < 0 ) {
			return null;
		}
	
		var data = settings.aoData[ idx ];
		return ! data.nTr ? // Might not have been created when deferred rendering
			$('<td/>').html( _fnGetCellData( settings, idx, colIdx, 'display' ) )[0] :
			data.anCells[ colIdx ];
	}
	
	
	/**
	 * Get the maximum strlen for each data column
	 *  @param {object} settings dataTables settings object
	 *  @param {int} colIdx column of interest
	 *  @returns {string} max string length for each column
	 *  @memberof DataTable#oApi
	 */
	function _fnGetMaxLenString( settings, colIdx )
	{
		var s, max=-1, maxIdx = -1;
	
		for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
			s = _fnGetCellData( settings, i, colIdx, 'display' )+'';
			s = s.replace( __re_html_remove, '' );
			s = s.replace( /&nbsp;/g, ' ' );
	
			if ( s.length > max ) {
				max = s.length;
				maxIdx = i;
			}
		}
	
		return maxIdx;
	}
	
	
	/**
	 * Append a CSS unit (only if required) to a string
	 *  @param {string} value to css-ify
	 *  @returns {string} value with css unit
	 *  @memberof DataTable#oApi
	 */
	function _fnStringToCss( s )
	{
		if ( s === null ) {
			return '0px';
		}
	
		if ( typeof s == 'number' ) {
			return s < 0 ?
				'0px' :
				s+'px';
		}
	
		// Check it has a unit character already
		return s.match(/\d$/) ?
			s+'px' :
			s;
	}
	
	
	
	function _fnSortFlatten ( settings )
	{
		var
			i, iLen, k, kLen,
			aSort = [],
			aiOrig = [],
			aoColumns = settings.aoColumns,
			aDataSort, iCol, sType, srcCol,
			fixed = settings.aaSortingFixed,
			fixedObj = $.isPlainObject( fixed ),
			nestedSort = [],
			add = function ( a ) {
				if ( a.length && ! Array.isArray( a[0] ) ) {
					// 1D array
					nestedSort.push( a );
				}
				else {
					// 2D array
					$.merge( nestedSort, a );
				}
			};
	
		// Build the sort array, with pre-fix and post-fix options if they have been
		// specified
		if ( Array.isArray( fixed ) ) {
			add( fixed );
		}
	
		if ( fixedObj && fixed.pre ) {
			add( fixed.pre );
		}
	
		add( settings.aaSorting );
	
		if (fixedObj && fixed.post ) {
			add( fixed.post );
		}
	
		for ( i=0 ; i<nestedSort.length ; i++ )
		{
			srcCol = nestedSort[i][0];
			aDataSort = aoColumns[ srcCol ].aDataSort;
	
			for ( k=0, kLen=aDataSort.length ; k<kLen ; k++ )
			{
				iCol = aDataSort[k];
				sType = aoColumns[ iCol ].sType || 'string';
	
				if ( nestedSort[i]._idx === undefined ) {
					nestedSort[i]._idx = $.inArray( nestedSort[i][1], aoColumns[iCol].asSorting );
				}
	
				aSort.push( {
					src:       srcCol,
					col:       iCol,
					dir:       nestedSort[i][1],
					index:     nestedSort[i]._idx,
					type:      sType,
					formatter: DataTable.ext.type.order[ sType+"-pre" ]
				} );
			}
		}
	
		return aSort;
	}
	
	/**
	 * Change the order of the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 *  @todo This really needs split up!
	 */
	function _fnSort ( oSettings )
	{
		var
			i, ien, iLen, j, jLen, k, kLen,
			sDataType, nTh,
			aiOrig = [],
			oExtSort = DataTable.ext.type.order,
			aoData = oSettings.aoData,
			aoColumns = oSettings.aoColumns,
			aDataSort, data, iCol, sType, oSort,
			formatters = 0,
			sortCol,
			displayMaster = oSettings.aiDisplayMaster,
			aSort;
	
		// Resolve any column types that are unknown due to addition or invalidation
		// @todo Can this be moved into a 'data-ready' handler which is called when
		//   data is going to be used in the table?
		_fnColumnTypes( oSettings );
	
		aSort = _fnSortFlatten( oSettings );
	
		for ( i=0, ien=aSort.length ; i<ien ; i++ ) {
			sortCol = aSort[i];
	
			// Track if we can use the fast sort algorithm
			if ( sortCol.formatter ) {
				formatters++;
			}
	
			// Load the data needed for the sort, for each cell
			_fnSortData( oSettings, sortCol.col );
		}
	
		/* No sorting required if server-side or no sorting array */
		if ( _fnDataSource( oSettings ) != 'ssp' && aSort.length !== 0 )
		{
			// Create a value - key array of the current row positions such that we can use their
			// current position during the sort, if values match, in order to perform stable sorting
			for ( i=0, iLen=displayMaster.length ; i<iLen ; i++ ) {
				aiOrig[ displayMaster[i] ] = i;
			}
	
			/* Do the sort - here we want multi-column sorting based on a given data source (column)
			 * and sorting function (from oSort) in a certain direction. It's reasonably complex to
			 * follow on it's own, but this is what we want (example two column sorting):
			 *  fnLocalSorting = function(a,b){
			 *    var iTest;
			 *    iTest = oSort['string-asc']('data11', 'data12');
			 *      if (iTest !== 0)
			 *        return iTest;
			 *    iTest = oSort['numeric-desc']('data21', 'data22');
			 *    if (iTest !== 0)
			 *      return iTest;
			 *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
			 *  }
			 * Basically we have a test for each sorting column, if the data in that column is equal,
			 * test the next column. If all columns match, then we use a numeric sort on the row
			 * positions in the original data array to provide a stable sort.
			 *
			 * Note - I know it seems excessive to have two sorting methods, but the first is around
			 * 15% faster, so the second is only maintained for backwards compatibility with sorting
			 * methods which do not have a pre-sort formatting function.
			 */
			if ( formatters === aSort.length ) {
				// All sort types have formatting functions
				displayMaster.sort( function ( a, b ) {
					var
						x, y, k, test, sort,
						len=aSort.length,
						dataA = aoData[a]._aSortData,
						dataB = aoData[b]._aSortData;
	
					for ( k=0 ; k<len ; k++ ) {
						sort = aSort[k];
	
						x = dataA[ sort.col ];
						y = dataB[ sort.col ];
	
						test = x<y ? -1 : x>y ? 1 : 0;
						if ( test !== 0 ) {
							return sort.dir === 'asc' ? test : -test;
						}
					}
	
					x = aiOrig[a];
					y = aiOrig[b];
					return x<y ? -1 : x>y ? 1 : 0;
				} );
			}
			else {
				// Depreciated - remove in 1.11 (providing a plug-in option)
				// Not all sort types have formatting methods, so we have to call their sorting
				// methods.
				displayMaster.sort( function ( a, b ) {
					var
						x, y, k, l, test, sort, fn,
						len=aSort.length,
						dataA = aoData[a]._aSortData,
						dataB = aoData[b]._aSortData;
	
					for ( k=0 ; k<len ; k++ ) {
						sort = aSort[k];
	
						x = dataA[ sort.col ];
						y = dataB[ sort.col ];
	
						fn = oExtSort[ sort.type+"-"+sort.dir ] || oExtSort[ "string-"+sort.dir ];
						test = fn( x, y );
						if ( test !== 0 ) {
							return test;
						}
					}
	
					x = aiOrig[a];
					y = aiOrig[b];
					return x<y ? -1 : x>y ? 1 : 0;
				} );
			}
		}
	
		/* Tell the draw function that we have sorted the data */
		oSettings.bSorted = true;
	}
	
	
	function _fnSortAria ( settings )
	{
		var label;
		var nextSort;
		var columns = settings.aoColumns;
		var aSort = _fnSortFlatten( settings );
		var oAria = settings.oLanguage.oAria;
	
		// ARIA attributes - need to loop all columns, to update all (removing old
		// attributes as needed)
		for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
		{
			var col = columns[i];
			var asSorting = col.asSorting;
			var sTitle = col.ariaTitle || col.sTitle.replace( /<.*?>/g, "" );
			var th = col.nTh;
	
			// IE7 is throwing an error when setting these properties with jQuery's
			// attr() and removeAttr() methods...
			th.removeAttribute('aria-sort');
	
			/* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
			if ( col.bSortable ) {
				if ( aSort.length > 0 && aSort[0].col == i ) {
					th.setAttribute('aria-sort', aSort[0].dir=="asc" ? "ascending" : "descending" );
					nextSort = asSorting[ aSort[0].index+1 ] || asSorting[0];
				}
				else {
					nextSort = asSorting[0];
				}
	
				label = sTitle + ( nextSort === "asc" ?
					oAria.sSortAscending :
					oAria.sSortDescending
				);
			}
			else {
				label = sTitle;
			}
	
			th.setAttribute('aria-label', label);
		}
	}
	
	
	/**
	 * Function to run on user sort request
	 *  @param {object} settings dataTables settings object
	 *  @param {node} attachTo node to attach the handler to
	 *  @param {int} colIdx column sorting index
	 *  @param {boolean} [append=false] Append the requested sort to the existing
	 *    sort if true (i.e. multi-column sort)
	 *  @param {function} [callback] callback function
	 *  @memberof DataTable#oApi
	 */
	function _fnSortListener ( settings, colIdx, append, callback )
	{
		var col = settings.aoColumns[ colIdx ];
		var sorting = settings.aaSorting;
		var asSorting = col.asSorting;
		var nextSortIdx;
		var next = function ( a, overflow ) {
			var idx = a._idx;
			if ( idx === undefined ) {
				idx = $.inArray( a[1], asSorting );
			}
	
			return idx+1 < asSorting.length ?
				idx+1 :
				overflow ?
					null :
					0;
		};
	
		// Convert to 2D array if needed
		if ( typeof sorting[0] === 'number' ) {
			sorting = settings.aaSorting = [ sorting ];
		}
	
		// If appending the sort then we are multi-column sorting
		if ( append && settings.oFeatures.bSortMulti ) {
			// Are we already doing some kind of sort on this column?
			var sortIdx = $.inArray( colIdx, _pluck(sorting, '0') );
	
			if ( sortIdx !== -1 ) {
				// Yes, modify the sort
				nextSortIdx = next( sorting[sortIdx], true );
	
				if ( nextSortIdx === null && sorting.length === 1 ) {
					nextSortIdx = 0; // can't remove sorting completely
				}
	
				if ( nextSortIdx === null ) {
					sorting.splice( sortIdx, 1 );
				}
				else {
					sorting[sortIdx][1] = asSorting[ nextSortIdx ];
					sorting[sortIdx]._idx = nextSortIdx;
				}
			}
			else {
				// No sort on this column yet
				sorting.push( [ colIdx, asSorting[0], 0 ] );
				sorting[sorting.length-1]._idx = 0;
			}
		}
		else if ( sorting.length && sorting[0][0] == colIdx ) {
			// Single column - already sorting on this column, modify the sort
			nextSortIdx = next( sorting[0] );
	
			sorting.length = 1;
			sorting[0][1] = asSorting[ nextSortIdx ];
			sorting[0]._idx = nextSortIdx;
		}
		else {
			// Single column - sort only on this column
			sorting.length = 0;
			sorting.push( [ colIdx, asSorting[0] ] );
			sorting[0]._idx = 0;
		}
	
		// Run the sort by calling a full redraw
		_fnReDraw( settings );
	
		// callback used for async user interaction
		if ( typeof callback == 'function' ) {
			callback( settings );
		}
	}
	
	
	/**
	 * Attach a sort handler (click) to a node
	 *  @param {object} settings dataTables settings object
	 *  @param {node} attachTo node to attach the handler to
	 *  @param {int} colIdx column sorting index
	 *  @param {function} [callback] callback function
	 *  @memberof DataTable#oApi
	 */
	function _fnSortAttachListener ( settings, attachTo, colIdx, callback )
	{
		var col = settings.aoColumns[ colIdx ];
	
		_fnBindAction( attachTo, {}, function (e) {
			/* If the column is not sortable - don't to anything */
			if ( col.bSortable === false ) {
				return;
			}
	
			// If processing is enabled use a timeout to allow the processing
			// display to be shown - otherwise to it synchronously
			if ( settings.oFeatures.bProcessing ) {
				_fnProcessingDisplay( settings, true );
	
				setTimeout( function() {
					_fnSortListener( settings, colIdx, e.shiftKey, callback );
	
					// In server-side processing, the draw callback will remove the
					// processing display
					if ( _fnDataSource( settings ) !== 'ssp' ) {
						_fnProcessingDisplay( settings, false );
					}
				}, 0 );
			}
			else {
				_fnSortListener( settings, colIdx, e.shiftKey, callback );
			}
		} );
	}
	
	
	/**
	 * Set the sorting classes on table's body, Note: it is safe to call this function
	 * when bSort and bSortClasses are false
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnSortingClasses( settings )
	{
		var oldSort = settings.aLastSort;
		var sortClass = settings.oClasses.sSortColumn;
		var sort = _fnSortFlatten( settings );
		var features = settings.oFeatures;
		var i, ien, colIdx;
	
		if ( features.bSort && features.bSortClasses ) {
			// Remove old sorting classes
			for ( i=0, ien=oldSort.length ; i<ien ; i++ ) {
				colIdx = oldSort[i].src;
	
				// Remove column sorting
				$( _pluck( settings.aoData, 'anCells', colIdx ) )
					.removeClass( sortClass + (i<2 ? i+1 : 3) );
			}
	
			// Add new column sorting
			for ( i=0, ien=sort.length ; i<ien ; i++ ) {
				colIdx = sort[i].src;
	
				$( _pluck( settings.aoData, 'anCells', colIdx ) )
					.addClass( sortClass + (i<2 ? i+1 : 3) );
			}
		}
	
		settings.aLastSort = sort;
	}
	
	
	// Get the data to sort a column, be it from cache, fresh (populating the
	// cache), or from a sort formatter
	function _fnSortData( settings, idx )
	{
		// Custom sorting function - provided by the sort data type
		var column = settings.aoColumns[ idx ];
		var customSort = DataTable.ext.order[ column.sSortDataType ];
		var customData;
	
		if ( customSort ) {
			customData = customSort.call( settings.oInstance, settings, idx,
				_fnColumnIndexToVisible( settings, idx )
			);
		}
	
		// Use / populate cache
		var row, cellData;
		var formatter = DataTable.ext.type.order[ column.sType+"-pre" ];
	
		for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
			row = settings.aoData[i];
	
			if ( ! row._aSortData ) {
				row._aSortData = [];
			}
	
			if ( ! row._aSortData[idx] || customSort ) {
				cellData = customSort ?
					customData[i] : // If there was a custom sort function, use data from there
					_fnGetCellData( settings, i, idx, 'sort' );
	
				row._aSortData[ idx ] = formatter ?
					formatter( cellData ) :
					cellData;
			}
		}
	}
	
	
	
	/**
	 * Save the state of a table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnSaveState ( settings )
	{
		if (settings._bLoadingState) {
			return;
		}
	
		/* Store the interesting variables */
		var state = {
			time:    +new Date(),
			start:   settings._iDisplayStart,
			length:  settings._iDisplayLength,
			order:   $.extend( true, [], settings.aaSorting ),
			search:  _fnSearchToCamel( settings.oPreviousSearch ),
			columns: $.map( settings.aoColumns, function ( col, i ) {
				return {
					visible: col.bVisible,
					search: _fnSearchToCamel( settings.aoPreSearchCols[i] )
				};
			} )
		};
	
		settings.oSavedState = state;
		_fnCallbackFire( settings, "aoStateSaveParams", 'stateSaveParams', [settings, state] );
		
		if ( settings.oFeatures.bStateSave && !settings.bDestroying )
		{
			settings.fnStateSaveCallback.call( settings.oInstance, settings, state );
		}	
	}
	
	
	/**
	 * Attempt to load a saved table state
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} oInit DataTables init object so we can override settings
	 *  @param {function} callback Callback to execute when the state has been loaded
	 *  @memberof DataTable#oApi
	 */
	function _fnLoadState ( settings, oInit, callback )
	{
		if ( ! settings.oFeatures.bStateSave ) {
			callback();
			return;
		}
	
		var loaded = function(state) {
			_fnImplementState(settings, state, callback);
		}
	
		var state = settings.fnStateLoadCallback.call( settings.oInstance, settings, loaded );
	
		if ( state !== undefined ) {
			_fnImplementState( settings, state, callback );
		}
		// otherwise, wait for the loaded callback to be executed
	
		return true;
	}
	
	function _fnImplementState ( settings, s, callback) {
		var i, ien;
		var columns = settings.aoColumns;
		settings._bLoadingState = true;
	
		// When StateRestore was introduced the state could now be implemented at any time
		// Not just initialisation. To do this an api instance is required in some places
		var api = settings._bInitComplete ? new DataTable.Api(settings) : null;
	
		if ( ! s || ! s.time ) {
			settings._bLoadingState = false;
			callback();
			return;
		}
	
		// Allow custom and plug-in manipulation functions to alter the saved data set and
		// cancelling of loading by returning false
		var abStateLoad = _fnCallbackFire( settings, 'aoStateLoadParams', 'stateLoadParams', [settings, s] );
		if ( $.inArray( false, abStateLoad ) !== -1 ) {
			settings._bLoadingState = false;
			callback();
			return;
		}
	
		// Reject old data
		var duration = settings.iStateDuration;
		if ( duration > 0 && s.time < +new Date() - (duration*1000) ) {
			settings._bLoadingState = false;
			callback();
			return;
		}
	
		// Number of columns have changed - all bets are off, no restore of settings
		if ( s.columns && columns.length !== s.columns.length ) {
			settings._bLoadingState = false;
			callback();
			return;
		}
	
		// Store the saved state so it might be accessed at any time
		settings.oLoadedState = $.extend( true, {}, s );
	
		// Page Length
		if ( s.length !== undefined ) {
			// If already initialised just set the value directly so that the select element is also updated
			if (api) {
				api.page.len(s.length)
			}
			else {
				settings._iDisplayLength   = s.length;
			}
		}
	
		// Restore key features - todo - for 1.11 this needs to be done by
		// subscribed events
		if ( s.start !== undefined ) {
			if(api === null) {
				settings._iDisplayStart    = s.start;
				settings.iInitDisplayStart = s.start;
			}
			else {
				_fnPageChange(settings, s.start/settings._iDisplayLength);
			}
		}
	
		// Order
		if ( s.order !== undefined ) {
			settings.aaSorting = [];
			$.each( s.order, function ( i, col ) {
				settings.aaSorting.push( col[0] >= columns.length ?
					[ 0, col[1] ] :
					col
				);
			} );
		}
	
		// Search
		if ( s.search !== undefined ) {
			$.extend( settings.oPreviousSearch, _fnSearchToHung( s.search ) );
		}
	
		// Columns
		if ( s.columns ) {
			for ( i=0, ien=s.columns.length ; i<ien ; i++ ) {
				var col = s.columns[i];
	
				// Visibility
				if ( col.visible !== undefined ) {
					// If the api is defined, the table has been initialised so we need to use it rather than internal settings
					if (api) {
						// Don't redraw the columns on every iteration of this loop, we will do this at the end instead
						api.column(i).visible(col.visible, false);
					}
					else {
						columns[i].bVisible = col.visible;
					}
				}
	
				// Search
				if ( col.search !== undefined ) {
					$.extend( settings.aoPreSearchCols[i], _fnSearchToHung( col.search ) );
				}
			}
			
			// If the api is defined then we need to adjust the columns once the visibility has been changed
			if (api) {
				api.columns.adjust();
			}
		}
	
		settings._bLoadingState = false;
		_fnCallbackFire( settings, 'aoStateLoaded', 'stateLoaded', [settings, s] );
		callback();
	};
	
	
	/**
	 * Return the settings object for a particular table
	 *  @param {node} table table we are using as a dataTable
	 *  @returns {object} Settings object - or null if not found
	 *  @memberof DataTable#oApi
	 */
	function _fnSettingsFromNode ( table )
	{
		var settings = DataTable.settings;
		var idx = $.inArray( table, _pluck( settings, 'nTable' ) );
	
		return idx !== -1 ?
			settings[ idx ] :
			null;
	}
	
	
	/**
	 * Log an error message
	 *  @param {object} settings dataTables settings object
	 *  @param {int} level log error messages, or display them to the user
	 *  @param {string} msg error message
	 *  @param {int} tn Technical note id to get more information about the error.
	 *  @memberof DataTable#oApi
	 */
	function _fnLog( settings, level, msg, tn )
	{
		msg = 'DataTables warning: '+
			(settings ? 'table id='+settings.sTableId+' - ' : '')+msg;
	
		if ( tn ) {
			msg += '. For more information about this error, please see '+
			'http://datatables.net/tn/'+tn;
		}
	
		if ( ! level  ) {
			// Backwards compatibility pre 1.10
			var ext = DataTable.ext;
			var type = ext.sErrMode || ext.errMode;
	
			if ( settings ) {
				_fnCallbackFire( settings, null, 'error', [ settings, tn, msg ] );
			}
	
			if ( type == 'alert' ) {
				alert( msg );
			}
			else if ( type == 'throw' ) {
				throw new Error(msg);
			}
			else if ( typeof type == 'function' ) {
				type( settings, tn, msg );
			}
		}
		else if ( window.console && console.log ) {
			console.log( msg );
		}
	}
	
	
	/**
	 * See if a property is defined on one object, if so assign it to the other object
	 *  @param {object} ret target object
	 *  @param {object} src source object
	 *  @param {string} name property
	 *  @param {string} [mappedName] name to map too - optional, name used if not given
	 *  @memberof DataTable#oApi
	 */
	function _fnMap( ret, src, name, mappedName )
	{
		if ( Array.isArray( name ) ) {
			$.each( name, function (i, val) {
				if ( Array.isArray( val ) ) {
					_fnMap( ret, src, val[0], val[1] );
				}
				else {
					_fnMap( ret, src, val );
				}
			} );
	
			return;
		}
	
		if ( mappedName === undefined ) {
			mappedName = name;
		}
	
		if ( src[name] !== undefined ) {
			ret[mappedName] = src[name];
		}
	}
	
	
	/**
	 * Extend objects - very similar to jQuery.extend, but deep copy objects, and
	 * shallow copy arrays. The reason we need to do this, is that we don't want to
	 * deep copy array init values (such as aaSorting) since the dev wouldn't be
	 * able to override them, but we do want to deep copy arrays.
	 *  @param {object} out Object to extend
	 *  @param {object} extender Object from which the properties will be applied to
	 *      out
	 *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
	 *      independent copy with the exception of the `data` or `aaData` parameters
	 *      if they are present. This is so you can pass in a collection to
	 *      DataTables and have that used as your data source without breaking the
	 *      references
	 *  @returns {object} out Reference, just for convenience - out === the return.
	 *  @memberof DataTable#oApi
	 *  @todo This doesn't take account of arrays inside the deep copied objects.
	 */
	function _fnExtend( out, extender, breakRefs )
	{
		var val;
	
		for ( var prop in extender ) {
			if ( extender.hasOwnProperty(prop) ) {
				val = extender[prop];
	
				if ( $.isPlainObject( val ) ) {
					if ( ! $.isPlainObject( out[prop] ) ) {
						out[prop] = {};
					}
					$.extend( true, out[prop], val );
				}
				else if ( breakRefs && prop !== 'data' && prop !== 'aaData' && Array.isArray(val) ) {
					out[prop] = val.slice();
				}
				else {
					out[prop] = val;
				}
			}
		}
	
		return out;
	}
	
	
	/**
	 * Bind an event handers to allow a click or return key to activate the callback.
	 * This is good for accessibility since a return on the keyboard will have the
	 * same effect as a click, if the element has focus.
	 *  @param {element} n Element to bind the action to
	 *  @param {object} oData Data object to pass to the triggered function
	 *  @param {function} fn Callback function for when the event is triggered
	 *  @memberof DataTable#oApi
	 */
	function _fnBindAction( n, oData, fn )
	{
		$(n)
			.on( 'click.DT', oData, function (e) {
					$(n).trigger('blur'); // Remove focus outline for mouse users
					fn(e);
				} )
			.on( 'keypress.DT', oData, function (e){
					if ( e.which === 13 ) {
						e.preventDefault();
						fn(e);
					}
				} )
			.on( 'selectstart.DT', function () {
					/* Take the brutal approach to cancelling text selection */
					return false;
				} );
	}
	
	
	/**
	 * Register a callback function. Easily allows a callback function to be added to
	 * an array store of callback functions that can then all be called together.
	 *  @param {object} oSettings dataTables settings object
	 *  @param {string} sStore Name of the array storage for the callbacks in oSettings
	 *  @param {function} fn Function to be called back
	 *  @param {string} sName Identifying name for the callback (i.e. a label)
	 *  @memberof DataTable#oApi
	 */
	function _fnCallbackReg( oSettings, sStore, fn, sName )
	{
		if ( fn )
		{
			oSettings[sStore].push( {
				"fn": fn,
				"sName": sName
			} );
		}
	}
	
	
	/**
	 * Fire callback functions and trigger events. Note that the loop over the
	 * callback array store is done backwards! Further note that you do not want to
	 * fire off triggers in time sensitive applications (for example cell creation)
	 * as its slow.
	 *  @param {object} settings dataTables settings object
	 *  @param {string} callbackArr Name of the array storage for the callbacks in
	 *      oSettings
	 *  @param {string} eventName Name of the jQuery custom event to trigger. If
	 *      null no trigger is fired
	 *  @param {array} args Array of arguments to pass to the callback function /
	 *      trigger
	 *  @memberof DataTable#oApi
	 */
	function _fnCallbackFire( settings, callbackArr, eventName, args )
	{
		var ret = [];
	
		if ( callbackArr ) {
			ret = $.map( settings[callbackArr].slice().reverse(), function (val, i) {
				return val.fn.apply( settings.oInstance, args );
			} );
		}
	
		if ( eventName !== null ) {
			var e = $.Event( eventName+'.dt' );
			var table = $(settings.nTable);
	
			table.trigger( e, args );
	
			// If not yet attached to the document, trigger the event
			// on the body directly to sort of simulate the bubble
			if (table.parents('body').length === 0) {
				$('body').trigger( e, args );
			}
	
			ret.push( e.result );
		}
	
		return ret;
	}
	
	
	function _fnLengthOverflow ( settings )
	{
		var
			start = settings._iDisplayStart,
			end = settings.fnDisplayEnd(),
			len = settings._iDisplayLength;
	
		/* If we have space to show extra rows (backing up from the end point - then do so */
		if ( start >= end )
		{
			start = end - len;
		}
	
		// Keep the start record on the current page
		start -= (start % len);
	
		if ( len === -1 || start < 0 )
		{
			start = 0;
		}
	
		settings._iDisplayStart = start;
	}
	
	
	function _fnRenderer( settings, type )
	{
		var renderer = settings.renderer;
		var host = DataTable.ext.renderer[type];
	
		if ( $.isPlainObject( renderer ) && renderer[type] ) {
			// Specific renderer for this type. If available use it, otherwise use
			// the default.
			return host[renderer[type]] || host._;
		}
		else if ( typeof renderer === 'string' ) {
			// Common renderer - if there is one available for this type use it,
			// otherwise use the default
			return host[renderer] || host._;
		}
	
		// Use the default
		return host._;
	}
	
	
	/**
	 * Detect the data source being used for the table. Used to simplify the code
	 * a little (ajax) and to make it compress a little smaller.
	 *
	 *  @param {object} settings dataTables settings object
	 *  @returns {string} Data source
	 *  @memberof DataTable#oApi
	 */
	function _fnDataSource ( settings )
	{
		if ( settings.oFeatures.bServerSide ) {
			return 'ssp';
		}
		else if ( settings.ajax || settings.sAjaxSource ) {
			return 'ajax';
		}
		return 'dom';
	}
	
	
	
	
	/**
	 * Computed structure of the DataTables API, defined by the options passed to
	 * `DataTable.Api.register()` when building the API.
	 *
	 * The structure is built in order to speed creation and extension of the Api
	 * objects since the extensions are effectively pre-parsed.
	 *
	 * The array is an array of objects with the following structure, where this
	 * base array represents the Api prototype base:
	 *
	 *     [
	 *       {
	 *         name:      'data'                -- string   - Property name
	 *         val:       function () {},       -- function - Api method (or undefined if just an object
	 *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
	 *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
	 *       },
	 *       {
	 *         name:     'row'
	 *         val:       {},
	 *         methodExt: [ ... ],
	 *         propExt:   [
	 *           {
	 *             name:      'data'
	 *             val:       function () {},
	 *             methodExt: [ ... ],
	 *             propExt:   [ ... ]
	 *           },
	 *           ...
	 *         ]
	 *       }
	 *     ]
	 *
	 * @type {Array}
	 * @ignore
	 */
	var __apiStruct = [];
	
	
	/**
	 * `Array.prototype` reference.
	 *
	 * @type object
	 * @ignore
	 */
	var __arrayProto = Array.prototype;
	
	
	/**
	 * Abstraction for `context` parameter of the `Api` constructor to allow it to
	 * take several different forms for ease of use.
	 *
	 * Each of the input parameter types will be converted to a DataTables settings
	 * object where possible.
	 *
	 * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
	 *   of:
	 *
	 *   * `string` - jQuery selector. Any DataTables' matching the given selector
	 *     with be found and used.
	 *   * `node` - `TABLE` node which has already been formed into a DataTable.
	 *   * `jQuery` - A jQuery object of `TABLE` nodes.
	 *   * `object` - DataTables settings object
	 *   * `DataTables.Api` - API instance
	 * @return {array|null} Matching DataTables settings objects. `null` or
	 *   `undefined` is returned if no matching DataTable is found.
	 * @ignore
	 */
	var _toSettings = function ( mixed )
	{
		var idx, jq;
		var settings = DataTable.settings;
		var tables = $.map( settings, function (el, i) {
			return el.nTable;
		} );
	
		if ( ! mixed ) {
			return [];
		}
		else if ( mixed.nTable && mixed.oApi ) {
			// DataTables settings object
			return [ mixed ];
		}
		else if ( mixed.nodeName && mixed.nodeName.toLowerCase() === 'table' ) {
			// Table node
			idx = $.inArray( mixed, tables );
			return idx !== -1 ? [ settings[idx] ] : null;
		}
		else if ( mixed && typeof mixed.settings === 'function' ) {
			return mixed.settings().toArray();
		}
		else if ( typeof mixed === 'string' ) {
			// jQuery selector
			jq = $(mixed);
		}
		else if ( mixed instanceof $ ) {
			// jQuery object (also DataTables instance)
			jq = mixed;
		}
	
		if ( jq ) {
			return jq.map( function(i) {
				idx = $.inArray( this, tables );
				return idx !== -1 ? settings[idx] : null;
			} ).toArray();
		}
	};
	
	
	/**
	 * DataTables API class - used to control and interface with  one or more
	 * DataTables enhanced tables.
	 *
	 * The API class is heavily based on jQuery, presenting a chainable interface
	 * that you can use to interact with tables. Each instance of the API class has
	 * a "context" - i.e. the tables that it will operate on. This could be a single
	 * table, all tables on a page or a sub-set thereof.
	 *
	 * Additionally the API is designed to allow you to easily work with the data in
	 * the tables, retrieving and manipulating it as required. This is done by
	 * presenting the API class as an array like interface. The contents of the
	 * array depend upon the actions requested by each method (for example
	 * `rows().nodes()` will return an array of nodes, while `rows().data()` will
	 * return an array of objects or arrays depending upon your table's
	 * configuration). The API object has a number of array like methods (`push`,
	 * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
	 * `unique` etc) to assist your working with the data held in a table.
	 *
	 * Most methods (those which return an Api instance) are chainable, which means
	 * the return from a method call also has all of the methods available that the
	 * top level object had. For example, these two calls are equivalent:
	 *
	 *     // Not chained
	 *     api.row.add( {...} );
	 *     api.draw();
	 *
	 *     // Chained
	 *     api.row.add( {...} ).draw();
	 *
	 * @class DataTable.Api
	 * @param {array|object|string|jQuery} context DataTable identifier. This is
	 *   used to define which DataTables enhanced tables this API will operate on.
	 *   Can be one of:
	 *
	 *   * `string` - jQuery selector. Any DataTables' matching the given selector
	 *     with be found and used.
	 *   * `node` - `TABLE` node which has already been formed into a DataTable.
	 *   * `jQuery` - A jQuery object of `TABLE` nodes.
	 *   * `object` - DataTables settings object
	 * @param {array} [data] Data to initialise the Api instance with.
	 *
	 * @example
	 *   // Direct initialisation during DataTables construction
	 *   var api = $('#example').DataTable();
	 *
	 * @example
	 *   // Initialisation using a DataTables jQuery object
	 *   var api = $('#example').dataTable().api();
	 *
	 * @example
	 *   // Initialisation as a constructor
	 *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
	 */
	_Api = function ( context, data )
	{
		if ( ! (this instanceof _Api) ) {
			return new _Api( context, data );
		}
	
		var settings = [];
		var ctxSettings = function ( o ) {
			var a = _toSettings( o );
			if ( a ) {
				settings.push.apply( settings, a );
			}
		};
	
		if ( Array.isArray( context ) ) {
			for ( var i=0, ien=context.length ; i<ien ; i++ ) {
				ctxSettings( context[i] );
			}
		}
		else {
			ctxSettings( context );
		}
	
		// Remove duplicates
		this.context = _unique( settings );
	
		// Initial data
		if ( data ) {
			$.merge( this, data );
		}
	
		// selector
		this.selector = {
			rows: null,
			cols: null,
			opts: null
		};
	
		_Api.extend( this, this, __apiStruct );
	};
	
	DataTable.Api = _Api;
	
	// Don't destroy the existing prototype, just extend it. Required for jQuery 2's
	// isPlainObject.
	$.extend( _Api.prototype, {
		any: function ()
		{
			return this.count() !== 0;
		},
	
	
		concat:  __arrayProto.concat,
	
	
		context: [], // array of table settings objects
	
	
		count: function ()
		{
			return this.flatten().length;
		},
	
	
		each: function ( fn )
		{
			for ( var i=0, ien=this.length ; i<ien; i++ ) {
				fn.call( this, this[i], i, this );
			}
	
			return this;
		},
	
	
		eq: function ( idx )
		{
			var ctx = this.context;
	
			return ctx.length > idx ?
				new _Api( ctx[idx], this[idx] ) :
				null;
		},
	
	
		filter: function ( fn )
		{
			var a = [];
	
			if ( __arrayProto.filter ) {
				a = __arrayProto.filter.call( this, fn, this );
			}
			else {
				// Compatibility for browsers without EMCA-252-5 (JS 1.6)
				for ( var i=0, ien=this.length ; i<ien ; i++ ) {
					if ( fn.call( this, this[i], i, this ) ) {
						a.push( this[i] );
					}
				}
			}
	
			return new _Api( this.context, a );
		},
	
	
		flatten: function ()
		{
			var a = [];
			return new _Api( this.context, a.concat.apply( a, this.toArray() ) );
		},
	
	
		join:    __arrayProto.join,
	
	
		indexOf: __arrayProto.indexOf || function (obj, start)
		{
			for ( var i=(start || 0), ien=this.length ; i<ien ; i++ ) {
				if ( this[i] === obj ) {
					return i;
				}
			}
			return -1;
		},
	
		iterator: function ( flatten, type, fn, alwaysNew ) {
			var
				a = [], ret,
				i, ien, j, jen,
				context = this.context,
				rows, items, item,
				selector = this.selector;
	
			// Argument shifting
			if ( typeof flatten === 'string' ) {
				alwaysNew = fn;
				fn = type;
				type = flatten;
				flatten = false;
			}
	
			for ( i=0, ien=context.length ; i<ien ; i++ ) {
				var apiInst = new _Api( context[i] );
	
				if ( type === 'table' ) {
					ret = fn.call( apiInst, context[i], i );
	
					if ( ret !== undefined ) {
						a.push( ret );
					}
				}
				else if ( type === 'columns' || type === 'rows' ) {
					// this has same length as context - one entry for each table
					ret = fn.call( apiInst, context[i], this[i], i );
	
					if ( ret !== undefined ) {
						a.push( ret );
					}
				}
				else if ( type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell' ) {
					// columns and rows share the same structure.
					// 'this' is an array of column indexes for each context
					items = this[i];
	
					if ( type === 'column-rows' ) {
						rows = _selector_row_indexes( context[i], selector.opts );
					}
	
					for ( j=0, jen=items.length ; j<jen ; j++ ) {
						item = items[j];
	
						if ( type === 'cell' ) {
							ret = fn.call( apiInst, context[i], item.row, item.column, i, j );
						}
						else {
							ret = fn.call( apiInst, context[i], item, i, j, rows );
						}
	
						if ( ret !== undefined ) {
							a.push( ret );
						}
					}
				}
			}
	
			if ( a.length || alwaysNew ) {
				var api = new _Api( context, flatten ? a.concat.apply( [], a ) : a );
				var apiSelector = api.selector;
				apiSelector.rows = selector.rows;
				apiSelector.cols = selector.cols;
				apiSelector.opts = selector.opts;
				return api;
			}
			return this;
		},
	
	
		lastIndexOf: __arrayProto.lastIndexOf || function (obj, start)
		{
			// Bit cheeky...
			return this.indexOf.apply( this.toArray.reverse(), arguments );
		},
	
	
		length:  0,
	
	
		map: function ( fn )
		{
			var a = [];
	
			if ( __arrayProto.map ) {
				a = __arrayProto.map.call( this, fn, this );
			}
			else {
				// Compatibility for browsers without EMCA-252-5 (JS 1.6)
				for ( var i=0, ien=this.length ; i<ien ; i++ ) {
					a.push( fn.call( this, this[i], i ) );
				}
			}
	
			return new _Api( this.context, a );
		},
	
	
		pluck: function ( prop )
		{
			var fn = DataTable.util.get(prop);
	
			return this.map( function ( el ) {
				return fn(el);
			} );
		},
	
		pop:     __arrayProto.pop,
	
	
		push:    __arrayProto.push,
	
	
		// Does not return an API instance
		reduce: __arrayProto.reduce || function ( fn, init )
		{
			return _fnReduce( this, fn, init, 0, this.length, 1 );
		},
	
	
		reduceRight: __arrayProto.reduceRight || function ( fn, init )
		{
			return _fnReduce( this, fn, init, this.length-1, -1, -1 );
		},
	
	
		reverse: __arrayProto.reverse,
	
	
		// Object with rows, columns and opts
		selector: null,
	
	
		shift:   __arrayProto.shift,
	
	
		slice: function () {
			return new _Api( this.context, this );
		},
	
	
		sort:    __arrayProto.sort, // ? name - order?
	
	
		splice:  __arrayProto.splice,
	
	
		toArray: function ()
		{
			return __arrayProto.slice.call( this );
		},
	
	
		to$: function ()
		{
			return $( this );
		},
	
	
		toJQuery: function ()
		{
			return $( this );
		},
	
	
		unique: function ()
		{
			return new _Api( this.context, _unique(this) );
		},
	
	
		unshift: __arrayProto.unshift
	} );
	
	
	_Api.extend = function ( scope, obj, ext )
	{
		// Only extend API instances and static properties of the API
		if ( ! ext.length || ! obj || ( ! (obj instanceof _Api) && ! obj.__dt_wrapper ) ) {
			return;
		}
	
		var
			i, ien,
			struct,
			methodScoping = function ( scope, fn, struc ) {
				return function () {
					var ret = fn.apply( scope, arguments );
	
					// Method extension
					_Api.extend( ret, ret, struc.methodExt );
					return ret;
				};
			};
	
		for ( i=0, ien=ext.length ; i<ien ; i++ ) {
			struct = ext[i];
	
			// Value
			obj[ struct.name ] = struct.type === 'function' ?
				methodScoping( scope, struct.val, struct ) :
				struct.type === 'object' ?
					{} :
					struct.val;
	
			obj[ struct.name ].__dt_wrapper = true;
	
			// Property extension
			_Api.extend( scope, obj[ struct.name ], struct.propExt );
		}
	};
	
	
	// @todo - Is there need for an augment function?
	// _Api.augment = function ( inst, name )
	// {
	// 	// Find src object in the structure from the name
	// 	var parts = name.split('.');
	
	// 	_Api.extend( inst, obj );
	// };
	
	
	//     [
	//       {
	//         name:      'data'                -- string   - Property name
	//         val:       function () {},       -- function - Api method (or undefined if just an object
	//         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
	//         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
	//       },
	//       {
	//         name:     'row'
	//         val:       {},
	//         methodExt: [ ... ],
	//         propExt:   [
	//           {
	//             name:      'data'
	//             val:       function () {},
	//             methodExt: [ ... ],
	//             propExt:   [ ... ]
	//           },
	//           ...
	//         ]
	//       }
	//     ]
	
	_Api.register = _api_register = function ( name, val )
	{
		if ( Array.isArray( name ) ) {
			for ( var j=0, jen=name.length ; j<jen ; j++ ) {
				_Api.register( name[j], val );
			}
			return;
		}
	
		var
			i, ien,
			heir = name.split('.'),
			struct = __apiStruct,
			key, method;
	
		var find = function ( src, name ) {
			for ( var i=0, ien=src.length ; i<ien ; i++ ) {
				if ( src[i].name === name ) {
					return src[i];
				}
			}
			return null;
		};
	
		for ( i=0, ien=heir.length ; i<ien ; i++ ) {
			method = heir[i].indexOf('()') !== -1;
			key = method ?
				heir[i].replace('()', '') :
				heir[i];
	
			var src = find( struct, key );
			if ( ! src ) {
				src = {
					name:      key,
					val:       {},
					methodExt: [],
					propExt:   [],
					type:      'object'
				};
				struct.push( src );
			}
	
			if ( i === ien-1 ) {
				src.val = val;
				src.type = typeof val === 'function' ?
					'function' :
					$.isPlainObject( val ) ?
						'object' :
						'other';
			}
			else {
				struct = method ?
					src.methodExt :
					src.propExt;
			}
		}
	};
	
	_Api.registerPlural = _api_registerPlural = function ( pluralName, singularName, val ) {
		_Api.register( pluralName, val );
	
		_Api.register( singularName, function () {
			var ret = val.apply( this, arguments );
	
			if ( ret === this ) {
				// Returned item is the API instance that was passed in, return it
				return this;
			}
			else if ( ret instanceof _Api ) {
				// New API instance returned, want the value from the first item
				// in the returned array for the singular result.
				return ret.length ?
					Array.isArray( ret[0] ) ?
						new _Api( ret.context, ret[0] ) : // Array results are 'enhanced'
						ret[0] :
					undefined;
			}
	
			// Non-API return - just fire it back
			return ret;
		} );
	};
	
	
	/**
	 * Selector for HTML tables. Apply the given selector to the give array of
	 * DataTables settings objects.
	 *
	 * @param {string|integer} [selector] jQuery selector string or integer
	 * @param  {array} Array of DataTables settings objects to be filtered
	 * @return {array}
	 * @ignore
	 */
	var __table_selector = function ( selector, a )
	{
		if ( Array.isArray(selector) ) {
			return $.map( selector, function (item) {
				return __table_selector(item, a);
			} );
		}
	
		// Integer is used to pick out a table by index
		if ( typeof selector === 'number' ) {
			return [ a[ selector ] ];
		}
	
		// Perform a jQuery selector on the table nodes
		var nodes = $.map( a, function (el, i) {
			return el.nTable;
		} );
	
		return $(nodes)
			.filter( selector )
			.map( function (i) {
				// Need to translate back from the table node to the settings
				var idx = $.inArray( this, nodes );
				return a[ idx ];
			} )
			.toArray();
	};
	
	
	
	/**
	 * Context selector for the API's context (i.e. the tables the API instance
	 * refers to.
	 *
	 * @name    DataTable.Api#tables
	 * @param {string|integer} [selector] Selector to pick which tables the iterator
	 *   should operate on. If not given, all tables in the current context are
	 *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
	 *   select multiple tables or as an integer to select a single table.
	 * @returns {DataTable.Api} Returns a new API instance if a selector is given.
	 */
	_api_register( 'tables()', function ( selector ) {
		// A new instance is created if there was a selector specified
		return selector !== undefined && selector !== null ?
			new _Api( __table_selector( selector, this.context ) ) :
			this;
	} );
	
	
	_api_register( 'table()', function ( selector ) {
		var tables = this.tables( selector );
		var ctx = tables.context;
	
		// Truncate to the first matched table
		return ctx.length ?
			new _Api( ctx[0] ) :
			tables;
	} );
	
	
	_api_registerPlural( 'tables().nodes()', 'table().node()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTable;
		}, 1 );
	} );
	
	
	_api_registerPlural( 'tables().body()', 'table().body()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTBody;
		}, 1 );
	} );
	
	
	_api_registerPlural( 'tables().header()', 'table().header()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTHead;
		}, 1 );
	} );
	
	
	_api_registerPlural( 'tables().footer()', 'table().footer()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTFoot;
		}, 1 );
	} );
	
	
	_api_registerPlural( 'tables().containers()', 'table().container()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTableWrapper;
		}, 1 );
	} );
	
	
	
	/**
	 * Redraw the tables in the current context.
	 */
	_api_register( 'draw()', function ( paging ) {
		return this.iterator( 'table', function ( settings ) {
			if ( paging === 'page' ) {
				_fnDraw( settings );
			}
			else {
				if ( typeof paging === 'string' ) {
					paging = paging === 'full-hold' ?
						false :
						true;
				}
	
				_fnReDraw( settings, paging===false );
			}
		} );
	} );
	
	
	
	/**
	 * Get the current page index.
	 *
	 * @return {integer} Current page index (zero based)
	 *//**
	 * Set the current page.
	 *
	 * Note that if you attempt to show a page which does not exist, DataTables will
	 * not throw an error, but rather reset the paging.
	 *
	 * @param {integer|string} action The paging action to take. This can be one of:
	 *  * `integer` - The page index to jump to
	 *  * `string` - An action to take:
	 *    * `first` - Jump to first page.
	 *    * `next` - Jump to the next page
	 *    * `previous` - Jump to previous page
	 *    * `last` - Jump to the last page.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'page()', function ( action ) {
		if ( action === undefined ) {
			return this.page.info().page; // not an expensive call
		}
	
		// else, have an action to take on all tables
		return this.iterator( 'table', function ( settings ) {
			_fnPageChange( settings, action );
		} );
	} );
	
	
	/**
	 * Paging information for the first table in the current context.
	 *
	 * If you require paging information for another table, use the `table()` method
	 * with a suitable selector.
	 *
	 * @return {object} Object with the following properties set:
	 *  * `page` - Current page index (zero based - i.e. the first page is `0`)
	 *  * `pages` - Total number of pages
	 *  * `start` - Display index for the first record shown on the current page
	 *  * `end` - Display index for the last record shown on the current page
	 *  * `length` - Display length (number of records). Note that generally `start
	 *    + length = end`, but this is not always true, for example if there are
	 *    only 2 records to show on the final page, with a length of 10.
	 *  * `recordsTotal` - Full data set length
	 *  * `recordsDisplay` - Data set length once the current filtering criterion
	 *    are applied.
	 */
	_api_register( 'page.info()', function ( action ) {
		if ( this.context.length === 0 ) {
			return undefined;
		}
	
		var
			settings   = this.context[0],
			start      = settings._iDisplayStart,
			len        = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
			visRecords = settings.fnRecordsDisplay(),
			all        = len === -1;
	
		return {
			"page":           all ? 0 : Math.floor( start / len ),
			"pages":          all ? 1 : Math.ceil( visRecords / len ),
			"start":          start,
			"end":            settings.fnDisplayEnd(),
			"length":         len,
			"recordsTotal":   settings.fnRecordsTotal(),
			"recordsDisplay": visRecords,
			"serverSide":     _fnDataSource( settings ) === 'ssp'
		};
	} );
	
	
	/**
	 * Get the current page length.
	 *
	 * @return {integer} Current page length. Note `-1` indicates that all records
	 *   are to be shown.
	 *//**
	 * Set the current page length.
	 *
	 * @param {integer} Page length to set. Use `-1` to show all records.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'page.len()', function ( len ) {
		// Note that we can't call this function 'length()' because `length`
		// is a Javascript property of functions which defines how many arguments
		// the function expects.
		if ( len === undefined ) {
			return this.context.length !== 0 ?
				this.context[0]._iDisplayLength :
				undefined;
		}
	
		// else, set the page length
		return this.iterator( 'table', function ( settings ) {
			_fnLengthChange( settings, len );
		} );
	} );
	
	
	
	var __reload = function ( settings, holdPosition, callback ) {
		// Use the draw event to trigger a callback
		if ( callback ) {
			var api = new _Api( settings );
	
			api.one( 'draw', function () {
				callback( api.ajax.json() );
			} );
		}
	
		if ( _fnDataSource( settings ) == 'ssp' ) {
			_fnReDraw( settings, holdPosition );
		}
		else {
			_fnProcessingDisplay( settings, true );
	
			// Cancel an existing request
			var xhr = settings.jqXHR;
			if ( xhr && xhr.readyState !== 4 ) {
				xhr.abort();
			}
	
			// Trigger xhr
			_fnBuildAjax( settings, [], function( json ) {
				_fnClearTable( settings );
	
				var data = _fnAjaxDataSrc( settings, json );
				for ( var i=0, ien=data.length ; i<ien ; i++ ) {
					_fnAddData( settings, data[i] );
				}
	
				_fnReDraw( settings, holdPosition );
				_fnProcessingDisplay( settings, false );
			} );
		}
	};
	
	
	/**
	 * Get the JSON response from the last Ajax request that DataTables made to the
	 * server. Note that this returns the JSON from the first table in the current
	 * context.
	 *
	 * @return {object} JSON received from the server.
	 */
	_api_register( 'ajax.json()', function () {
		var ctx = this.context;
	
		if ( ctx.length > 0 ) {
			return ctx[0].json;
		}
	
		// else return undefined;
	} );
	
	
	/**
	 * Get the data submitted in the last Ajax request
	 */
	_api_register( 'ajax.params()', function () {
		var ctx = this.context;
	
		if ( ctx.length > 0 ) {
			return ctx[0].oAjaxData;
		}
	
		// else return undefined;
	} );
	
	
	/**
	 * Reload tables from the Ajax data source. Note that this function will
	 * automatically re-draw the table when the remote data has been loaded.
	 *
	 * @param {boolean} [reset=true] Reset (default) or hold the current paging
	 *   position. A full re-sort and re-filter is performed when this method is
	 *   called, which is why the pagination reset is the default action.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'ajax.reload()', function ( callback, resetPaging ) {
		return this.iterator( 'table', function (settings) {
			__reload( settings, resetPaging===false, callback );
		} );
	} );
	
	
	/**
	 * Get the current Ajax URL. Note that this returns the URL from the first
	 * table in the current context.
	 *
	 * @return {string} Current Ajax source URL
	 *//**
	 * Set the Ajax URL. Note that this will set the URL for all tables in the
	 * current context.
	 *
	 * @param {string} url URL to set.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'ajax.url()', function ( url ) {
		var ctx = this.context;
	
		if ( url === undefined ) {
			// get
			if ( ctx.length === 0 ) {
				return undefined;
			}
			ctx = ctx[0];
	
			return ctx.ajax ?
				$.isPlainObject( ctx.ajax ) ?
					ctx.ajax.url :
					ctx.ajax :
				ctx.sAjaxSource;
		}
	
		// set
		return this.iterator( 'table', function ( settings ) {
			if ( $.isPlainObject( settings.ajax ) ) {
				settings.ajax.url = url;
			}
			else {
				settings.ajax = url;
			}
			// No need to consider sAjaxSource here since DataTables gives priority
			// to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
			// value of `sAjaxSource` redundant.
		} );
	} );
	
	
	/**
	 * Load data from the newly set Ajax URL. Note that this method is only
	 * available when `ajax.url()` is used to set a URL. Additionally, this method
	 * has the same effect as calling `ajax.reload()` but is provided for
	 * convenience when setting a new URL. Like `ajax.reload()` it will
	 * automatically redraw the table once the remote data has been loaded.
	 *
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'ajax.url().load()', function ( callback, resetPaging ) {
		// Same as a reload, but makes sense to present it for easy access after a
		// url change
		return this.iterator( 'table', function ( ctx ) {
			__reload( ctx, resetPaging===false, callback );
		} );
	} );
	
	
	
	
	var _selector_run = function ( type, selector, selectFn, settings, opts )
	{
		var
			out = [], res,
			a, i, ien, j, jen,
			selectorType = typeof selector;
	
		// Can't just check for isArray here, as an API or jQuery instance might be
		// given with their array like look
		if ( ! selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined ) {
			selector = [ selector ];
		}
	
		for ( i=0, ien=selector.length ; i<ien ; i++ ) {
			// Only split on simple strings - complex expressions will be jQuery selectors
			a = selector[i] && selector[i].split && ! selector[i].match(/[\[\(:]/) ?
				selector[i].split(',') :
				[ selector[i] ];
	
			for ( j=0, jen=a.length ; j<jen ; j++ ) {
				res = selectFn( typeof a[j] === 'string' ? (a[j]).trim() : a[j] );
	
				if ( res && res.length ) {
					out = out.concat( res );
				}
			}
		}
	
		// selector extensions
		var ext = _ext.selector[ type ];
		if ( ext.length ) {
			for ( i=0, ien=ext.length ; i<ien ; i++ ) {
				out = ext[i]( settings, opts, out );
			}
		}
	
		return _unique( out );
	};
	
	
	var _selector_opts = function ( opts )
	{
		if ( ! opts ) {
			opts = {};
		}
	
		// Backwards compatibility for 1.9- which used the terminology filter rather
		// than search
		if ( opts.filter && opts.search === undefined ) {
			opts.search = opts.filter;
		}
	
		return $.extend( {
			search: 'none',
			order: 'current',
			page: 'all'
		}, opts );
	};
	
	
	var _selector_first = function ( inst )
	{
		// Reduce the API instance to the first item found
		for ( var i=0, ien=inst.length ; i<ien ; i++ ) {
			if ( inst[i].length > 0 ) {
				// Assign the first element to the first item in the instance
				// and truncate the instance and context
				inst[0] = inst[i];
				inst[0].length = 1;
				inst.length = 1;
				inst.context = [ inst.context[i] ];
	
				return inst;
			}
		}
	
		// Not found - return an empty instance
		inst.length = 0;
		return inst;
	};
	
	
	var _selector_row_indexes = function ( settings, opts )
	{
		var
			i, ien, tmp, a=[],
			displayFiltered = settings.aiDisplay,
			displayMaster = settings.aiDisplayMaster;
	
		var
			search = opts.search,  // none, applied, removed
			order  = opts.order,   // applied, current, index (original - compatibility with 1.9)
			page   = opts.page;    // all, current
	
		if ( _fnDataSource( settings ) == 'ssp' ) {
			// In server-side processing mode, most options are irrelevant since
			// rows not shown don't exist and the index order is the applied order
			// Removed is a special case - for consistency just return an empty
			// array
			return search === 'removed' ?
				[] :
				_range( 0, displayMaster.length );
		}
		else if ( page == 'current' ) {
			// Current page implies that order=current and filter=applied, since it is
			// fairly senseless otherwise, regardless of what order and search actually
			// are
			for ( i=settings._iDisplayStart, ien=settings.fnDisplayEnd() ; i<ien ; i++ ) {
				a.push( displayFiltered[i] );
			}
		}
		else if ( order == 'current' || order == 'applied' ) {
			if ( search == 'none') {
				a = displayMaster.slice();
			}
			else if ( search == 'applied' ) {
				a = displayFiltered.slice();
			}
			else if ( search == 'removed' ) {
				// O(n+m) solution by creating a hash map
				var displayFilteredMap = {};
	
				for ( var i=0, ien=displayFiltered.length ; i<ien ; i++ ) {
					displayFilteredMap[displayFiltered[i]] = null;
				}
	
				a = $.map( displayMaster, function (el) {
					return ! displayFilteredMap.hasOwnProperty(el) ?
						el :
						null;
				} );
			}
		}
		else if ( order == 'index' || order == 'original' ) {
			for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
				if ( search == 'none' ) {
					a.push( i );
				}
				else { // applied | removed
					tmp = $.inArray( i, displayFiltered );
	
					if ((tmp === -1 && search == 'removed') ||
						(tmp >= 0   && search == 'applied') )
					{
						a.push( i );
					}
				}
			}
		}
	
		return a;
	};
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Rows
	 *
	 * {}          - no selector - use all available rows
	 * {integer}   - row aoData index
	 * {node}      - TR node
	 * {string}    - jQuery selector to apply to the TR elements
	 * {array}     - jQuery array of nodes, or simply an array of TR nodes
	 *
	 */
	var __row_selector = function ( settings, selector, opts )
	{
		var rows;
		var run = function ( sel ) {
			var selInt = _intVal( sel );
			var i, ien;
			var aoData = settings.aoData;
	
			// Short cut - selector is a number and no options provided (default is
			// all records, so no need to check if the index is in there, since it
			// must be - dev error if the index doesn't exist).
			if ( selInt !== null && ! opts ) {
				return [ selInt ];
			}
	
			if ( ! rows ) {
				rows = _selector_row_indexes( settings, opts );
			}
	
			if ( selInt !== null && $.inArray( selInt, rows ) !== -1 ) {
				// Selector - integer
				return [ selInt ];
			}
			else if ( sel === null || sel === undefined || sel === '' ) {
				// Selector - none
				return rows;
			}
	
			// Selector - function
			if ( typeof sel === 'function' ) {
				return $.map( rows, function (idx) {
					var row = aoData[ idx ];
					return sel( idx, row._aData, row.nTr ) ? idx : null;
				} );
			}
	
			// Selector - node
			if ( sel.nodeName ) {
				var rowIdx = sel._DT_RowIndex;  // Property added by DT for fast lookup
				var cellIdx = sel._DT_CellIndex;
	
				if ( rowIdx !== undefined ) {
					// Make sure that the row is actually still present in the table
					return aoData[ rowIdx ] && aoData[ rowIdx ].nTr === sel ?
						[ rowIdx ] :
						[];
				}
				else if ( cellIdx ) {
					return aoData[ cellIdx.row ] && aoData[ cellIdx.row ].nTr === sel.parentNode ?
						[ cellIdx.row ] :
						[];
				}
				else {
					var host = $(sel).closest('*[data-dt-row]');
					return host.length ?
						[ host.data('dt-row') ] :
						[];
				}
			}
	
			// ID selector. Want to always be able to select rows by id, regardless
			// of if the tr element has been created or not, so can't rely upon
			// jQuery here - hence a custom implementation. This does not match
			// Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,
			// but to select it using a CSS selector engine (like Sizzle or
			// querySelect) it would need to need to be escaped for some characters.
			// DataTables simplifies this for row selectors since you can select
			// only a row. A # indicates an id any anything that follows is the id -
			// unescaped.
			if ( typeof sel === 'string' && sel.charAt(0) === '#' ) {
				// get row index from id
				var rowObj = settings.aIds[ sel.replace( /^#/, '' ) ];
				if ( rowObj !== undefined ) {
					return [ rowObj.idx ];
				}
	
				// need to fall through to jQuery in case there is DOM id that
				// matches
			}
			
			// Get nodes in the order from the `rows` array with null values removed
			var nodes = _removeEmpty(
				_pluck_order( settings.aoData, rows, 'nTr' )
			);
	
			// Selector - jQuery selector string, array of nodes or jQuery object/
			// As jQuery's .filter() allows jQuery objects to be passed in filter,
			// it also allows arrays, so this will cope with all three options
			return $(nodes)
				.filter( sel )
				.map( function () {
					return this._DT_RowIndex;
				} )
				.toArray();
		};
	
		return _selector_run( 'row', selector, run, settings, opts );
	};
	
	
	_api_register( 'rows()', function ( selector, opts ) {
		// argument shifting
		if ( selector === undefined ) {
			selector = '';
		}
		else if ( $.isPlainObject( selector ) ) {
			opts = selector;
			selector = '';
		}
	
		opts = _selector_opts( opts );
	
		var inst = this.iterator( 'table', function ( settings ) {
			return __row_selector( settings, selector, opts );
		}, 1 );
	
		// Want argument shifting here and in __row_selector?
		inst.selector.rows = selector;
		inst.selector.opts = opts;
	
		return inst;
	} );
	
	_api_register( 'rows().nodes()', function () {
		return this.iterator( 'row', function ( settings, row ) {
			return settings.aoData[ row ].nTr || undefined;
		}, 1 );
	} );
	
	_api_register( 'rows().data()', function () {
		return this.iterator( true, 'rows', function ( settings, rows ) {
			return _pluck_order( settings.aoData, rows, '_aData' );
		}, 1 );
	} );
	
	_api_registerPlural( 'rows().cache()', 'row().cache()', function ( type ) {
		return this.iterator( 'row', function ( settings, row ) {
			var r = settings.aoData[ row ];
			return type === 'search' ? r._aFilterData : r._aSortData;
		}, 1 );
	} );
	
	_api_registerPlural( 'rows().invalidate()', 'row().invalidate()', function ( src ) {
		return this.iterator( 'row', function ( settings, row ) {
			_fnInvalidate( settings, row, src );
		} );
	} );
	
	_api_registerPlural( 'rows().indexes()', 'row().index()', function () {
		return this.iterator( 'row', function ( settings, row ) {
			return row;
		}, 1 );
	} );
	
	_api_registerPlural( 'rows().ids()', 'row().id()', function ( hash ) {
		var a = [];
		var context = this.context;
	
		// `iterator` will drop undefined values, but in this case we want them
		for ( var i=0, ien=context.length ; i<ien ; i++ ) {
			for ( var j=0, jen=this[i].length ; j<jen ; j++ ) {
				var id = context[i].rowIdFn( context[i].aoData[ this[i][j] ]._aData );
				a.push( (hash === true ? '#' : '' )+ id );
			}
		}
	
		return new _Api( context, a );
	} );
	
	_api_registerPlural( 'rows().remove()', 'row().remove()', function () {
		var that = this;
	
		this.iterator( 'row', function ( settings, row, thatIdx ) {
			var data = settings.aoData;
			var rowData = data[ row ];
			var i, ien, j, jen;
			var loopRow, loopCells;
	
			data.splice( row, 1 );
	
			// Update the cached indexes
			for ( i=0, ien=data.length ; i<ien ; i++ ) {
				loopRow = data[i];
				loopCells = loopRow.anCells;
	
				// Rows
				if ( loopRow.nTr !== null ) {
					loopRow.nTr._DT_RowIndex = i;
				}
	
				// Cells
				if ( loopCells !== null ) {
					for ( j=0, jen=loopCells.length ; j<jen ; j++ ) {
						loopCells[j]._DT_CellIndex.row = i;
					}
				}
			}
	
			// Delete from the display arrays
			_fnDeleteIndex( settings.aiDisplayMaster, row );
			_fnDeleteIndex( settings.aiDisplay, row );
			_fnDeleteIndex( that[ thatIdx ], row, false ); // maintain local indexes
	
			// For server-side processing tables - subtract the deleted row from the count
			if ( settings._iRecordsDisplay > 0 ) {
				settings._iRecordsDisplay--;
			}
	
			// Check for an 'overflow' they case for displaying the table
			_fnLengthOverflow( settings );
	
			// Remove the row's ID reference if there is one
			var id = settings.rowIdFn( rowData._aData );
			if ( id !== undefined ) {
				delete settings.aIds[ id ];
			}
		} );
	
		this.iterator( 'table', function ( settings ) {
			for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
				settings.aoData[i].idx = i;
			}
		} );
	
		return this;
	} );
	
	
	_api_register( 'rows.add()', function ( rows ) {
		var newRows = this.iterator( 'table', function ( settings ) {
				var row, i, ien;
				var out = [];
	
				for ( i=0, ien=rows.length ; i<ien ; i++ ) {
					row = rows[i];
	
					if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
						out.push( _fnAddTr( settings, row )[0] );
					}
					else {
						out.push( _fnAddData( settings, row ) );
					}
				}
	
				return out;
			}, 1 );
	
		// Return an Api.rows() extended instance, so rows().nodes() etc can be used
		var modRows = this.rows( -1 );
		modRows.pop();
		$.merge( modRows, newRows );
	
		return modRows;
	} );
	
	
	
	
	
	/**
	 *
	 */
	_api_register( 'row()', function ( selector, opts ) {
		return _selector_first( this.rows( selector, opts ) );
	} );
	
	
	_api_register( 'row().data()', function ( data ) {
		var ctx = this.context;
	
		if ( data === undefined ) {
			// Get
			return ctx.length && this.length ?
				ctx[0].aoData[ this[0] ]._aData :
				undefined;
		}
	
		// Set
		var row = ctx[0].aoData[ this[0] ];
		row._aData = data;
	
		// If the DOM has an id, and the data source is an array
		if ( Array.isArray( data ) && row.nTr && row.nTr.id ) {
			_fnSetObjectDataFn( ctx[0].rowId )( data, row.nTr.id );
		}
	
		// Automatically invalidate
		_fnInvalidate( ctx[0], this[0], 'data' );
	
		return this;
	} );
	
	
	_api_register( 'row().node()', function () {
		var ctx = this.context;
	
		return ctx.length && this.length ?
			ctx[0].aoData[ this[0] ].nTr || null :
			null;
	} );
	
	
	_api_register( 'row.add()', function ( row ) {
		// Allow a jQuery object to be passed in - only a single row is added from
		// it though - the first element in the set
		if ( row instanceof $ && row.length ) {
			row = row[0];
		}
	
		var rows = this.iterator( 'table', function ( settings ) {
			if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
				return _fnAddTr( settings, row )[0];
			}
			return _fnAddData( settings, row );
		} );
	
		// Return an Api.rows() extended instance, with the newly added row selected
		return this.row( rows[0] );
	} );
	
	
	$(document).on('plugin-init.dt', function (e, context) {
		var api = new _Api( context );
		var namespace = 'on-plugin-init';
		var stateSaveParamsEvent = 'stateSaveParams.' + namespace;
		var destroyEvent = 'destroy. ' + namespace;
	
		api.on( stateSaveParamsEvent, function ( e, settings, d ) {
			// This could be more compact with the API, but it is a lot faster as a simple
			// internal loop
			var idFn = settings.rowIdFn;
			var data = settings.aoData;
			var ids = [];
	
			for (var i=0 ; i<data.length ; i++) {
				if (data[i]._detailsShow) {
					ids.push( '#' + idFn(data[i]._aData) );
				}
			}
	
			d.childRows = ids;
		});
	
		api.on( destroyEvent, function () {
			api.off(stateSaveParamsEvent + ' ' + destroyEvent);
		});
	
		var loaded = api.state.loaded();
	
		if ( loaded && loaded.childRows ) {
			api
				.rows( $.map(loaded.childRows, function (id){
					return id.replace(/:/g, '\\:')
				}) )
				.every( function () {
					_fnCallbackFire( context, null, 'requestChild', [ this ] )
				});
		}
	});
	
	var __details_add = function ( ctx, row, data, klass )
	{
		// Convert to array of TR elements
		var rows = [];
		var addRow = function ( r, k ) {
			// Recursion to allow for arrays of jQuery objects
			if ( Array.isArray( r ) || r instanceof $ ) {
				for ( var i=0, ien=r.length ; i<ien ; i++ ) {
					addRow( r[i], k );
				}
				return;
			}
	
			// If we get a TR element, then just add it directly - up to the dev
			// to add the correct number of columns etc
			if ( r.nodeName && r.nodeName.toLowerCase() === 'tr' ) {
				rows.push( r );
			}
			else {
				// Otherwise create a row with a wrapper
				var created = $('<tr><td></td></tr>').addClass( k );
				$('td', created)
					.addClass( k )
					.html( r )
					[0].colSpan = _fnVisbleColumns( ctx );
	
				rows.push( created[0] );
			}
		};
	
		addRow( data, klass );
	
		if ( row._details ) {
			row._details.detach();
		}
	
		row._details = $(rows);
	
		// If the children were already shown, that state should be retained
		if ( row._detailsShow ) {
			row._details.insertAfter( row.nTr );
		}
	};
	
	
	// Make state saving of child row details async to allow them to be batch processed
	var __details_state = DataTable.util.throttle(
		function (ctx) {
			_fnSaveState( ctx[0] )
		},
		500
	);
	
	
	var __details_remove = function ( api, idx )
	{
		var ctx = api.context;
	
		if ( ctx.length ) {
			var row = ctx[0].aoData[ idx !== undefined ? idx : api[0] ];
	
			if ( row && row._details ) {
				row._details.remove();
	
				row._detailsShow = undefined;
				row._details = undefined;
				$( row.nTr ).removeClass( 'dt-hasChild' );
				__details_state( ctx );
			}
		}
	};
	
	
	var __details_display = function ( api, show ) {
		var ctx = api.context;
	
		if ( ctx.length && api.length ) {
			var row = ctx[0].aoData[ api[0] ];
	
			if ( row._details ) {
				row._detailsShow = show;
	
				if ( show ) {
					row._details.insertAfter( row.nTr );
					$( row.nTr ).addClass( 'dt-hasChild' );
				}
				else {
					row._details.detach();
					$( row.nTr ).removeClass( 'dt-hasChild' );
				}
	
				_fnCallbackFire( ctx[0], null, 'childRow', [ show, api.row( api[0] ) ] )
	
				__details_events( ctx[0] );
				__details_state( ctx );
			}
		}
	};
	
	
	var __details_events = function ( settings )
	{
		var api = new _Api( settings );
		var namespace = '.dt.DT_details';
		var drawEvent = 'draw'+namespace;
		var colvisEvent = 'column-sizing'+namespace;
		var destroyEvent = 'destroy'+namespace;
		var data = settings.aoData;
	
		api.off( drawEvent +' '+ colvisEvent +' '+ destroyEvent );
	
		if ( _pluck( data, '_details' ).length > 0 ) {
			// On each draw, insert the required elements into the document
			api.on( drawEvent, function ( e, ctx ) {
				if ( settings !== ctx ) {
					return;
				}
	
				api.rows( {page:'current'} ).eq(0).each( function (idx) {
					// Internal data grab
					var row = data[ idx ];
	
					if ( row._detailsShow ) {
						row._details.insertAfter( row.nTr );
					}
				} );
			} );
	
			// Column visibility change - update the colspan
			api.on( colvisEvent, function ( e, ctx, idx, vis ) {
				if ( settings !== ctx ) {
					return;
				}
	
				// Update the colspan for the details rows (note, only if it already has
				// a colspan)
				var row, visible = _fnVisbleColumns( ctx );
	
				for ( var i=0, ien=data.length ; i<ien ; i++ ) {
					row = data[i];
	
					if ( row._details ) {
						row._details.children('td[colspan]').attr('colspan', visible );
					}
				}
			} );
	
			// Table destroyed - nuke any child rows
			api.on( destroyEvent, function ( e, ctx ) {
				if ( settings !== ctx ) {
					return;
				}
	
				for ( var i=0, ien=data.length ; i<ien ; i++ ) {
					if ( data[i]._details ) {
						__details_remove( api, i );
					}
				}
			} );
		}
	};
	
	// Strings for the method names to help minification
	var _emp = '';
	var _child_obj = _emp+'row().child';
	var _child_mth = _child_obj+'()';
	
	// data can be:
	//  tr
	//  string
	//  jQuery or array of any of the above
	_api_register( _child_mth, function ( data, klass ) {
		var ctx = this.context;
	
		if ( data === undefined ) {
			// get
			return ctx.length && this.length ?
				ctx[0].aoData[ this[0] ]._details :
				undefined;
		}
		else if ( data === true ) {
			// show
			this.child.show();
		}
		else if ( data === false ) {
			// remove
			__details_remove( this );
		}
		else if ( ctx.length && this.length ) {
			// set
			__details_add( ctx[0], ctx[0].aoData[ this[0] ], data, klass );
		}
	
		return this;
	} );
	
	
	_api_register( [
		_child_obj+'.show()',
		_child_mth+'.show()' // only when `child()` was called with parameters (without
	], function ( show ) {   // it returns an object and this method is not executed)
		__details_display( this, true );
		return this;
	} );
	
	
	_api_register( [
		_child_obj+'.hide()',
		_child_mth+'.hide()' // only when `child()` was called with parameters (without
	], function () {         // it returns an object and this method is not executed)
		__details_display( this, false );
		return this;
	} );
	
	
	_api_register( [
		_child_obj+'.remove()',
		_child_mth+'.remove()' // only when `child()` was called with parameters (without
	], function () {           // it returns an object and this method is not executed)
		__details_remove( this );
		return this;
	} );
	
	
	_api_register( _child_obj+'.isShown()', function () {
		var ctx = this.context;
	
		if ( ctx.length && this.length ) {
			// _detailsShown as false or undefined will fall through to return false
			return ctx[0].aoData[ this[0] ]._detailsShow || false;
		}
		return false;
	} );
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Columns
	 *
	 * {integer}           - column index (>=0 count from left, <0 count from right)
	 * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
	 * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
	 * "{string}:name"     - column name
	 * "{string}"          - jQuery selector on column header nodes
	 *
	 */
	
	// can be an array of these items, comma separated list, or an array of comma
	// separated lists
	
	var __re_column_selector = /^([^:]+):(name|visIdx|visible)$/;
	
	
	// r1 and r2 are redundant - but it means that the parameters match for the
	// iterator callback in columns().data()
	var __columnData = function ( settings, column, r1, r2, rows ) {
		var a = [];
		for ( var row=0, ien=rows.length ; row<ien ; row++ ) {
			a.push( _fnGetCellData( settings, rows[row], column ) );
		}
		return a;
	};
	
	
	var __column_selector = function ( settings, selector, opts )
	{
		var
			columns = settings.aoColumns,
			names = _pluck( columns, 'sName' ),
			nodes = _pluck( columns, 'nTh' );
	
		var run = function ( s ) {
			var selInt = _intVal( s );
	
			// Selector - all
			if ( s === '' ) {
				return _range( columns.length );
			}
	
			// Selector - index
			if ( selInt !== null ) {
				return [ selInt >= 0 ?
					selInt : // Count from left
					columns.length + selInt // Count from right (+ because its a negative value)
				];
			}
	
			// Selector = function
			if ( typeof s === 'function' ) {
				var rows = _selector_row_indexes( settings, opts );
	
				return $.map( columns, function (col, idx) {
					return s(
							idx,
							__columnData( settings, idx, 0, 0, rows ),
							nodes[ idx ]
						) ? idx : null;
				} );
			}
	
			// jQuery or string selector
			var match = typeof s === 'string' ?
				s.match( __re_column_selector ) :
				'';
	
			if ( match ) {
				switch( match[2] ) {
					case 'visIdx':
					case 'visible':
						var idx = parseInt( match[1], 10 );
						// Visible index given, convert to column index
						if ( idx < 0 ) {
							// Counting from the right
							var visColumns = $.map( columns, function (col,i) {
								return col.bVisible ? i : null;
							} );
							return [ visColumns[ visColumns.length + idx ] ];
						}
						// Counting from the left
						return [ _fnVisibleToColumnIndex( settings, idx ) ];
	
					case 'name':
						// match by name. `names` is column index complete and in order
						return $.map( names, function (name, i) {
							return name === match[1] ? i : null;
						} );
	
					default:
						return [];
				}
			}
	
			// Cell in the table body
			if ( s.nodeName && s._DT_CellIndex ) {
				return [ s._DT_CellIndex.column ];
			}
	
			// jQuery selector on the TH elements for the columns
			var jqResult = $( nodes )
				.filter( s )
				.map( function () {
					return $.inArray( this, nodes ); // `nodes` is column index complete and in order
				} )
				.toArray();
	
			if ( jqResult.length || ! s.nodeName ) {
				return jqResult;
			}
	
			// Otherwise a node which might have a `dt-column` data attribute, or be
			// a child or such an element
			var host = $(s).closest('*[data-dt-column]');
			return host.length ?
				[ host.data('dt-column') ] :
				[];
		};
	
		return _selector_run( 'column', selector, run, settings, opts );
	};
	
	
	var __setColumnVis = function ( settings, column, vis ) {
		var
			cols = settings.aoColumns,
			col  = cols[ column ],
			data = settings.aoData,
			row, cells, i, ien, tr;
	
		// Get
		if ( vis === undefined ) {
			return col.bVisible;
		}
	
		// Set
		// No change
		if ( col.bVisible === vis ) {
			return;
		}
	
		if ( vis ) {
			// Insert column
			// Need to decide if we should use appendChild or insertBefore
			var insertBefore = $.inArray( true, _pluck(cols, 'bVisible'), column+1 );
	
			for ( i=0, ien=data.length ; i<ien ; i++ ) {
				tr = data[i].nTr;
				cells = data[i].anCells;
	
				if ( tr ) {
					// insertBefore can act like appendChild if 2nd arg is null
					tr.insertBefore( cells[ column ], cells[ insertBefore ] || null );
				}
			}
		}
		else {
			// Remove column
			$( _pluck( settings.aoData, 'anCells', column ) ).detach();
		}
	
		// Common actions
		col.bVisible = vis;
	};
	
	
	_api_register( 'columns()', function ( selector, opts ) {
		// argument shifting
		if ( selector === undefined ) {
			selector = '';
		}
		else if ( $.isPlainObject( selector ) ) {
			opts = selector;
			selector = '';
		}
	
		opts = _selector_opts( opts );
	
		var inst = this.iterator( 'table', function ( settings ) {
			return __column_selector( settings, selector, opts );
		}, 1 );
	
		// Want argument shifting here and in _row_selector?
		inst.selector.cols = selector;
		inst.selector.opts = opts;
	
		return inst;
	} );
	
	_api_registerPlural( 'columns().header()', 'column().header()', function ( selector, opts ) {
		return this.iterator( 'column', function ( settings, column ) {
			return settings.aoColumns[column].nTh;
		}, 1 );
	} );
	
	_api_registerPlural( 'columns().footer()', 'column().footer()', function ( selector, opts ) {
		return this.iterator( 'column', function ( settings, column ) {
			return settings.aoColumns[column].nTf;
		}, 1 );
	} );
	
	_api_registerPlural( 'columns().data()', 'column().data()', function () {
		return this.iterator( 'column-rows', __columnData, 1 );
	} );
	
	_api_registerPlural( 'columns().dataSrc()', 'column().dataSrc()', function () {
		return this.iterator( 'column', function ( settings, column ) {
			return settings.aoColumns[column].mData;
		}, 1 );
	} );
	
	_api_registerPlural( 'columns().cache()', 'column().cache()', function ( type ) {
		return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
			return _pluck_order( settings.aoData, rows,
				type === 'search' ? '_aFilterData' : '_aSortData', column
			);
		}, 1 );
	} );
	
	_api_registerPlural( 'columns().nodes()', 'column().nodes()', function () {
		return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
			return _pluck_order( settings.aoData, rows, 'anCells', column ) ;
		}, 1 );
	} );
	
	_api_registerPlural( 'columns().visible()', 'column().visible()', function ( vis, calc ) {
		var that = this;
		var ret = this.iterator( 'column', function ( settings, column ) {
			if ( vis === undefined ) {
				return settings.aoColumns[ column ].bVisible;
			} // else
			__setColumnVis( settings, column, vis );
		} );
	
		// Group the column visibility changes
		if ( vis !== undefined ) {
			this.iterator( 'table', function ( settings ) {
				// Redraw the header after changes
				_fnDrawHead( settings, settings.aoHeader );
				_fnDrawHead( settings, settings.aoFooter );
		
				// Update colspan for no records display. Child rows and extensions will use their own
				// listeners to do this - only need to update the empty table item here
				if ( ! settings.aiDisplay.length ) {
					$(settings.nTBody).find('td[colspan]').attr('colspan', _fnVisbleColumns(settings));
				}
		
				_fnSaveState( settings );
	
				// Second loop once the first is done for events
				that.iterator( 'column', function ( settings, column ) {
					_fnCallbackFire( settings, null, 'column-visibility', [settings, column, vis, calc] );
				} );
	
				if ( calc === undefined || calc ) {
					that.columns.adjust();
				}
			});
		}
	
		return ret;
	} );
	
	_api_registerPlural( 'columns().indexes()', 'column().index()', function ( type ) {
		return this.iterator( 'column', function ( settings, column ) {
			return type === 'visible' ?
				_fnColumnIndexToVisible( settings, column ) :
				column;
		}, 1 );
	} );
	
	_api_register( 'columns.adjust()', function () {
		return this.iterator( 'table', function ( settings ) {
			_fnAdjustColumnSizing( settings );
		}, 1 );
	} );
	
	_api_register( 'column.index()', function ( type, idx ) {
		if ( this.context.length !== 0 ) {
			var ctx = this.context[0];
	
			if ( type === 'fromVisible' || type === 'toData' ) {
				return _fnVisibleToColumnIndex( ctx, idx );
			}
			else if ( type === 'fromData' || type === 'toVisible' ) {
				return _fnColumnIndexToVisible( ctx, idx );
			}
		}
	} );
	
	_api_register( 'column()', function ( selector, opts ) {
		return _selector_first( this.columns( selector, opts ) );
	} );
	
	var __cell_selector = function ( settings, selector, opts )
	{
		var data = settings.aoData;
		var rows = _selector_row_indexes( settings, opts );
		var cells = _removeEmpty( _pluck_order( data, rows, 'anCells' ) );
		var allCells = $(_flatten( [], cells ));
		var row;
		var columns = settings.aoColumns.length;
		var a, i, ien, j, o, host;
	
		var run = function ( s ) {
			var fnSelector = typeof s === 'function';
	
			if ( s === null || s === undefined || fnSelector ) {
				// All cells and function selectors
				a = [];
	
				for ( i=0, ien=rows.length ; i<ien ; i++ ) {
					row = rows[i];
	
					for ( j=0 ; j<columns ; j++ ) {
						o = {
							row: row,
							column: j
						};
	
						if ( fnSelector ) {
							// Selector - function
							host = data[ row ];
	
							if ( s( o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null ) ) {
								a.push( o );
							}
						}
						else {
							// Selector - all
							a.push( o );
						}
					}
				}
	
				return a;
			}
			
			// Selector - index
			if ( $.isPlainObject( s ) ) {
				// Valid cell index and its in the array of selectable rows
				return s.column !== undefined && s.row !== undefined && $.inArray( s.row, rows ) !== -1 ?
					[s] :
					[];
			}
	
			// Selector - jQuery filtered cells
			var jqResult = allCells
				.filter( s )
				.map( function (i, el) {
					return { // use a new object, in case someone changes the values
						row:    el._DT_CellIndex.row,
						column: el._DT_CellIndex.column
	 				};
				} )
				.toArray();
	
			if ( jqResult.length || ! s.nodeName ) {
				return jqResult;
			}
	
			// Otherwise the selector is a node, and there is one last option - the
			// element might be a child of an element which has dt-row and dt-column
			// data attributes
			host = $(s).closest('*[data-dt-row]');
			return host.length ?
				[ {
					row: host.data('dt-row'),
					column: host.data('dt-column')
				} ] :
				[];
		};
	
		return _selector_run( 'cell', selector, run, settings, opts );
	};
	
	
	
	
	_api_register( 'cells()', function ( rowSelector, columnSelector, opts ) {
		// Argument shifting
		if ( $.isPlainObject( rowSelector ) ) {
			// Indexes
			if ( rowSelector.row === undefined ) {
				// Selector options in first parameter
				opts = rowSelector;
				rowSelector = null;
			}
			else {
				// Cell index objects in first parameter
				opts = columnSelector;
				columnSelector = null;
			}
		}
		if ( $.isPlainObject( columnSelector ) ) {
			opts = columnSelector;
			columnSelector = null;
		}
	
		// Cell selector
		if ( columnSelector === null || columnSelector === undefined ) {
			return this.iterator( 'table', function ( settings ) {
				return __cell_selector( settings, rowSelector, _selector_opts( opts ) );
			} );
		}
	
		// The default built in options need to apply to row and columns
		var internalOpts = opts ? {
			page: opts.page,
			order: opts.order,
			search: opts.search
		} : {};
	
		// Row + column selector
		var columns = this.columns( columnSelector, internalOpts );
		var rows = this.rows( rowSelector, internalOpts );
		var i, ien, j, jen;
	
		var cellsNoOpts = this.iterator( 'table', function ( settings, idx ) {
			var a = [];
	
			for ( i=0, ien=rows[idx].length ; i<ien ; i++ ) {
				for ( j=0, jen=columns[idx].length ; j<jen ; j++ ) {
					a.push( {
						row:    rows[idx][i],
						column: columns[idx][j]
					} );
				}
			}
	
			return a;
		}, 1 );
	
		// There is currently only one extension which uses a cell selector extension
		// It is a _major_ performance drag to run this if it isn't needed, so this is
		// an extension specific check at the moment
		var cells = opts && opts.selected ?
			this.cells( cellsNoOpts, opts ) :
			cellsNoOpts;
	
		$.extend( cells.selector, {
			cols: columnSelector,
			rows: rowSelector,
			opts: opts
		} );
	
		return cells;
	} );
	
	
	_api_registerPlural( 'cells().nodes()', 'cell().node()', function () {
		return this.iterator( 'cell', function ( settings, row, column ) {
			var data = settings.aoData[ row ];
	
			return data && data.anCells ?
				data.anCells[ column ] :
				undefined;
		}, 1 );
	} );
	
	
	_api_register( 'cells().data()', function () {
		return this.iterator( 'cell', function ( settings, row, column ) {
			return _fnGetCellData( settings, row, column );
		}, 1 );
	} );
	
	
	_api_registerPlural( 'cells().cache()', 'cell().cache()', function ( type ) {
		type = type === 'search' ? '_aFilterData' : '_aSortData';
	
		return this.iterator( 'cell', function ( settings, row, column ) {
			return settings.aoData[ row ][ type ][ column ];
		}, 1 );
	} );
	
	
	_api_registerPlural( 'cells().render()', 'cell().render()', function ( type ) {
		return this.iterator( 'cell', function ( settings, row, column ) {
			return _fnGetCellData( settings, row, column, type );
		}, 1 );
	} );
	
	
	_api_registerPlural( 'cells().indexes()', 'cell().index()', function () {
		return this.iterator( 'cell', function ( settings, row, column ) {
			return {
				row: row,
				column: column,
				columnVisible: _fnColumnIndexToVisible( settings, column )
			};
		}, 1 );
	} );
	
	
	_api_registerPlural( 'cells().invalidate()', 'cell().invalidate()', function ( src ) {
		return this.iterator( 'cell', function ( settings, row, column ) {
			_fnInvalidate( settings, row, src, column );
		} );
	} );
	
	
	
	_api_register( 'cell()', function ( rowSelector, columnSelector, opts ) {
		return _selector_first( this.cells( rowSelector, columnSelector, opts ) );
	} );
	
	
	_api_register( 'cell().data()', function ( data ) {
		var ctx = this.context;
		var cell = this[0];
	
		if ( data === undefined ) {
			// Get
			return ctx.length && cell.length ?
				_fnGetCellData( ctx[0], cell[0].row, cell[0].column ) :
				undefined;
		}
	
		// Set
		_fnSetCellData( ctx[0], cell[0].row, cell[0].column, data );
		_fnInvalidate( ctx[0], cell[0].row, 'data', cell[0].column );
	
		return this;
	} );
	
	
	
	/**
	 * Get current ordering (sorting) that has been applied to the table.
	 *
	 * @returns {array} 2D array containing the sorting information for the first
	 *   table in the current context. Each element in the parent array represents
	 *   a column being sorted upon (i.e. multi-sorting with two columns would have
	 *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
	 *   the column index that the sorting condition applies to, the second is the
	 *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
	 *   index of the sorting order from the `column.sorting` initialisation array.
	 *//**
	 * Set the ordering for the table.
	 *
	 * @param {integer} order Column index to sort upon.
	 * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
	 * @returns {DataTables.Api} this
	 *//**
	 * Set the ordering for the table.
	 *
	 * @param {array} order 1D array of sorting information to be applied.
	 * @param {array} [...] Optional additional sorting conditions
	 * @returns {DataTables.Api} this
	 *//**
	 * Set the ordering for the table.
	 *
	 * @param {array} order 2D array of sorting information to be applied.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'order()', function ( order, dir ) {
		var ctx = this.context;
	
		if ( order === undefined ) {
			// get
			return ctx.length !== 0 ?
				ctx[0].aaSorting :
				undefined;
		}
	
		// set
		if ( typeof order === 'number' ) {
			// Simple column / direction passed in
			order = [ [ order, dir ] ];
		}
		else if ( order.length && ! Array.isArray( order[0] ) ) {
			// Arguments passed in (list of 1D arrays)
			order = Array.prototype.slice.call( arguments );
		}
		// otherwise a 2D array was passed in
	
		return this.iterator( 'table', function ( settings ) {
			settings.aaSorting = order.slice();
		} );
	} );
	
	
	/**
	 * Attach a sort listener to an element for a given column
	 *
	 * @param {node|jQuery|string} node Identifier for the element(s) to attach the
	 *   listener to. This can take the form of a single DOM node, a jQuery
	 *   collection of nodes or a jQuery selector which will identify the node(s).
	 * @param {integer} column the column that a click on this node will sort on
	 * @param {function} [callback] callback function when sort is run
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'order.listener()', function ( node, column, callback ) {
		return this.iterator( 'table', function ( settings ) {
			_fnSortAttachListener( settings, node, column, callback );
		} );
	} );
	
	
	_api_register( 'order.fixed()', function ( set ) {
		if ( ! set ) {
			var ctx = this.context;
			var fixed = ctx.length ?
				ctx[0].aaSortingFixed :
				undefined;
	
			return Array.isArray( fixed ) ?
				{ pre: fixed } :
				fixed;
		}
	
		return this.iterator( 'table', function ( settings ) {
			settings.aaSortingFixed = $.extend( true, {}, set );
		} );
	} );
	
	
	// Order by the selected column(s)
	_api_register( [
		'columns().order()',
		'column().order()'
	], function ( dir ) {
		var that = this;
	
		return this.iterator( 'table', function ( settings, i ) {
			var sort = [];
	
			$.each( that[i], function (j, col) {
				sort.push( [ col, dir ] );
			} );
	
			settings.aaSorting = sort;
		} );
	} );
	
	
	
	_api_register( 'search()', function ( input, regex, smart, caseInsen ) {
		var ctx = this.context;
	
		if ( input === undefined ) {
			// get
			return ctx.length !== 0 ?
				ctx[0].oPreviousSearch.sSearch :
				undefined;
		}
	
		// set
		return this.iterator( 'table', function ( settings ) {
			if ( ! settings.oFeatures.bFilter ) {
				return;
			}
	
			_fnFilterComplete( settings, $.extend( {}, settings.oPreviousSearch, {
				"sSearch": input+"",
				"bRegex":  regex === null ? false : regex,
				"bSmart":  smart === null ? true  : smart,
				"bCaseInsensitive": caseInsen === null ? true : caseInsen
			} ), 1 );
		} );
	} );
	
	
	_api_registerPlural(
		'columns().search()',
		'column().search()',
		function ( input, regex, smart, caseInsen ) {
			return this.iterator( 'column', function ( settings, column ) {
				var preSearch = settings.aoPreSearchCols;
	
				if ( input === undefined ) {
					// get
					return preSearch[ column ].sSearch;
				}
	
				// set
				if ( ! settings.oFeatures.bFilter ) {
					return;
				}
	
				$.extend( preSearch[ column ], {
					"sSearch": input+"",
					"bRegex":  regex === null ? false : regex,
					"bSmart":  smart === null ? true  : smart,
					"bCaseInsensitive": caseInsen === null ? true : caseInsen
				} );
	
				_fnFilterComplete( settings, settings.oPreviousSearch, 1 );
			} );
		}
	);
	
	/*
	 * State API methods
	 */
	
	_api_register( 'state()', function () {
		return this.context.length ?
			this.context[0].oSavedState :
			null;
	} );
	
	
	_api_register( 'state.clear()', function () {
		return this.iterator( 'table', function ( settings ) {
			// Save an empty object
			settings.fnStateSaveCallback.call( settings.oInstance, settings, {} );
		} );
	} );
	
	
	_api_register( 'state.loaded()', function () {
		return this.context.length ?
			this.context[0].oLoadedState :
			null;
	} );
	
	
	_api_register( 'state.save()', function () {
		return this.iterator( 'table', function ( settings ) {
			_fnSaveState( settings );
		} );
	} );
	
	
	
	/**
	 * Set the jQuery or window object to be used by DataTables
	 *
	 * @param {*} module Library / container object
	 * @param {string} type Library or container type `lib` or `win`.
	 */
	DataTable.use = function (module, type) {
		if (type === 'lib' || module.fn) {
			$ = module;
		}
		else if (type == 'win' || module.document) {
			window = module;
			document = module.document;
		}
	}
	
	/**
	 * CommonJS factory function pass through. This will check if the arguments
	 * given are a window object or a jQuery object. If so they are set
	 * accordingly.
	 * @param {*} root Window
	 * @param {*} jq jQUery
	 * @returns {boolean} Indicator
	 */
	DataTable.factory = function (root, jq) {
		var is = false;
	
		// Test if the first parameter is a window object
		if (root && root.document) {
			window = root;
			document = root.document;
		}
	
		// Test if the second parameter is a jQuery object
		if (jq && jq.fn && jq.fn.jquery) {
			$ = jq;
			is = true;
		}
	
		return is;
	}
	
	/**
	 * Provide a common method for plug-ins to check the version of DataTables being
	 * used, in order to ensure compatibility.
	 *
	 *  @param {string} version Version string to check for, in the format "X.Y.Z".
	 *    Note that the formats "X" and "X.Y" are also acceptable.
	 *  @returns {boolean} true if this version of DataTables is greater or equal to
	 *    the required version, or false if this version of DataTales is not
	 *    suitable
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
	 */
	DataTable.versionCheck = DataTable.fnVersionCheck = function( version )
	{
		var aThis = DataTable.version.split('.');
		var aThat = version.split('.');
		var iThis, iThat;
	
		for ( var i=0, iLen=aThat.length ; i<iLen ; i++ ) {
			iThis = parseInt( aThis[i], 10 ) || 0;
			iThat = parseInt( aThat[i], 10 ) || 0;
	
			// Parts are the same, keep comparing
			if (iThis === iThat) {
				continue;
			}
	
			// Parts are different, return immediately
			return iThis > iThat;
		}
	
		return true;
	};
	
	
	/**
	 * Check if a `<table>` node is a DataTable table already or not.
	 *
	 *  @param {node|jquery|string} table Table node, jQuery object or jQuery
	 *      selector for the table to test. Note that if more than more than one
	 *      table is passed on, only the first will be checked
	 *  @returns {boolean} true the table given is a DataTable, or false otherwise
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
	 *      $('#example').dataTable();
	 *    }
	 */
	DataTable.isDataTable = DataTable.fnIsDataTable = function ( table )
	{
		var t = $(table).get(0);
		var is = false;
	
		if ( table instanceof DataTable.Api ) {
			return true;
		}
	
		$.each( DataTable.settings, function (i, o) {
			var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
			var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;
	
			if ( o.nTable === t || head === t || foot === t ) {
				is = true;
			}
		} );
	
		return is;
	};
	
	
	/**
	 * Get all DataTable tables that have been initialised - optionally you can
	 * select to get only currently visible tables.
	 *
	 *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
	 *    or visible tables only.
	 *  @returns {array} Array of `table` nodes (not DataTable instances) which are
	 *    DataTables
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    $.each( $.fn.dataTable.tables(true), function () {
	 *      $(table).DataTable().columns.adjust();
	 *    } );
	 */
	DataTable.tables = DataTable.fnTables = function ( visible )
	{
		var api = false;
	
		if ( $.isPlainObject( visible ) ) {
			api = visible.api;
			visible = visible.visible;
		}
	
		var a = $.map( DataTable.settings, function (o) {
			if ( !visible || (visible && $(o.nTable).is(':visible')) ) {
				return o.nTable;
			}
		} );
	
		return api ?
			new _Api( a ) :
			a;
	};
	
	
	/**
	 * Convert from camel case parameters to Hungarian notation. This is made public
	 * for the extensions to provide the same ability as DataTables core to accept
	 * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
	 * parameters.
	 *
	 *  @param {object} src The model object which holds all parameters that can be
	 *    mapped.
	 *  @param {object} user The object to convert from camel case to Hungarian.
	 *  @param {boolean} force When set to `true`, properties which already have a
	 *    Hungarian value in the `user` object will be overwritten. Otherwise they
	 *    won't be.
	 */
	DataTable.camelToHungarian = _fnCamelToHungarian;
	
	
	
	/**
	 *
	 */
	_api_register( '$()', function ( selector, opts ) {
		var
			rows   = this.rows( opts ).nodes(), // Get all rows
			jqRows = $(rows);
	
		return $( [].concat(
			jqRows.filter( selector ).toArray(),
			jqRows.find( selector ).toArray()
		) );
	} );
	
	
	// jQuery functions to operate on the tables
	$.each( [ 'on', 'one', 'off' ], function (i, key) {
		_api_register( key+'()', function ( /* event, handler */ ) {
			var args = Array.prototype.slice.call(arguments);
	
			// Add the `dt` namespace automatically if it isn't already present
			args[0] = $.map( args[0].split( /\s/ ), function ( e ) {
				return ! e.match(/\.dt\b/) ?
					e+'.dt' :
					e;
				} ).join( ' ' );
	
			var inst = $( this.tables().nodes() );
			inst[key].apply( inst, args );
			return this;
		} );
	} );
	
	
	_api_register( 'clear()', function () {
		return this.iterator( 'table', function ( settings ) {
			_fnClearTable( settings );
		} );
	} );
	
	
	_api_register( 'settings()', function () {
		return new _Api( this.context, this.context );
	} );
	
	
	_api_register( 'init()', function () {
		var ctx = this.context;
		return ctx.length ? ctx[0].oInit : null;
	} );
	
	
	_api_register( 'data()', function () {
		return this.iterator( 'table', function ( settings ) {
			return _pluck( settings.aoData, '_aData' );
		} ).flatten();
	} );
	
	
	_api_register( 'destroy()', function ( remove ) {
		remove = remove || false;
	
		return this.iterator( 'table', function ( settings ) {
			var classes   = settings.oClasses;
			var table     = settings.nTable;
			var tbody     = settings.nTBody;
			var thead     = settings.nTHead;
			var tfoot     = settings.nTFoot;
			var jqTable   = $(table);
			var jqTbody   = $(tbody);
			var jqWrapper = $(settings.nTableWrapper);
			var rows      = $.map( settings.aoData, function (r) { return r.nTr; } );
			var i, ien;
	
			// Flag to note that the table is currently being destroyed - no action
			// should be taken
			settings.bDestroying = true;
	
			// Fire off the destroy callbacks for plug-ins etc
			_fnCallbackFire( settings, "aoDestroyCallback", "destroy", [settings] );
	
			// If not being removed from the document, make all columns visible
			if ( ! remove ) {
				new _Api( settings ).columns().visible( true );
			}
	
			// Blitz all `DT` namespaced events (these are internal events, the
			// lowercase, `dt` events are user subscribed and they are responsible
			// for removing them
			jqWrapper.off('.DT').find(':not(tbody *)').off('.DT');
			$(window).off('.DT-'+settings.sInstance);
	
			// When scrolling we had to break the table up - restore it
			if ( table != thead.parentNode ) {
				jqTable.children('thead').detach();
				jqTable.append( thead );
			}
	
			if ( tfoot && table != tfoot.parentNode ) {
				jqTable.children('tfoot').detach();
				jqTable.append( tfoot );
			}
	
			settings.aaSorting = [];
			settings.aaSortingFixed = [];
			_fnSortingClasses( settings );
	
			$( rows ).removeClass( settings.asStripeClasses.join(' ') );
	
			$('th, td', thead).removeClass( classes.sSortable+' '+
				classes.sSortableAsc+' '+classes.sSortableDesc+' '+classes.sSortableNone
			);
	
			// Add the TR elements back into the table in their original order
			jqTbody.children().detach();
			jqTbody.append( rows );
	
			var orig = settings.nTableWrapper.parentNode;
	
			// Remove the DataTables generated nodes, events and classes
			var removedMethod = remove ? 'remove' : 'detach';
			jqTable[ removedMethod ]();
			jqWrapper[ removedMethod ]();
	
			// If we need to reattach the table to the document
			if ( ! remove && orig ) {
				// insertBefore acts like appendChild if !arg[1]
				orig.insertBefore( table, settings.nTableReinsertBefore );
	
				// Restore the width of the original table - was read from the style property,
				// so we can restore directly to that
				jqTable
					.css( 'width', settings.sDestroyWidth )
					.removeClass( classes.sTable );
	
				// If the were originally stripe classes - then we add them back here.
				// Note this is not fool proof (for example if not all rows had stripe
				// classes - but it's a good effort without getting carried away
				ien = settings.asDestroyStripes.length;
	
				if ( ien ) {
					jqTbody.children().each( function (i) {
						$(this).addClass( settings.asDestroyStripes[i % ien] );
					} );
				}
			}
	
			/* Remove the settings object from the settings array */
			var idx = $.inArray( settings, DataTable.settings );
			if ( idx !== -1 ) {
				DataTable.settings.splice( idx, 1 );
			}
		} );
	} );
	
	
	// Add the `every()` method for rows, columns and cells in a compact form
	$.each( [ 'column', 'row', 'cell' ], function ( i, type ) {
		_api_register( type+'s().every()', function ( fn ) {
			var opts = this.selector.opts;
			var api = this;
	
			return this.iterator( type, function ( settings, arg1, arg2, arg3, arg4 ) {
				// Rows and columns:
				//  arg1 - index
				//  arg2 - table counter
				//  arg3 - loop counter
				//  arg4 - undefined
				// Cells:
				//  arg1 - row index
				//  arg2 - column index
				//  arg3 - table counter
				//  arg4 - loop counter
				fn.call(
					api[ type ](
						arg1,
						type==='cell' ? arg2 : opts,
						type==='cell' ? opts : undefined
					),
					arg1, arg2, arg3, arg4
				);
			} );
		} );
	} );
	
	
	// i18n method for extensions to be able to use the language object from the
	// DataTable
	_api_register( 'i18n()', function ( token, def, plural ) {
		var ctx = this.context[0];
		var resolved = _fnGetObjectDataFn( token )( ctx.oLanguage );
	
		if ( resolved === undefined ) {
			resolved = def;
		}
	
		if ( plural !== undefined && $.isPlainObject( resolved ) ) {
			resolved = resolved[ plural ] !== undefined ?
				resolved[ plural ] :
				resolved._;
		}
	
		return resolved.replace( '%d', plural ); // nb: plural might be undefined,
	} );	
	/**
	 * Version string for plug-ins to check compatibility. Allowed format is
	 * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
	 * only for non-release builds. See http://semver.org/ for more information.
	 *  @member
	 *  @type string
	 *  @default Version number
	 */
	DataTable.version = "1.13.4";
	
	/**
	 * Private data store, containing all of the settings objects that are
	 * created for the tables on a given page.
	 *
	 * Note that the `DataTable.settings` object is aliased to
	 * `jQuery.fn.dataTableExt` through which it may be accessed and
	 * manipulated, or `jQuery.fn.dataTable.settings`.
	 *  @member
	 *  @type array
	 *  @default []
	 *  @private
	 */
	DataTable.settings = [];
	
	/**
	 * Object models container, for the various models that DataTables has
	 * available to it. These models define the objects that are used to hold
	 * the active state and configuration of the table.
	 *  @namespace
	 */
	DataTable.models = {};
	
	
	
	/**
	 * Template object for the way in which DataTables holds information about
	 * search information for the global filter and individual column filters.
	 *  @namespace
	 */
	DataTable.models.oSearch = {
		/**
		 * Flag to indicate if the filtering should be case insensitive or not
		 *  @type boolean
		 *  @default true
		 */
		"bCaseInsensitive": true,
	
		/**
		 * Applied search term
		 *  @type string
		 *  @default <i>Empty string</i>
		 */
		"sSearch": "",
	
		/**
		 * Flag to indicate if the search term should be interpreted as a
		 * regular expression (true) or not (false) and therefore and special
		 * regex characters escaped.
		 *  @type boolean
		 *  @default false
		 */
		"bRegex": false,
	
		/**
		 * Flag to indicate if DataTables is to use its smart filtering or not.
		 *  @type boolean
		 *  @default true
		 */
		"bSmart": true,
	
		/**
		 * Flag to indicate if DataTables should only trigger a search when
		 * the return key is pressed.
		 *  @type boolean
		 *  @default false
		 */
		"return": false
	};
	
	
	
	
	/**
	 * Template object for the way in which DataTables holds information about
	 * each individual row. This is the object format used for the settings
	 * aoData array.
	 *  @namespace
	 */
	DataTable.models.oRow = {
		/**
		 * TR element for the row
		 *  @type node
		 *  @default null
		 */
		"nTr": null,
	
		/**
		 * Array of TD elements for each row. This is null until the row has been
		 * created.
		 *  @type array nodes
		 *  @default []
		 */
		"anCells": null,
	
		/**
		 * Data object from the original data source for the row. This is either
		 * an array if using the traditional form of DataTables, or an object if
		 * using mData options. The exact type will depend on the passed in
		 * data from the data source, or will be an array if using DOM a data
		 * source.
		 *  @type array|object
		 *  @default []
		 */
		"_aData": [],
	
		/**
		 * Sorting data cache - this array is ostensibly the same length as the
		 * number of columns (although each index is generated only as it is
		 * needed), and holds the data that is used for sorting each column in the
		 * row. We do this cache generation at the start of the sort in order that
		 * the formatting of the sort data need be done only once for each cell
		 * per sort. This array should not be read from or written to by anything
		 * other than the master sorting methods.
		 *  @type array
		 *  @default null
		 *  @private
		 */
		"_aSortData": null,
	
		/**
		 * Per cell filtering data cache. As per the sort data cache, used to
		 * increase the performance of the filtering in DataTables
		 *  @type array
		 *  @default null
		 *  @private
		 */
		"_aFilterData": null,
	
		/**
		 * Filtering data cache. This is the same as the cell filtering cache, but
		 * in this case a string rather than an array. This is easily computed with
		 * a join on `_aFilterData`, but is provided as a cache so the join isn't
		 * needed on every search (memory traded for performance)
		 *  @type array
		 *  @default null
		 *  @private
		 */
		"_sFilterRow": null,
	
		/**
		 * Cache of the class name that DataTables has applied to the row, so we
		 * can quickly look at this variable rather than needing to do a DOM check
		 * on className for the nTr property.
		 *  @type string
		 *  @default <i>Empty string</i>
		 *  @private
		 */
		"_sRowStripe": "",
	
		/**
		 * Denote if the original data source was from the DOM, or the data source
		 * object. This is used for invalidating data, so DataTables can
		 * automatically read data from the original source, unless uninstructed
		 * otherwise.
		 *  @type string
		 *  @default null
		 *  @private
		 */
		"src": null,
	
		/**
		 * Index in the aoData array. This saves an indexOf lookup when we have the
		 * object, but want to know the index
		 *  @type integer
		 *  @default -1
		 *  @private
		 */
		"idx": -1
	};
	
	
	/**
	 * Template object for the column information object in DataTables. This object
	 * is held in the settings aoColumns array and contains all the information that
	 * DataTables needs about each individual column.
	 *
	 * Note that this object is related to {@link DataTable.defaults.column}
	 * but this one is the internal data store for DataTables's cache of columns.
	 * It should NOT be manipulated outside of DataTables. Any configuration should
	 * be done through the initialisation options.
	 *  @namespace
	 */
	DataTable.models.oColumn = {
		/**
		 * Column index. This could be worked out on-the-fly with $.inArray, but it
		 * is faster to just hold it as a variable
		 *  @type integer
		 *  @default null
		 */
		"idx": null,
	
		/**
		 * A list of the columns that sorting should occur on when this column
		 * is sorted. That this property is an array allows multi-column sorting
		 * to be defined for a column (for example first name / last name columns
		 * would benefit from this). The values are integers pointing to the
		 * columns to be sorted on (typically it will be a single integer pointing
		 * at itself, but that doesn't need to be the case).
		 *  @type array
		 */
		"aDataSort": null,
	
		/**
		 * Define the sorting directions that are applied to the column, in sequence
		 * as the column is repeatedly sorted upon - i.e. the first value is used
		 * as the sorting direction when the column if first sorted (clicked on).
		 * Sort it again (click again) and it will move on to the next index.
		 * Repeat until loop.
		 *  @type array
		 */
		"asSorting": null,
	
		/**
		 * Flag to indicate if the column is searchable, and thus should be included
		 * in the filtering or not.
		 *  @type boolean
		 */
		"bSearchable": null,
	
		/**
		 * Flag to indicate if the column is sortable or not.
		 *  @type boolean
		 */
		"bSortable": null,
	
		/**
		 * Flag to indicate if the column is currently visible in the table or not
		 *  @type boolean
		 */
		"bVisible": null,
	
		/**
		 * Store for manual type assignment using the `column.type` option. This
		 * is held in store so we can manipulate the column's `sType` property.
		 *  @type string
		 *  @default null
		 *  @private
		 */
		"_sManualType": null,
	
		/**
		 * Flag to indicate if HTML5 data attributes should be used as the data
		 * source for filtering or sorting. True is either are.
		 *  @type boolean
		 *  @default false
		 *  @private
		 */
		"_bAttrSrc": false,
	
		/**
		 * Developer definable function that is called whenever a cell is created (Ajax source,
		 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
		 * allowing you to modify the DOM element (add background colour for example) when the
		 * element is available.
		 *  @type function
		 *  @param {element} nTd The TD node that has been created
		 *  @param {*} sData The Data for the cell
		 *  @param {array|object} oData The data for the whole row
		 *  @param {int} iRow The row index for the aoData data store
		 *  @default null
		 */
		"fnCreatedCell": null,
	
		/**
		 * Function to get data from a cell in a column. You should <b>never</b>
		 * access data directly through _aData internally in DataTables - always use
		 * the method attached to this property. It allows mData to function as
		 * required. This function is automatically assigned by the column
		 * initialisation method
		 *  @type function
		 *  @param {array|object} oData The data array/object for the array
		 *    (i.e. aoData[]._aData)
		 *  @param {string} sSpecific The specific data type you want to get -
		 *    'display', 'type' 'filter' 'sort'
		 *  @returns {*} The data for the cell from the given row's data
		 *  @default null
		 */
		"fnGetData": null,
	
		/**
		 * Function to set data for a cell in the column. You should <b>never</b>
		 * set the data directly to _aData internally in DataTables - always use
		 * this method. It allows mData to function as required. This function
		 * is automatically assigned by the column initialisation method
		 *  @type function
		 *  @param {array|object} oData The data array/object for the array
		 *    (i.e. aoData[]._aData)
		 *  @param {*} sValue Value to set
		 *  @default null
		 */
		"fnSetData": null,
	
		/**
		 * Property to read the value for the cells in the column from the data
		 * source array / object. If null, then the default content is used, if a
		 * function is given then the return from the function is used.
		 *  @type function|int|string|null
		 *  @default null
		 */
		"mData": null,
	
		/**
		 * Partner property to mData which is used (only when defined) to get
		 * the data - i.e. it is basically the same as mData, but without the
		 * 'set' option, and also the data fed to it is the result from mData.
		 * This is the rendering method to match the data method of mData.
		 *  @type function|int|string|null
		 *  @default null
		 */
		"mRender": null,
	
		/**
		 * Unique header TH/TD element for this column - this is what the sorting
		 * listener is attached to (if sorting is enabled.)
		 *  @type node
		 *  @default null
		 */
		"nTh": null,
	
		/**
		 * Unique footer TH/TD element for this column (if there is one). Not used
		 * in DataTables as such, but can be used for plug-ins to reference the
		 * footer for each column.
		 *  @type node
		 *  @default null
		 */
		"nTf": null,
	
		/**
		 * The class to apply to all TD elements in the table's TBODY for the column
		 *  @type string
		 *  @default null
		 */
		"sClass": null,
	
		/**
		 * When DataTables calculates the column widths to assign to each column,
		 * it finds the longest string in each column and then constructs a
		 * temporary table and reads the widths from that. The problem with this
		 * is that "mmm" is much wider then "iiii", but the latter is a longer
		 * string - thus the calculation can go wrong (doing it properly and putting
		 * it into an DOM object and measuring that is horribly(!) slow). Thus as
		 * a "work around" we provide this option. It will append its value to the
		 * text that is found to be the longest string for the column - i.e. padding.
		 *  @type string
		 */
		"sContentPadding": null,
	
		/**
		 * Allows a default value to be given for a column's data, and will be used
		 * whenever a null data source is encountered (this can be because mData
		 * is set to null, or because the data source itself is null).
		 *  @type string
		 *  @default null
		 */
		"sDefaultContent": null,
	
		/**
		 * Name for the column, allowing reference to the column by name as well as
		 * by index (needs a lookup to work by name).
		 *  @type string
		 */
		"sName": null,
	
		/**
		 * Custom sorting data type - defines which of the available plug-ins in
		 * afnSortData the custom sorting will use - if any is defined.
		 *  @type string
		 *  @default std
		 */
		"sSortDataType": 'std',
	
		/**
		 * Class to be applied to the header element when sorting on this column
		 *  @type string
		 *  @default null
		 */
		"sSortingClass": null,
	
		/**
		 * Class to be applied to the header element when sorting on this column -
		 * when jQuery UI theming is used.
		 *  @type string
		 *  @default null
		 */
		"sSortingClassJUI": null,
	
		/**
		 * Title of the column - what is seen in the TH element (nTh).
		 *  @type string
		 */
		"sTitle": null,
	
		/**
		 * Column sorting and filtering type
		 *  @type string
		 *  @default null
		 */
		"sType": null,
	
		/**
		 * Width of the column
		 *  @type string
		 *  @default null
		 */
		"sWidth": null,
	
		/**
		 * Width of the column when it was first "encountered"
		 *  @type string
		 *  @default null
		 */
		"sWidthOrig": null
	};
	
	
	/*
	 * Developer note: The properties of the object below are given in Hungarian
	 * notation, that was used as the interface for DataTables prior to v1.10, however
	 * from v1.10 onwards the primary interface is camel case. In order to avoid
	 * breaking backwards compatibility utterly with this change, the Hungarian
	 * version is still, internally the primary interface, but is is not documented
	 * - hence the @name tags in each doc comment. This allows a Javascript function
	 * to create a map from Hungarian notation to camel case (going the other direction
	 * would require each property to be listed, which would add around 3K to the size
	 * of DataTables, while this method is about a 0.5K hit).
	 *
	 * Ultimately this does pave the way for Hungarian notation to be dropped
	 * completely, but that is a massive amount of work and will break current
	 * installs (therefore is on-hold until v2).
	 */
	
	/**
	 * Initialisation options that can be given to DataTables at initialisation
	 * time.
	 *  @namespace
	 */
	DataTable.defaults = {
		/**
		 * An array of data to use for the table, passed in at initialisation which
		 * will be used in preference to any data which is already in the DOM. This is
		 * particularly useful for constructing tables purely in Javascript, for
		 * example with a custom Ajax call.
		 *  @type array
		 *  @default null
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.data
		 *
		 *  @example
		 *    // Using a 2D array data source
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "data": [
		 *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
		 *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
		 *        ],
		 *        "columns": [
		 *          { "title": "Engine" },
		 *          { "title": "Browser" },
		 *          { "title": "Platform" },
		 *          { "title": "Version" },
		 *          { "title": "Grade" }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using an array of objects as a data source (`data`)
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "data": [
		 *          {
		 *            "engine":   "Trident",
		 *            "browser":  "Internet Explorer 4.0",
		 *            "platform": "Win 95+",
		 *            "version":  4,
		 *            "grade":    "X"
		 *          },
		 *          {
		 *            "engine":   "Trident",
		 *            "browser":  "Internet Explorer 5.0",
		 *            "platform": "Win 95+",
		 *            "version":  5,
		 *            "grade":    "C"
		 *          }
		 *        ],
		 *        "columns": [
		 *          { "title": "Engine",   "data": "engine" },
		 *          { "title": "Browser",  "data": "browser" },
		 *          { "title": "Platform", "data": "platform" },
		 *          { "title": "Version",  "data": "version" },
		 *          { "title": "Grade",    "data": "grade" }
		 *        ]
		 *      } );
		 *    } );
		 */
		"aaData": null,
	
	
		/**
		 * If ordering is enabled, then DataTables will perform a first pass sort on
		 * initialisation. You can define which column(s) the sort is performed
		 * upon, and the sorting direction, with this variable. The `sorting` array
		 * should contain an array for each column to be sorted initially containing
		 * the column's index and a direction string ('asc' or 'desc').
		 *  @type array
		 *  @default [[0,'asc']]
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.order
		 *
		 *  @example
		 *    // Sort by 3rd column first, and then 4th column
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "order": [[2,'asc'], [3,'desc']]
		 *      } );
		 *    } );
		 *
		 *    // No initial sorting
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "order": []
		 *      } );
		 *    } );
		 */
		"aaSorting": [[0,'asc']],
	
	
		/**
		 * This parameter is basically identical to the `sorting` parameter, but
		 * cannot be overridden by user interaction with the table. What this means
		 * is that you could have a column (visible or hidden) which the sorting
		 * will always be forced on first - any sorting after that (from the user)
		 * will then be performed as required. This can be useful for grouping rows
		 * together.
		 *  @type array
		 *  @default null
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.orderFixed
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "orderFixed": [[0,'asc']]
		 *      } );
		 *    } )
		 */
		"aaSortingFixed": [],
	
	
		/**
		 * DataTables can be instructed to load data to display in the table from a
		 * Ajax source. This option defines how that Ajax call is made and where to.
		 *
		 * The `ajax` property has three different modes of operation, depending on
		 * how it is defined. These are:
		 *
		 * * `string` - Set the URL from where the data should be loaded from.
		 * * `object` - Define properties for `jQuery.ajax`.
		 * * `function` - Custom data get function
		 *
		 * `string`
		 * --------
		 *
		 * As a string, the `ajax` property simply defines the URL from which
		 * DataTables will load data.
		 *
		 * `object`
		 * --------
		 *
		 * As an object, the parameters in the object are passed to
		 * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
		 * of the Ajax request. DataTables has a number of default parameters which
		 * you can override using this option. Please refer to the jQuery
		 * documentation for a full description of the options available, although
		 * the following parameters provide additional options in DataTables or
		 * require special consideration:
		 *
		 * * `data` - As with jQuery, `data` can be provided as an object, but it
		 *   can also be used as a function to manipulate the data DataTables sends
		 *   to the server. The function takes a single parameter, an object of
		 *   parameters with the values that DataTables has readied for sending. An
		 *   object may be returned which will be merged into the DataTables
		 *   defaults, or you can add the items to the object that was passed in and
		 *   not return anything from the function. This supersedes `fnServerParams`
		 *   from DataTables 1.9-.
		 *
		 * * `dataSrc` - By default DataTables will look for the property `data` (or
		 *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
		 *   from an Ajax source or for server-side processing - this parameter
		 *   allows that property to be changed. You can use Javascript dotted
		 *   object notation to get a data source for multiple levels of nesting, or
		 *   it my be used as a function. As a function it takes a single parameter,
		 *   the JSON returned from the server, which can be manipulated as
		 *   required, with the returned value being that used by DataTables as the
		 *   data source for the table. This supersedes `sAjaxDataProp` from
		 *   DataTables 1.9-.
		 *
		 * * `success` - Should not be overridden it is used internally in
		 *   DataTables. To manipulate / transform the data returned by the server
		 *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
		 *
		 * `function`
		 * ----------
		 *
		 * As a function, making the Ajax call is left up to yourself allowing
		 * complete control of the Ajax request. Indeed, if desired, a method other
		 * than Ajax could be used to obtain the required data, such as Web storage
		 * or an AIR database.
		 *
		 * The function is given four parameters and no return is required. The
		 * parameters are:
		 *
		 * 1. _object_ - Data to send to the server
		 * 2. _function_ - Callback function that must be executed when the required
		 *    data has been obtained. That data should be passed into the callback
		 *    as the only parameter
		 * 3. _object_ - DataTables settings object for the table
		 *
		 * Note that this supersedes `fnServerData` from DataTables 1.9-.
		 *
		 *  @type string|object|function
		 *  @default null
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.ajax
		 *  @since 1.10.0
		 *
		 * @example
		 *   // Get JSON data from a file via Ajax.
		 *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
		 *   $('#example').dataTable( {
		 *     "ajax": "data.json"
		 *   } );
		 *
		 * @example
		 *   // Get JSON data from a file via Ajax, using `dataSrc` to change
		 *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "dataSrc": "tableData"
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
		 *   // from a plain array rather than an array in an object
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "dataSrc": ""
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Manipulate the data returned from the server - add a link to data
		 *   // (note this can, should, be done using `render` for the column - this
		 *   // is just a simple example of how the data can be manipulated).
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "dataSrc": function ( json ) {
		 *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
		 *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
		 *         }
		 *         return json;
		 *       }
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Add data to the request
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "data": function ( d ) {
		 *         return {
		 *           "extra_search": $('#extra').val()
		 *         };
		 *       }
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Send request as POST
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "type": "POST"
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Get the data from localStorage (could interface with a form for
		 *   // adding, editing and removing rows).
		 *   $('#example').dataTable( {
		 *     "ajax": function (data, callback, settings) {
		 *       callback(
		 *         JSON.parse( localStorage.getItem('dataTablesData') )
		 *       );
		 *     }
		 *   } );
		 */
		"ajax": null,
	
	
		/**
		 * This parameter allows you to readily specify the entries in the length drop
		 * down menu that DataTables shows when pagination is enabled. It can be
		 * either a 1D array of options which will be used for both the displayed
		 * option and the value, or a 2D array which will use the array in the first
		 * position as the value, and the array in the second position as the
		 * displayed options (useful for language strings such as 'All').
		 *
		 * Note that the `pageLength` property will be automatically set to the
		 * first value given in this array, unless `pageLength` is also provided.
		 *  @type array
		 *  @default [ 10, 25, 50, 100 ]
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.lengthMenu
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
		 *      } );
		 *    } );
		 */
		"aLengthMenu": [ 10, 25, 50, 100 ],
	
	
		/**
		 * The `columns` option in the initialisation parameter allows you to define
		 * details about the way individual columns behave. For a full list of
		 * column options that can be set, please see
		 * {@link DataTable.defaults.column}. Note that if you use `columns` to
		 * define your columns, you must have an entry in the array for every single
		 * column that you have in your table (these can be null if you don't which
		 * to specify any options).
		 *  @member
		 *
		 *  @name DataTable.defaults.column
		 */
		"aoColumns": null,
	
		/**
		 * Very similar to `columns`, `columnDefs` allows you to target a specific
		 * column, multiple columns, or all columns, using the `targets` property of
		 * each object in the array. This allows great flexibility when creating
		 * tables, as the `columnDefs` arrays can be of any length, targeting the
		 * columns you specifically want. `columnDefs` may use any of the column
		 * options available: {@link DataTable.defaults.column}, but it _must_
		 * have `targets` defined in each object in the array. Values in the `targets`
		 * array may be:
		 *   <ul>
		 *     <li>a string - class name will be matched on the TH for the column</li>
		 *     <li>0 or a positive integer - column index counting from the left</li>
		 *     <li>a negative integer - column index counting from the right</li>
		 *     <li>the string "_all" - all columns (i.e. assign a default)</li>
		 *   </ul>
		 *  @member
		 *
		 *  @name DataTable.defaults.columnDefs
		 */
		"aoColumnDefs": null,
	
	
		/**
		 * Basically the same as `search`, this parameter defines the individual column
		 * filtering state at initialisation time. The array must be of the same size
		 * as the number of columns, and each element be an object with the parameters
		 * `search` and `escapeRegex` (the latter is optional). 'null' is also
		 * accepted and the default will be used.
		 *  @type array
		 *  @default []
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.searchCols
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "searchCols": [
		 *          null,
		 *          { "search": "My filter" },
		 *          null,
		 *          { "search": "^[0-9]", "escapeRegex": false }
		 *        ]
		 *      } );
		 *    } )
		 */
		"aoSearchCols": [],
	
	
		/**
		 * An array of CSS classes that should be applied to displayed rows. This
		 * array may be of any length, and DataTables will apply each class
		 * sequentially, looping when required.
		 *  @type array
		 *  @default null <i>Will take the values determined by the `oClasses.stripe*`
		 *    options</i>
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.stripeClasses
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
		 *      } );
		 *    } )
		 */
		"asStripeClasses": null,
	
	
		/**
		 * Enable or disable automatic column width calculation. This can be disabled
		 * as an optimisation (it takes some time to calculate the widths) if the
		 * tables widths are passed in using `columns`.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.autoWidth
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "autoWidth": false
		 *      } );
		 *    } );
		 */
		"bAutoWidth": true,
	
	
		/**
		 * Deferred rendering can provide DataTables with a huge speed boost when you
		 * are using an Ajax or JS data source for the table. This option, when set to
		 * true, will cause DataTables to defer the creation of the table elements for
		 * each row until they are needed for a draw - saving a significant amount of
		 * time.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.deferRender
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "ajax": "sources/arrays.txt",
		 *        "deferRender": true
		 *      } );
		 *    } );
		 */
		"bDeferRender": false,
	
	
		/**
		 * Replace a DataTable which matches the given selector and replace it with
		 * one which has the properties of the new initialisation object passed. If no
		 * table matches the selector, then the new DataTable will be constructed as
		 * per normal.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.destroy
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "srollY": "200px",
		 *        "paginate": false
		 *      } );
		 *
		 *      // Some time later....
		 *      $('#example').dataTable( {
		 *        "filter": false,
		 *        "destroy": true
		 *      } );
		 *    } );
		 */
		"bDestroy": false,
	
	
		/**
		 * Enable or disable filtering of data. Filtering in DataTables is "smart" in
		 * that it allows the end user to input multiple words (space separated) and
		 * will match a row containing those words, even if not in the order that was
		 * specified (this allow matching across multiple columns). Note that if you
		 * wish to use filtering in DataTables this must remain 'true' - to remove the
		 * default filtering input box and retain filtering abilities, please use
		 * {@link DataTable.defaults.dom}.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.searching
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "searching": false
		 *      } );
		 *    } );
		 */
		"bFilter": true,
	
	
		/**
		 * Enable or disable the table information display. This shows information
		 * about the data that is currently visible on the page, including information
		 * about filtered data if that action is being performed.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.info
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "info": false
		 *      } );
		 *    } );
		 */
		"bInfo": true,
	
	
		/**
		 * Allows the end user to select the size of a formatted page from a select
		 * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.lengthChange
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "lengthChange": false
		 *      } );
		 *    } );
		 */
		"bLengthChange": true,
	
	
		/**
		 * Enable or disable pagination.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.paging
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "paging": false
		 *      } );
		 *    } );
		 */
		"bPaginate": true,
	
	
		/**
		 * Enable or disable the display of a 'processing' indicator when the table is
		 * being processed (e.g. a sort). This is particularly useful for tables with
		 * large amounts of data where it can take a noticeable amount of time to sort
		 * the entries.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.processing
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "processing": true
		 *      } );
		 *    } );
		 */
		"bProcessing": false,
	
	
		/**
		 * Retrieve the DataTables object for the given selector. Note that if the
		 * table has already been initialised, this parameter will cause DataTables
		 * to simply return the object that has already been set up - it will not take
		 * account of any changes you might have made to the initialisation object
		 * passed to DataTables (setting this parameter to true is an acknowledgement
		 * that you understand this). `destroy` can be used to reinitialise a table if
		 * you need.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.retrieve
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      initTable();
		 *      tableActions();
		 *    } );
		 *
		 *    function initTable ()
		 *    {
		 *      return $('#example').dataTable( {
		 *        "scrollY": "200px",
		 *        "paginate": false,
		 *        "retrieve": true
		 *      } );
		 *    }
		 *
		 *    function tableActions ()
		 *    {
		 *      var table = initTable();
		 *      // perform API operations with oTable
		 *    }
		 */
		"bRetrieve": false,
	
	
		/**
		 * When vertical (y) scrolling is enabled, DataTables will force the height of
		 * the table's viewport to the given height at all times (useful for layout).
		 * However, this can look odd when filtering data down to a small data set,
		 * and the footer is left "floating" further down. This parameter (when
		 * enabled) will cause DataTables to collapse the table's viewport down when
		 * the result set will fit within the given Y height.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.scrollCollapse
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "scrollY": "200",
		 *        "scrollCollapse": true
		 *      } );
		 *    } );
		 */
		"bScrollCollapse": false,
	
	
		/**
		 * Configure DataTables to use server-side processing. Note that the
		 * `ajax` parameter must also be given in order to give DataTables a
		 * source to obtain the required data for each draw.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverSide
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "serverSide": true,
		 *        "ajax": "xhr.php"
		 *      } );
		 *    } );
		 */
		"bServerSide": false,
	
	
		/**
		 * Enable or disable sorting of columns. Sorting of individual columns can be
		 * disabled by the `sortable` option for each column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.ordering
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "ordering": false
		 *      } );
		 *    } );
		 */
		"bSort": true,
	
	
		/**
		 * Enable or display DataTables' ability to sort multiple columns at the
		 * same time (activated by shift-click by the user).
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.orderMulti
		 *
		 *  @example
		 *    // Disable multiple column sorting ability
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "orderMulti": false
		 *      } );
		 *    } );
		 */
		"bSortMulti": true,
	
	
		/**
		 * Allows control over whether DataTables should use the top (true) unique
		 * cell that is found for a single column, or the bottom (false - default).
		 * This is useful when using complex headers.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.orderCellsTop
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "orderCellsTop": true
		 *      } );
		 *    } );
		 */
		"bSortCellsTop": false,
	
	
		/**
		 * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
		 * `sorting\_3` to the columns which are currently being sorted on. This is
		 * presented as a feature switch as it can increase processing time (while
		 * classes are removed and added) so for large data sets you might want to
		 * turn this off.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.orderClasses
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "orderClasses": false
		 *      } );
		 *    } );
		 */
		"bSortClasses": true,
	
	
		/**
		 * Enable or disable state saving. When enabled HTML5 `localStorage` will be
		 * used to save table display information such as pagination information,
		 * display length, filtering and sorting. As such when the end user reloads
		 * the page the display display will match what thy had previously set up.
		 *
		 * Due to the use of `localStorage` the default state saving is not supported
		 * in IE6 or 7. If state saving is required in those browsers, use
		 * `stateSaveCallback` to provide a storage solution such as cookies.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.stateSave
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "stateSave": true
		 *      } );
		 *    } );
		 */
		"bStateSave": false,
	
	
		/**
		 * This function is called when a TR element is created (and all TD child
		 * elements have been inserted), or registered if using a DOM source, allowing
		 * manipulation of the TR element (adding classes etc).
		 *  @type function
		 *  @param {node} row "TR" element for the current row
		 *  @param {array} data Raw data array for this row
		 *  @param {int} dataIndex The index of this row in the internal aoData array
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.createdRow
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "createdRow": function( row, data, dataIndex ) {
		 *          // Bold the grade for all 'A' grade browsers
		 *          if ( data[4] == "A" )
		 *          {
		 *            $('td:eq(4)', row).html( '<b>A</b>' );
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		"fnCreatedRow": null,
	
	
		/**
		 * This function is called on every 'draw' event, and allows you to
		 * dynamically modify any aspect you want about the created DOM.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.drawCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "drawCallback": function( settings ) {
		 *          alert( 'DataTables has redrawn the table' );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnDrawCallback": null,
	
	
		/**
		 * Identical to fnHeaderCallback() but for the table footer this function
		 * allows you to modify the table footer on every 'draw' event.
		 *  @type function
		 *  @param {node} foot "TR" element for the footer
		 *  @param {array} data Full table data (as derived from the original HTML)
		 *  @param {int} start Index for the current display starting point in the
		 *    display array
		 *  @param {int} end Index for the current display ending point in the
		 *    display array
		 *  @param {array int} display Index array to translate the visual position
		 *    to the full data array
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.footerCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "footerCallback": function( tfoot, data, start, end, display ) {
		 *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
		 *        }
		 *      } );
		 *    } )
		 */
		"fnFooterCallback": null,
	
	
		/**
		 * When rendering large numbers in the information element for the table
		 * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
		 * to have a comma separator for the 'thousands' units (e.g. 1 million is
		 * rendered as "1,000,000") to help readability for the end user. This
		 * function will override the default method DataTables uses.
		 *  @type function
		 *  @member
		 *  @param {int} toFormat number to be formatted
		 *  @returns {string} formatted string for DataTables to show the number
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.formatNumber
		 *
		 *  @example
		 *    // Format a number using a single quote for the separator (note that
		 *    // this can also be done with the language.thousands option)
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "formatNumber": function ( toFormat ) {
		 *          return toFormat.toString().replace(
		 *            /\B(?=(\d{3})+(?!\d))/g, "'"
		 *          );
		 *        };
		 *      } );
		 *    } );
		 */
		"fnFormatNumber": function ( toFormat ) {
			return toFormat.toString().replace(
				/\B(?=(\d{3})+(?!\d))/g,
				this.oLanguage.sThousands
			);
		},
	
	
		/**
		 * This function is called on every 'draw' event, and allows you to
		 * dynamically modify the header row. This can be used to calculate and
		 * display useful information about the table.
		 *  @type function
		 *  @param {node} head "TR" element for the header
		 *  @param {array} data Full table data (as derived from the original HTML)
		 *  @param {int} start Index for the current display starting point in the
		 *    display array
		 *  @param {int} end Index for the current display ending point in the
		 *    display array
		 *  @param {array int} display Index array to translate the visual position
		 *    to the full data array
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.headerCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fheaderCallback": function( head, data, start, end, display ) {
		 *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
		 *        }
		 *      } );
		 *    } )
		 */
		"fnHeaderCallback": null,
	
	
		/**
		 * The information element can be used to convey information about the current
		 * state of the table. Although the internationalisation options presented by
		 * DataTables are quite capable of dealing with most customisations, there may
		 * be times where you wish to customise the string further. This callback
		 * allows you to do exactly that.
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @param {int} start Starting position in data for the draw
		 *  @param {int} end End position in data for the draw
		 *  @param {int} max Total number of rows in the table (regardless of
		 *    filtering)
		 *  @param {int} total Total number of rows in the data set, after filtering
		 *  @param {string} pre The string that DataTables has formatted using it's
		 *    own rules
		 *  @returns {string} The string to be displayed in the information element.
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.infoCallback
		 *
		 *  @example
		 *    $('#example').dataTable( {
		 *      "infoCallback": function( settings, start, end, max, total, pre ) {
		 *        return start +" to "+ end;
		 *      }
		 *    } );
		 */
		"fnInfoCallback": null,
	
	
		/**
		 * Called when the table has been initialised. Normally DataTables will
		 * initialise sequentially and there will be no need for this function,
		 * however, this does not hold true when using external language information
		 * since that is obtained using an async XHR call.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} json The JSON object request from the server - only
		 *    present if client-side Ajax sourced data is used
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.initComplete
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "initComplete": function(settings, json) {
		 *          alert( 'DataTables has finished its initialisation.' );
		 *        }
		 *      } );
		 *    } )
		 */
		"fnInitComplete": null,
	
	
		/**
		 * Called at the very start of each table draw and can be used to cancel the
		 * draw by returning false, any other return (including undefined) results in
		 * the full draw occurring).
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @returns {boolean} False will cancel the draw, anything else (including no
		 *    return) will allow it to complete.
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.preDrawCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "preDrawCallback": function( settings ) {
		 *          if ( $('#test').val() == 1 ) {
		 *            return false;
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		"fnPreDrawCallback": null,
	
	
		/**
		 * This function allows you to 'post process' each row after it have been
		 * generated for each table draw, but before it is rendered on screen. This
		 * function might be used for setting the row class name etc.
		 *  @type function
		 *  @param {node} row "TR" element for the current row
		 *  @param {array} data Raw data array for this row
		 *  @param {int} displayIndex The display index for the current table draw
		 *  @param {int} displayIndexFull The index of the data in the full list of
		 *    rows (after filtering)
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.rowCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
		 *          // Bold the grade for all 'A' grade browsers
		 *          if ( data[4] == "A" ) {
		 *            $('td:eq(4)', row).html( '<b>A</b>' );
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		"fnRowCallback": null,
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 * This parameter allows you to override the default function which obtains
		 * the data from the server so something more suitable for your application.
		 * For example you could use POST data, or pull information from a Gears or
		 * AIR database.
		 *  @type function
		 *  @member
		 *  @param {string} source HTTP source to obtain the data from (`ajax`)
		 *  @param {array} data A key/value pair object containing the data to send
		 *    to the server
		 *  @param {function} callback to be called on completion of the data get
		 *    process that will draw the data on the page.
		 *  @param {object} settings DataTables settings object
		 *
		 *  @dtopt Callbacks
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverData
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"fnServerData": null,
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 *  It is often useful to send extra data to the server when making an Ajax
		 * request - for example custom filtering information, and this callback
		 * function makes it trivial to send extra information to the server. The
		 * passed in parameter is the data set that has been constructed by
		 * DataTables, and you can add to this or modify it as you require.
		 *  @type function
		 *  @param {array} data Data array (array of objects which are name/value
		 *    pairs) that has been constructed by DataTables and will be sent to the
		 *    server. In the case of Ajax sourced data with server-side processing
		 *    this will be an empty array, for server-side processing there will be a
		 *    significant number of parameters!
		 *  @returns {undefined} Ensure that you modify the data array passed in,
		 *    as this is passed by reference.
		 *
		 *  @dtopt Callbacks
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverParams
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"fnServerParams": null,
	
	
		/**
		 * Load the table state. With this function you can define from where, and how, the
		 * state of a table is loaded. By default DataTables will load from `localStorage`
		 * but you might wish to use a server-side database or cookies.
		 *  @type function
		 *  @member
		 *  @param {object} settings DataTables settings object
		 *  @param {object} callback Callback that can be executed when done. It
		 *    should be passed the loaded state object.
		 *  @return {object} The DataTables state object to be loaded
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateLoadCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateLoadCallback": function (settings, callback) {
		 *          $.ajax( {
		 *            "url": "/state_load",
		 *            "dataType": "json",
		 *            "success": function (json) {
		 *              callback( json );
		 *            }
		 *          } );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateLoadCallback": function ( settings ) {
			try {
				return JSON.parse(
					(settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
						'DataTables_'+settings.sInstance+'_'+location.pathname
					)
				);
			} catch (e) {
				return {};
			}
		},
	
	
		/**
		 * Callback which allows modification of the saved state prior to loading that state.
		 * This callback is called when the table is loading state from the stored data, but
		 * prior to the settings object being modified by the saved state. Note that for
		 * plug-in authors, you should use the `stateLoadParams` event to load parameters for
		 * a plug-in.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object that is to be loaded
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateLoadParams
		 *
		 *  @example
		 *    // Remove a saved filter, so filtering is never loaded
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateLoadParams": function (settings, data) {
		 *          data.oSearch.sSearch = "";
		 *        }
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Disallow state loading by returning false
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateLoadParams": function (settings, data) {
		 *          return false;
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateLoadParams": null,
	
	
		/**
		 * Callback that is called when the state has been loaded from the state saving method
		 * and the DataTables settings object has been modified as a result of the loaded state.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object that was loaded
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateLoaded
		 *
		 *  @example
		 *    // Show an alert with the filtering value that was saved
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateLoaded": function (settings, data) {
		 *          alert( 'Saved filter was: '+data.oSearch.sSearch );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateLoaded": null,
	
	
		/**
		 * Save the table state. This function allows you to define where and how the state
		 * information for the table is stored By default DataTables will use `localStorage`
		 * but you might wish to use a server-side database or cookies.
		 *  @type function
		 *  @member
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object to be saved
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateSaveCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateSaveCallback": function (settings, data) {
		 *          // Send an Ajax request to the server with the state object
		 *          $.ajax( {
		 *            "url": "/state_save",
		 *            "data": data,
		 *            "dataType": "json",
		 *            "method": "POST"
		 *            "success": function () {}
		 *          } );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateSaveCallback": function ( settings, data ) {
			try {
				(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
					'DataTables_'+settings.sInstance+'_'+location.pathname,
					JSON.stringify( data )
				);
			} catch (e) {}
		},
	
	
		/**
		 * Callback which allows modification of the state to be saved. Called when the table
		 * has changed state a new state save is required. This method allows modification of
		 * the state saving object prior to actually doing the save, including addition or
		 * other state properties or modification. Note that for plug-in authors, you should
		 * use the `stateSaveParams` event to save parameters for a plug-in.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object to be saved
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateSaveParams
		 *
		 *  @example
		 *    // Remove a saved filter, so filtering is never saved
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateSaveParams": function (settings, data) {
		 *          data.oSearch.sSearch = "";
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateSaveParams": null,
	
	
		/**
		 * Duration for which the saved state information is considered valid. After this period
		 * has elapsed the state will be returned to the default.
		 * Value is given in seconds.
		 *  @type int
		 *  @default 7200 <i>(2 hours)</i>
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.stateDuration
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateDuration": 60*60*24; // 1 day
		 *      } );
		 *    } )
		 */
		"iStateDuration": 7200,
	
	
		/**
		 * When enabled DataTables will not make a request to the server for the first
		 * page draw - rather it will use the data already on the page (no sorting etc
		 * will be applied to it), thus saving on an XHR at load time. `deferLoading`
		 * is used to indicate that deferred loading is required, but it is also used
		 * to tell DataTables how many records there are in the full table (allowing
		 * the information element and pagination to be displayed correctly). In the case
		 * where a filtering is applied to the table on initial load, this can be
		 * indicated by giving the parameter as an array, where the first element is
		 * the number of records available after filtering and the second element is the
		 * number of records without filtering (allowing the table information element
		 * to be shown correctly).
		 *  @type int | array
		 *  @default null
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.deferLoading
		 *
		 *  @example
		 *    // 57 records available in the table, no filtering applied
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "serverSide": true,
		 *        "ajax": "scripts/server_processing.php",
		 *        "deferLoading": 57
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // 57 records after filtering, 100 without filtering (an initial filter applied)
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "serverSide": true,
		 *        "ajax": "scripts/server_processing.php",
		 *        "deferLoading": [ 57, 100 ],
		 *        "search": {
		 *          "search": "my_filter"
		 *        }
		 *      } );
		 *    } );
		 */
		"iDeferLoading": null,
	
	
		/**
		 * Number of rows to display on a single page when using pagination. If
		 * feature enabled (`lengthChange`) then the end user will be able to override
		 * this to a custom setting using a pop-up menu.
		 *  @type int
		 *  @default 10
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.pageLength
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "pageLength": 50
		 *      } );
		 *    } )
		 */
		"iDisplayLength": 10,
	
	
		/**
		 * Define the starting point for data display when using DataTables with
		 * pagination. Note that this parameter is the number of records, rather than
		 * the page number, so if you have 10 records per page and want to start on
		 * the third page, it should be "20".
		 *  @type int
		 *  @default 0
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.displayStart
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "displayStart": 20
		 *      } );
		 *    } )
		 */
		"iDisplayStart": 0,
	
	
		/**
		 * By default DataTables allows keyboard navigation of the table (sorting, paging,
		 * and filtering) by adding a `tabindex` attribute to the required elements. This
		 * allows you to tab through the controls and press the enter key to activate them.
		 * The tabindex is default 0, meaning that the tab follows the flow of the document.
		 * You can overrule this using this parameter if you wish. Use a value of -1 to
		 * disable built-in keyboard navigation.
		 *  @type int
		 *  @default 0
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.tabIndex
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "tabIndex": 1
		 *      } );
		 *    } );
		 */
		"iTabIndex": 0,
	
	
		/**
		 * Classes that DataTables assigns to the various components and features
		 * that it adds to the HTML table. This allows classes to be configured
		 * during initialisation in addition to through the static
		 * {@link DataTable.ext.oStdClasses} object).
		 *  @namespace
		 *  @name DataTable.defaults.classes
		 */
		"oClasses": {},
	
	
		/**
		 * All strings that DataTables uses in the user interface that it creates
		 * are defined in this object, allowing you to modified them individually or
		 * completely replace them all as required.
		 *  @namespace
		 *  @name DataTable.defaults.language
		 */
		"oLanguage": {
			/**
			 * Strings that are used for WAI-ARIA labels and controls only (these are not
			 * actually visible on the page, but will be read by screenreaders, and thus
			 * must be internationalised as well).
			 *  @namespace
			 *  @name DataTable.defaults.language.aria
			 */
			"oAria": {
				/**
				 * ARIA label that is added to the table headers when the column may be
				 * sorted ascending by activing the column (click or return when focused).
				 * Note that the column header is prefixed to this string.
				 *  @type string
				 *  @default : activate to sort column ascending
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.aria.sortAscending
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "aria": {
				 *            "sortAscending": " - click/return to sort ascending"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sSortAscending": ": activate to sort column ascending",
	
				/**
				 * ARIA label that is added to the table headers when the column may be
				 * sorted descending by activing the column (click or return when focused).
				 * Note that the column header is prefixed to this string.
				 *  @type string
				 *  @default : activate to sort column ascending
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.aria.sortDescending
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "aria": {
				 *            "sortDescending": " - click/return to sort descending"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sSortDescending": ": activate to sort column descending"
			},
	
			/**
			 * Pagination string used by DataTables for the built-in pagination
			 * control types.
			 *  @namespace
			 *  @name DataTable.defaults.language.paginate
			 */
			"oPaginate": {
				/**
				 * Text to use when using the 'full_numbers' type of pagination for the
				 * button to take the user to the first page.
				 *  @type string
				 *  @default First
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.first
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "paginate": {
				 *            "first": "First page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sFirst": "First",
	
	
				/**
				 * Text to use when using the 'full_numbers' type of pagination for the
				 * button to take the user to the last page.
				 *  @type string
				 *  @default Last
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.last
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "paginate": {
				 *            "last": "Last page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sLast": "Last",
	
	
				/**
				 * Text to use for the 'next' pagination button (to take the user to the
				 * next page).
				 *  @type string
				 *  @default Next
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.next
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "paginate": {
				 *            "next": "Next page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sNext": "Next",
	
	
				/**
				 * Text to use for the 'previous' pagination button (to take the user to
				 * the previous page).
				 *  @type string
				 *  @default Previous
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.previous
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "paginate": {
				 *            "previous": "Previous page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sPrevious": "Previous"
			},
	
			/**
			 * This string is shown in preference to `zeroRecords` when the table is
			 * empty of data (regardless of filtering). Note that this is an optional
			 * parameter - if it is not given, the value of `zeroRecords` will be used
			 * instead (either the default or given value).
			 *  @type string
			 *  @default No data available in table
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.emptyTable
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "emptyTable": "No data available in table"
			 *        }
			 *      } );
			 *    } );
			 */
			"sEmptyTable": "No data available in table",
	
	
			/**
			 * This string gives information to the end user about the information
			 * that is current on display on the page. The following tokens can be
			 * used in the string and will be dynamically replaced as the table
			 * display updates. This tokens can be placed anywhere in the string, or
			 * removed as needed by the language requires:
			 *
			 * * `\_START\_` - Display index of the first record on the current page
			 * * `\_END\_` - Display index of the last record on the current page
			 * * `\_TOTAL\_` - Number of records in the table after filtering
			 * * `\_MAX\_` - Number of records in the table without filtering
			 * * `\_PAGE\_` - Current page number
			 * * `\_PAGES\_` - Total number of pages of data in the table
			 *
			 *  @type string
			 *  @default Showing _START_ to _END_ of _TOTAL_ entries
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.info
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "info": "Showing page _PAGE_ of _PAGES_"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",
	
	
			/**
			 * Display information string for when the table is empty. Typically the
			 * format of this string should match `info`.
			 *  @type string
			 *  @default Showing 0 to 0 of 0 entries
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.infoEmpty
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "infoEmpty": "No entries to show"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoEmpty": "Showing 0 to 0 of 0 entries",
	
	
			/**
			 * When a user filters the information in a table, this string is appended
			 * to the information (`info`) to give an idea of how strong the filtering
			 * is. The variable _MAX_ is dynamically updated.
			 *  @type string
			 *  @default (filtered from _MAX_ total entries)
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.infoFiltered
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "infoFiltered": " - filtering from _MAX_ records"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoFiltered": "(filtered from _MAX_ total entries)",
	
	
			/**
			 * If can be useful to append extra information to the info string at times,
			 * and this variable does exactly that. This information will be appended to
			 * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
			 * being used) at all times.
			 *  @type string
			 *  @default <i>Empty string</i>
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.infoPostFix
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "infoPostFix": "All records shown are derived from real information."
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoPostFix": "",
	
	
			/**
			 * This decimal place operator is a little different from the other
			 * language options since DataTables doesn't output floating point
			 * numbers, so it won't ever use this for display of a number. Rather,
			 * what this parameter does is modify the sort methods of the table so
			 * that numbers which are in a format which has a character other than
			 * a period (`.`) as a decimal place will be sorted numerically.
			 *
			 * Note that numbers with different decimal places cannot be shown in
			 * the same table and still be sortable, the table must be consistent.
			 * However, multiple different tables on the page can use different
			 * decimal place characters.
			 *  @type string
			 *  @default 
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.decimal
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "decimal": ","
			 *          "thousands": "."
			 *        }
			 *      } );
			 *    } );
			 */
			"sDecimal": "",
	
	
			/**
			 * DataTables has a build in number formatter (`formatNumber`) which is
			 * used to format large numbers that are used in the table information.
			 * By default a comma is used, but this can be trivially changed to any
			 * character you wish with this parameter.
			 *  @type string
			 *  @default ,
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.thousands
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "thousands": "'"
			 *        }
			 *      } );
			 *    } );
			 */
			"sThousands": ",",
	
	
			/**
			 * Detail the action that will be taken when the drop down menu for the
			 * pagination length option is changed. The '_MENU_' variable is replaced
			 * with a default select list of 10, 25, 50 and 100, and can be replaced
			 * with a custom select box if required.
			 *  @type string
			 *  @default Show _MENU_ entries
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.lengthMenu
			 *
			 *  @example
			 *    // Language change only
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "lengthMenu": "Display _MENU_ records"
			 *        }
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Language and options change
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "lengthMenu": 'Display <select>'+
			 *            '<option value="10">10</option>'+
			 *            '<option value="20">20</option>'+
			 *            '<option value="30">30</option>'+
			 *            '<option value="40">40</option>'+
			 *            '<option value="50">50</option>'+
			 *            '<option value="-1">All</option>'+
			 *            '</select> records'
			 *        }
			 *      } );
			 *    } );
			 */
			"sLengthMenu": "Show _MENU_ entries",
	
	
			/**
			 * When using Ajax sourced data and during the first draw when DataTables is
			 * gathering the data, this message is shown in an empty row in the table to
			 * indicate to the end user the the data is being loaded. Note that this
			 * parameter is not used when loading data by server-side processing, just
			 * Ajax sourced data with client-side processing.
			 *  @type string
			 *  @default Loading...
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.loadingRecords
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "loadingRecords": "Please wait - loading..."
			 *        }
			 *      } );
			 *    } );
			 */
			"sLoadingRecords": "Loading...",
	
	
			/**
			 * Text which is displayed when the table is processing a user action
			 * (usually a sort command or similar).
			 *  @type string
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.processing
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "processing": "DataTables is currently busy"
			 *        }
			 *      } );
			 *    } );
			 */
			"sProcessing": "",
	
	
			/**
			 * Details the actions that will be taken when the user types into the
			 * filtering input text box. The variable "_INPUT_", if used in the string,
			 * is replaced with the HTML text box for the filtering input allowing
			 * control over where it appears in the string. If "_INPUT_" is not given
			 * then the input box is appended to the string automatically.
			 *  @type string
			 *  @default Search:
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.search
			 *
			 *  @example
			 *    // Input text box will be appended at the end automatically
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "search": "Filter records:"
			 *        }
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Specify where the filter should appear
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "search": "Apply filter _INPUT_ to table"
			 *        }
			 *      } );
			 *    } );
			 */
			"sSearch": "Search:",
	
	
			/**
			 * Assign a `placeholder` attribute to the search `input` element
			 *  @type string
			 *  @default 
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.searchPlaceholder
			 */
			"sSearchPlaceholder": "",
	
	
			/**
			 * All of the language information can be stored in a file on the
			 * server-side, which DataTables will look up if this parameter is passed.
			 * It must store the URL of the language file, which is in a JSON format,
			 * and the object has the same properties as the oLanguage object in the
			 * initialiser object (i.e. the above parameters). Please refer to one of
			 * the example language files to see how this works in action.
			 *  @type string
			 *  @default <i>Empty string - i.e. disabled</i>
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.url
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
			 *        }
			 *      } );
			 *    } );
			 */
			"sUrl": "",
	
	
			/**
			 * Text shown inside the table records when the is no information to be
			 * displayed after filtering. `emptyTable` is shown when there is simply no
			 * information in the table at all (regardless of filtering).
			 *  @type string
			 *  @default No matching records found
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.zeroRecords
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "zeroRecords": "No records to display"
			 *        }
			 *      } );
			 *    } );
			 */
			"sZeroRecords": "No matching records found"
		},
	
	
		/**
		 * This parameter allows you to have define the global filtering state at
		 * initialisation time. As an object the `search` parameter must be
		 * defined, but all other parameters are optional. When `regex` is true,
		 * the search string will be treated as a regular expression, when false
		 * (default) it will be treated as a straight string. When `smart`
		 * DataTables will use it's smart filtering methods (to word match at
		 * any point in the data), when false this will not be done.
		 *  @namespace
		 *  @extends DataTable.models.oSearch
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.search
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "search": {"search": "Initial search"}
		 *      } );
		 *    } )
		 */
		"oSearch": $.extend( {}, DataTable.models.oSearch ),
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 * By default DataTables will look for the property `data` (or `aaData` for
		 * compatibility with DataTables 1.9-) when obtaining data from an Ajax
		 * source or for server-side processing - this parameter allows that
		 * property to be changed. You can use Javascript dotted object notation to
		 * get a data source for multiple levels of nesting.
		 *  @type string
		 *  @default data
		 *
		 *  @dtopt Options
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.ajaxDataProp
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"sAjaxDataProp": "data",
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 * You can instruct DataTables to load data from an external
		 * source using this parameter (use aData if you want to pass data in you
		 * already have). Simply provide a url a JSON object can be obtained from.
		 *  @type string
		 *  @default null
		 *
		 *  @dtopt Options
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.ajaxSource
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"sAjaxSource": null,
	
	
		/**
		 * This initialisation variable allows you to specify exactly where in the
		 * DOM you want DataTables to inject the various controls it adds to the page
		 * (for example you might want the pagination controls at the top of the
		 * table). DIV elements (with or without a custom class) can also be added to
		 * aid styling. The follow syntax is used:
		 *   <ul>
		 *     <li>The following options are allowed:
		 *       <ul>
		 *         <li>'l' - Length changing</li>
		 *         <li>'f' - Filtering input</li>
		 *         <li>'t' - The table!</li>
		 *         <li>'i' - Information</li>
		 *         <li>'p' - Pagination</li>
		 *         <li>'r' - pRocessing</li>
		 *       </ul>
		 *     </li>
		 *     <li>The following constants are allowed:
		 *       <ul>
		 *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
		 *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
		 *       </ul>
		 *     </li>
		 *     <li>The following syntax is expected:
		 *       <ul>
		 *         <li>'&lt;' and '&gt;' - div elements</li>
		 *         <li>'&lt;"class" and '&gt;' - div with a class</li>
		 *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
		 *       </ul>
		 *     </li>
		 *     <li>Examples:
		 *       <ul>
		 *         <li>'&lt;"wrapper"flipt&gt;'</li>
		 *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
		 *       </ul>
		 *     </li>
		 *   </ul>
		 *  @type string
		 *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
		 *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.dom
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
		 *      } );
		 *    } );
		 */
		"sDom": "lfrtip",
	
	
		/**
		 * Search delay option. This will throttle full table searches that use the
		 * DataTables provided search input element (it does not effect calls to
		 * `dt-api search()`, providing a delay before the search is made.
		 *  @type integer
		 *  @default 0
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.searchDelay
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "searchDelay": 200
		 *      } );
		 *    } )
		 */
		"searchDelay": null,
	
	
		/**
		 * DataTables features six different built-in options for the buttons to
		 * display for pagination control:
		 *
		 * * `numbers` - Page number buttons only
		 * * `simple` - 'Previous' and 'Next' buttons only
		 * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
		 * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
		 * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
		 * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
		 *  
		 * Further methods can be added using {@link DataTable.ext.oPagination}.
		 *  @type string
		 *  @default simple_numbers
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.pagingType
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "pagingType": "full_numbers"
		 *      } );
		 *    } )
		 */
		"sPaginationType": "simple_numbers",
	
	
		/**
		 * Enable horizontal scrolling. When a table is too wide to fit into a
		 * certain layout, or you have a large number of columns in the table, you
		 * can enable x-scrolling to show the table in a viewport, which can be
		 * scrolled. This property can be `true` which will allow the table to
		 * scroll horizontally when needed, or any CSS unit, or a number (in which
		 * case it will be treated as a pixel measurement). Setting as simply `true`
		 * is recommended.
		 *  @type boolean|string
		 *  @default <i>blank string - i.e. disabled</i>
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.scrollX
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "scrollX": true,
		 *        "scrollCollapse": true
		 *      } );
		 *    } );
		 */
		"sScrollX": "",
	
	
		/**
		 * This property can be used to force a DataTable to use more width than it
		 * might otherwise do when x-scrolling is enabled. For example if you have a
		 * table which requires to be well spaced, this parameter is useful for
		 * "over-sizing" the table, and thus forcing scrolling. This property can by
		 * any CSS unit, or a number (in which case it will be treated as a pixel
		 * measurement).
		 *  @type string
		 *  @default <i>blank string - i.e. disabled</i>
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.scrollXInner
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "scrollX": "100%",
		 *        "scrollXInner": "110%"
		 *      } );
		 *    } );
		 */
		"sScrollXInner": "",
	
	
		/**
		 * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
		 * to the given height, and enable scrolling for any data which overflows the
		 * current viewport. This can be used as an alternative to paging to display
		 * a lot of data in a small area (although paging and scrolling can both be
		 * enabled at the same time). This property can be any CSS unit, or a number
		 * (in which case it will be treated as a pixel measurement).
		 *  @type string
		 *  @default <i>blank string - i.e. disabled</i>
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.scrollY
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "scrollY": "200px",
		 *        "paginate": false
		 *      } );
		 *    } );
		 */
		"sScrollY": "",
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 * Set the HTTP method that is used to make the Ajax call for server-side
		 * processing or Ajax sourced data.
		 *  @type string
		 *  @default GET
		 *
		 *  @dtopt Options
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverMethod
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"sServerMethod": "GET",
	
	
		/**
		 * DataTables makes use of renderers when displaying HTML elements for
		 * a table. These renderers can be added or modified by plug-ins to
		 * generate suitable mark-up for a site. For example the Bootstrap
		 * integration plug-in for DataTables uses a paging button renderer to
		 * display pagination buttons in the mark-up required by Bootstrap.
		 *
		 * For further information about the renderers available see
		 * DataTable.ext.renderer
		 *  @type string|object
		 *  @default null
		 *
		 *  @name DataTable.defaults.renderer
		 *
		 */
		"renderer": null,
	
	
		/**
		 * Set the data property name that DataTables should use to get a row's id
		 * to set as the `id` property in the node.
		 *  @type string
		 *  @default DT_RowId
		 *
		 *  @name DataTable.defaults.rowId
		 */
		"rowId": "DT_RowId"
	};
	
	_fnHungarianMap( DataTable.defaults );
	
	
	
	/*
	 * Developer note - See note in model.defaults.js about the use of Hungarian
	 * notation and camel case.
	 */
	
	/**
	 * Column options that can be given to DataTables at initialisation time.
	 *  @namespace
	 */
	DataTable.defaults.column = {
		/**
		 * Define which column(s) an order will occur on for this column. This
		 * allows a column's ordering to take multiple columns into account when
		 * doing a sort or use the data from a different column. For example first
		 * name / last name columns make sense to do a multi-column sort over the
		 * two columns.
		 *  @type array|int
		 *  @default null <i>Takes the value of the column index automatically</i>
		 *
		 *  @name DataTable.defaults.column.orderData
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
		 *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
		 *          { "orderData": 2, "targets": [ 2 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "orderData": [ 0, 1 ] },
		 *          { "orderData": [ 1, 0 ] },
		 *          { "orderData": 2 },
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"aDataSort": null,
		"iDataSort": -1,
	
	
		/**
		 * You can control the default ordering direction, and even alter the
		 * behaviour of the sort handler (i.e. only allow ascending ordering etc)
		 * using this parameter.
		 *  @type array
		 *  @default [ 'asc', 'desc' ]
		 *
		 *  @name DataTable.defaults.column.orderSequence
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
		 *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
		 *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          null,
		 *          { "orderSequence": [ "asc" ] },
		 *          { "orderSequence": [ "desc", "asc", "asc" ] },
		 *          { "orderSequence": [ "desc" ] },
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"asSorting": [ 'asc', 'desc' ],
	
	
		/**
		 * Enable or disable filtering on the data in this column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @name DataTable.defaults.column.searchable
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "searchable": false, "targets": [ 0 ] }
		 *        ] } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "searchable": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		"bSearchable": true,
	
	
		/**
		 * Enable or disable ordering on this column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @name DataTable.defaults.column.orderable
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "orderable": false, "targets": [ 0 ] }
		 *        ] } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "orderable": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		"bSortable": true,
	
	
		/**
		 * Enable or disable the display of this column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @name DataTable.defaults.column.visible
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "visible": false, "targets": [ 0 ] }
		 *        ] } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "visible": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		"bVisible": true,
	
	
		/**
		 * Developer definable function that is called whenever a cell is created (Ajax source,
		 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
		 * allowing you to modify the DOM element (add background colour for example) when the
		 * element is available.
		 *  @type function
		 *  @param {element} td The TD node that has been created
		 *  @param {*} cellData The Data for the cell
		 *  @param {array|object} rowData The data for the whole row
		 *  @param {int} row The row index for the aoData data store
		 *  @param {int} col The column index for aoColumns
		 *
		 *  @name DataTable.defaults.column.createdCell
		 *  @dtopt Columns
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [3],
		 *          "createdCell": function (td, cellData, rowData, row, col) {
		 *            if ( cellData == "1.7" ) {
		 *              $(td).css('color', 'blue')
		 *            }
		 *          }
		 *        } ]
		 *      });
		 *    } );
		 */
		"fnCreatedCell": null,
	
	
		/**
		 * This parameter has been replaced by `data` in DataTables to ensure naming
		 * consistency. `dataProp` can still be used, as there is backwards
		 * compatibility in DataTables for this option, but it is strongly
		 * recommended that you use `data` in preference to `dataProp`.
		 *  @name DataTable.defaults.column.dataProp
		 */
	
	
		/**
		 * This property can be used to read data from any data source property,
		 * including deeply nested objects / properties. `data` can be given in a
		 * number of different ways which effect its behaviour:
		 *
		 * * `integer` - treated as an array index for the data source. This is the
		 *   default that DataTables uses (incrementally increased for each column).
		 * * `string` - read an object property from the data source. There are
		 *   three 'special' options that can be used in the string to alter how
		 *   DataTables reads the data from the source object:
		 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
		 *      Javascript to read from nested objects, so to can the options
		 *      specified in `data`. For example: `browser.version` or
		 *      `browser.name`. If your object parameter name contains a period, use
		 *      `\\` to escape it - i.e. `first\\.name`.
		 *    * `[]` - Array notation. DataTables can automatically combine data
		 *      from and array source, joining the data with the characters provided
		 *      between the two brackets. For example: `name[, ]` would provide a
		 *      comma-space separated list from the source array. If no characters
		 *      are provided between the brackets, the original array source is
		 *      returned.
		 *    * `()` - Function notation. Adding `()` to the end of a parameter will
		 *      execute a function of the name given. For example: `browser()` for a
		 *      simple function on the data source, `browser.version()` for a
		 *      function in a nested property or even `browser().version` to get an
		 *      object property if the function called returns an object. Note that
		 *      function notation is recommended for use in `render` rather than
		 *      `data` as it is much simpler to use as a renderer.
		 * * `null` - use the original data source for the row rather than plucking
		 *   data directly from it. This action has effects on two other
		 *   initialisation options:
		 *    * `defaultContent` - When null is given as the `data` option and
		 *      `defaultContent` is specified for the column, the value defined by
		 *      `defaultContent` will be used for the cell.
		 *    * `render` - When null is used for the `data` option and the `render`
		 *      option is specified for the column, the whole data source for the
		 *      row is used for the renderer.
		 * * `function` - the function given will be executed whenever DataTables
		 *   needs to set or get the data for a cell in the column. The function
		 *   takes three parameters:
		 *    * Parameters:
		 *      * `{array|object}` The data source for the row
		 *      * `{string}` The type call data requested - this will be 'set' when
		 *        setting data or 'filter', 'display', 'type', 'sort' or undefined
		 *        when gathering data. Note that when `undefined` is given for the
		 *        type DataTables expects to get the raw data for the object back<
		 *      * `{*}` Data to set when the second parameter is 'set'.
		 *    * Return:
		 *      * The return value from the function is not required when 'set' is
		 *        the type of call, but otherwise the return is what will be used
		 *        for the data requested.
		 *
		 * Note that `data` is a getter and setter option. If you just require
		 * formatting of data for output, you will likely want to use `render` which
		 * is simply a getter and thus simpler to use.
		 *
		 * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
		 * name change reflects the flexibility of this property and is consistent
		 * with the naming of mRender. If 'mDataProp' is given, then it will still
		 * be used by DataTables, as it automatically maps the old name to the new
		 * if required.
		 *
		 *  @type string|int|function|null
		 *  @default null <i>Use automatically calculated column index</i>
		 *
		 *  @name DataTable.defaults.column.data
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Read table data from objects
		 *    // JSON structure for each row:
		 *    //   {
		 *    //      "engine": {value},
		 *    //      "browser": {value},
		 *    //      "platform": {value},
		 *    //      "version": {value},
		 *    //      "grade": {value}
		 *    //   }
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "ajaxSource": "sources/objects.txt",
		 *        "columns": [
		 *          { "data": "engine" },
		 *          { "data": "browser" },
		 *          { "data": "platform" },
		 *          { "data": "version" },
		 *          { "data": "grade" }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Read information from deeply nested objects
		 *    // JSON structure for each row:
		 *    //   {
		 *    //      "engine": {value},
		 *    //      "browser": {value},
		 *    //      "platform": {
		 *    //         "inner": {value}
		 *    //      },
		 *    //      "details": [
		 *    //         {value}, {value}
		 *    //      ]
		 *    //   }
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "ajaxSource": "sources/deep.txt",
		 *        "columns": [
		 *          { "data": "engine" },
		 *          { "data": "browser" },
		 *          { "data": "platform.inner" },
		 *          { "data": "details.0" },
		 *          { "data": "details.1" }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `data` as a function to provide different information for
		 *    // sorting, filtering and display. In this case, currency (price)
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": function ( source, type, val ) {
		 *            if (type === 'set') {
		 *              source.price = val;
		 *              // Store the computed display and filter values for efficiency
		 *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
		 *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
		 *              return;
		 *            }
		 *            else if (type === 'display') {
		 *              return source.price_display;
		 *            }
		 *            else if (type === 'filter') {
		 *              return source.price_filter;
		 *            }
		 *            // 'sort', 'type' and undefined all just use the integer
		 *            return source.price;
		 *          }
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using default content
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": null,
		 *          "defaultContent": "Click to edit"
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using array notation - outputting a list from an array
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": "name[, ]"
		 *        } ]
		 *      } );
		 *    } );
		 *
		 */
		"mData": null,
	
	
		/**
		 * This property is the rendering partner to `data` and it is suggested that
		 * when you want to manipulate data for display (including filtering,
		 * sorting etc) without altering the underlying data for the table, use this
		 * property. `render` can be considered to be the the read only companion to
		 * `data` which is read / write (then as such more complex). Like `data`
		 * this option can be given in a number of different ways to effect its
		 * behaviour:
		 *
		 * * `integer` - treated as an array index for the data source. This is the
		 *   default that DataTables uses (incrementally increased for each column).
		 * * `string` - read an object property from the data source. There are
		 *   three 'special' options that can be used in the string to alter how
		 *   DataTables reads the data from the source object:
		 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
		 *      Javascript to read from nested objects, so to can the options
		 *      specified in `data`. For example: `browser.version` or
		 *      `browser.name`. If your object parameter name contains a period, use
		 *      `\\` to escape it - i.e. `first\\.name`.
		 *    * `[]` - Array notation. DataTables can automatically combine data
		 *      from and array source, joining the data with the characters provided
		 *      between the two brackets. For example: `name[, ]` would provide a
		 *      comma-space separated list from the source array. If no characters
		 *      are provided between the brackets, the original array source is
		 *      returned.
		 *    * `()` - Function notation. Adding `()` to the end of a parameter will
		 *      execute a function of the name given. For example: `browser()` for a
		 *      simple function on the data source, `browser.version()` for a
		 *      function in a nested property or even `browser().version` to get an
		 *      object property if the function called returns an object.
		 * * `object` - use different data for the different data types requested by
		 *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
		 *   of the object is the data type the property refers to and the value can
		 *   defined using an integer, string or function using the same rules as
		 *   `render` normally does. Note that an `_` option _must_ be specified.
		 *   This is the default value to use if you haven't specified a value for
		 *   the data type requested by DataTables.
		 * * `function` - the function given will be executed whenever DataTables
		 *   needs to set or get the data for a cell in the column. The function
		 *   takes three parameters:
		 *    * Parameters:
		 *      * {array|object} The data source for the row (based on `data`)
		 *      * {string} The type call data requested - this will be 'filter',
		 *        'display', 'type' or 'sort'.
		 *      * {array|object} The full data source for the row (not based on
		 *        `data`)
		 *    * Return:
		 *      * The return value from the function is what will be used for the
		 *        data requested.
		 *
		 *  @type string|int|function|object|null
		 *  @default null Use the data source value.
		 *
		 *  @name DataTable.defaults.column.render
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Create a comma separated list from an array of objects
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "ajaxSource": "sources/deep.txt",
		 *        "columns": [
		 *          { "data": "engine" },
		 *          { "data": "browser" },
		 *          {
		 *            "data": "platform",
		 *            "render": "[, ].name"
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Execute a function to obtain data
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": null, // Use the full data source object for the renderer's source
		 *          "render": "browserName()"
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // As an object, extracting different data for the different types
		 *    // This would be used with a data source such as:
		 *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
		 *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
		 *    // (which has both forms) is used for filtering for if a user inputs either format, while
		 *    // the formatted phone number is the one that is shown in the table.
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": null, // Use the full data source object for the renderer's source
		 *          "render": {
		 *            "_": "phone",
		 *            "filter": "phone_filter",
		 *            "display": "phone_display"
		 *          }
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Use as a function to create a link from the data source
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": "download_link",
		 *          "render": function ( data, type, full ) {
		 *            return '<a href="'+data+'">Download</a>';
		 *          }
		 *        } ]
		 *      } );
		 *    } );
		 */
		"mRender": null,
	
	
		/**
		 * Change the cell type created for the column - either TD cells or TH cells. This
		 * can be useful as TH cells have semantic meaning in the table body, allowing them
		 * to act as a header for a row (you may wish to add scope='row' to the TH elements).
		 *  @type string
		 *  @default td
		 *
		 *  @name DataTable.defaults.column.cellType
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Make the first column use TH cells
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "cellType": "th"
		 *        } ]
		 *      } );
		 *    } );
		 */
		"sCellType": "td",
	
	
		/**
		 * Class to give to each cell in this column.
		 *  @type string
		 *  @default <i>Empty string</i>
		 *
		 *  @name DataTable.defaults.column.class
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "class": "my_class", "targets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "class": "my_class" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sClass": "",
	
		/**
		 * When DataTables calculates the column widths to assign to each column,
		 * it finds the longest string in each column and then constructs a
		 * temporary table and reads the widths from that. The problem with this
		 * is that "mmm" is much wider then "iiii", but the latter is a longer
		 * string - thus the calculation can go wrong (doing it properly and putting
		 * it into an DOM object and measuring that is horribly(!) slow). Thus as
		 * a "work around" we provide this option. It will append its value to the
		 * text that is found to be the longest string for the column - i.e. padding.
		 * Generally you shouldn't need this!
		 *  @type string
		 *  @default <i>Empty string<i>
		 *
		 *  @name DataTable.defaults.column.contentPadding
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          null,
		 *          null,
		 *          null,
		 *          {
		 *            "contentPadding": "mmm"
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sContentPadding": "",
	
	
		/**
		 * Allows a default value to be given for a column's data, and will be used
		 * whenever a null data source is encountered (this can be because `data`
		 * is set to null, or because the data source itself is null).
		 *  @type string
		 *  @default null
		 *
		 *  @name DataTable.defaults.column.defaultContent
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          {
		 *            "data": null,
		 *            "defaultContent": "Edit",
		 *            "targets": [ -1 ]
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          null,
		 *          null,
		 *          null,
		 *          {
		 *            "data": null,
		 *            "defaultContent": "Edit"
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sDefaultContent": null,
	
	
		/**
		 * This parameter is only used in DataTables' server-side processing. It can
		 * be exceptionally useful to know what columns are being displayed on the
		 * client side, and to map these to database fields. When defined, the names
		 * also allow DataTables to reorder information from the server if it comes
		 * back in an unexpected order (i.e. if you switch your columns around on the
		 * client-side, your server-side code does not also need updating).
		 *  @type string
		 *  @default <i>Empty string</i>
		 *
		 *  @name DataTable.defaults.column.name
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "name": "engine", "targets": [ 0 ] },
		 *          { "name": "browser", "targets": [ 1 ] },
		 *          { "name": "platform", "targets": [ 2 ] },
		 *          { "name": "version", "targets": [ 3 ] },
		 *          { "name": "grade", "targets": [ 4 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "name": "engine" },
		 *          { "name": "browser" },
		 *          { "name": "platform" },
		 *          { "name": "version" },
		 *          { "name": "grade" }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sName": "",
	
	
		/**
		 * Defines a data source type for the ordering which can be used to read
		 * real-time information from the table (updating the internally cached
		 * version) prior to ordering. This allows ordering to occur on user
		 * editable elements such as form inputs.
		 *  @type string
		 *  @default std
		 *
		 *  @name DataTable.defaults.column.orderDataType
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
		 *          { "type": "numeric", "targets": [ 3 ] },
		 *          { "orderDataType": "dom-select", "targets": [ 4 ] },
		 *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          null,
		 *          null,
		 *          { "orderDataType": "dom-text" },
		 *          { "orderDataType": "dom-text", "type": "numeric" },
		 *          { "orderDataType": "dom-select" },
		 *          { "orderDataType": "dom-checkbox" }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sSortDataType": "std",
	
	
		/**
		 * The title of this column.
		 *  @type string
		 *  @default null <i>Derived from the 'TH' value for this column in the
		 *    original HTML table.</i>
		 *
		 *  @name DataTable.defaults.column.title
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "title": "My column title", "targets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "title": "My column title" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sTitle": null,
	
	
		/**
		 * The type allows you to specify how the data for this column will be
		 * ordered. Four types (string, numeric, date and html (which will strip
		 * HTML tags before ordering)) are currently available. Note that only date
		 * formats understood by Javascript's Date() object will be accepted as type
		 * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
		 * 'numeric', 'date' or 'html' (by default). Further types can be adding
		 * through plug-ins.
		 *  @type string
		 *  @default null <i>Auto-detected from raw data</i>
		 *
		 *  @name DataTable.defaults.column.type
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "type": "html", "targets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "type": "html" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sType": null,
	
	
		/**
		 * Defining the width of the column, this parameter may take any CSS value
		 * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
		 * been given a specific width through this interface ensuring that the table
		 * remains readable.
		 *  @type string
		 *  @default null <i>Automatic</i>
		 *
		 *  @name DataTable.defaults.column.width
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "width": "20%", "targets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "width": "20%" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sWidth": null
	};
	
	_fnHungarianMap( DataTable.defaults.column );
	
	
	
	/**
	 * DataTables settings object - this holds all the information needed for a
	 * given table, including configuration, data and current application of the
	 * table options. DataTables does not have a single instance for each DataTable
	 * with the settings attached to that instance, but rather instances of the
	 * DataTable "class" are created on-the-fly as needed (typically by a
	 * $().dataTable() call) and the settings object is then applied to that
	 * instance.
	 *
	 * Note that this object is related to {@link DataTable.defaults} but this
	 * one is the internal data store for DataTables's cache of columns. It should
	 * NOT be manipulated outside of DataTables. Any configuration should be done
	 * through the initialisation options.
	 *  @namespace
	 *  @todo Really should attach the settings object to individual instances so we
	 *    don't need to create new instances on each $().dataTable() call (if the
	 *    table already exists). It would also save passing oSettings around and
	 *    into every single function. However, this is a very significant
	 *    architecture change for DataTables and will almost certainly break
	 *    backwards compatibility with older installations. This is something that
	 *    will be done in 2.0.
	 */
	DataTable.models.oSettings = {
		/**
		 * Primary features of DataTables and their enablement state.
		 *  @namespace
		 */
		"oFeatures": {
	
			/**
			 * Flag to say if DataTables should automatically try to calculate the
			 * optimum table and columns widths (true) or not (false).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bAutoWidth": null,
	
			/**
			 * Delay the creation of TR and TD elements until they are actually
			 * needed by a driven page draw. This can give a significant speed
			 * increase for Ajax source and Javascript source data, but makes no
			 * difference at all for DOM and server-side processing tables.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bDeferRender": null,
	
			/**
			 * Enable filtering on the table or not. Note that if this is disabled
			 * then there is no filtering at all on the table, including fnFilter.
			 * To just remove the filtering input use sDom and remove the 'f' option.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bFilter": null,
	
			/**
			 * Table information element (the 'Showing x of y records' div) enable
			 * flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bInfo": null,
	
			/**
			 * Present a user control allowing the end user to change the page size
			 * when pagination is enabled.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bLengthChange": null,
	
			/**
			 * Pagination enabled or not. Note that if this is disabled then length
			 * changing must also be disabled.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bPaginate": null,
	
			/**
			 * Processing indicator enable flag whenever DataTables is enacting a
			 * user request - typically an Ajax request for server-side processing.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bProcessing": null,
	
			/**
			 * Server-side processing enabled flag - when enabled DataTables will
			 * get all data from the server for every draw - there is no filtering,
			 * sorting or paging done on the client-side.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bServerSide": null,
	
			/**
			 * Sorting enablement flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSort": null,
	
			/**
			 * Multi-column sorting
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSortMulti": null,
	
			/**
			 * Apply a class to the columns which are being sorted to provide a
			 * visual highlight or not. This can slow things down when enabled since
			 * there is a lot of DOM interaction.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSortClasses": null,
	
			/**
			 * State saving enablement flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bStateSave": null
		},
	
	
		/**
		 * Scrolling settings for a table.
		 *  @namespace
		 */
		"oScroll": {
			/**
			 * When the table is shorter in height than sScrollY, collapse the
			 * table container down to the height of the table (when true).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bCollapse": null,
	
			/**
			 * Width of the scrollbar for the web-browser's platform. Calculated
			 * during table initialisation.
			 *  @type int
			 *  @default 0
			 */
			"iBarWidth": 0,
	
			/**
			 * Viewport width for horizontal scrolling. Horizontal scrolling is
			 * disabled if an empty string.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			"sX": null,
	
			/**
			 * Width to expand the table to when using x-scrolling. Typically you
			 * should not need to use this.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 *  @deprecated
			 */
			"sXInner": null,
	
			/**
			 * Viewport height for vertical scrolling. Vertical scrolling is disabled
			 * if an empty string.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			"sY": null
		},
	
		/**
		 * Language information for the table.
		 *  @namespace
		 *  @extends DataTable.defaults.oLanguage
		 */
		"oLanguage": {
			/**
			 * Information callback function. See
			 * {@link DataTable.defaults.fnInfoCallback}
			 *  @type function
			 *  @default null
			 */
			"fnInfoCallback": null
		},
	
		/**
		 * Browser support parameters
		 *  @namespace
		 */
		"oBrowser": {
			/**
			 * Indicate if the browser incorrectly calculates width:100% inside a
			 * scrolling element (IE6/7)
			 *  @type boolean
			 *  @default false
			 */
			"bScrollOversize": false,
	
			/**
			 * Determine if the vertical scrollbar is on the right or left of the
			 * scrolling container - needed for rtl language layout, although not
			 * all browsers move the scrollbar (Safari).
			 *  @type boolean
			 *  @default false
			 */
			"bScrollbarLeft": false,
	
			/**
			 * Flag for if `getBoundingClientRect` is fully supported or not
			 *  @type boolean
			 *  @default false
			 */
			"bBounding": false,
	
			/**
			 * Browser scrollbar width
			 *  @type integer
			 *  @default 0
			 */
			"barWidth": 0
		},
	
	
		"ajax": null,
	
	
		/**
		 * Array referencing the nodes which are used for the features. The
		 * parameters of this object match what is allowed by sDom - i.e.
		 *   <ul>
		 *     <li>'l' - Length changing</li>
		 *     <li>'f' - Filtering input</li>
		 *     <li>'t' - The table!</li>
		 *     <li>'i' - Information</li>
		 *     <li>'p' - Pagination</li>
		 *     <li>'r' - pRocessing</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 */
		"aanFeatures": [],
	
		/**
		 * Store data information - see {@link DataTable.models.oRow} for detailed
		 * information.
		 *  @type array
		 *  @default []
		 */
		"aoData": [],
	
		/**
		 * Array of indexes which are in the current display (after filtering etc)
		 *  @type array
		 *  @default []
		 */
		"aiDisplay": [],
	
		/**
		 * Array of indexes for display - no filtering
		 *  @type array
		 *  @default []
		 */
		"aiDisplayMaster": [],
	
		/**
		 * Map of row ids to data indexes
		 *  @type object
		 *  @default {}
		 */
		"aIds": {},
	
		/**
		 * Store information about each column that is in use
		 *  @type array
		 *  @default []
		 */
		"aoColumns": [],
	
		/**
		 * Store information about the table's header
		 *  @type array
		 *  @default []
		 */
		"aoHeader": [],
	
		/**
		 * Store information about the table's footer
		 *  @type array
		 *  @default []
		 */
		"aoFooter": [],
	
		/**
		 * Store the applied global search information in case we want to force a
		 * research or compare the old search to a new one.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @namespace
		 *  @extends DataTable.models.oSearch
		 */
		"oPreviousSearch": {},
	
		/**
		 * Store the applied search for each column - see
		 * {@link DataTable.models.oSearch} for the format that is used for the
		 * filtering information for each column.
		 *  @type array
		 *  @default []
		 */
		"aoPreSearchCols": [],
	
		/**
		 * Sorting that is applied to the table. Note that the inner arrays are
		 * used in the following manner:
		 * <ul>
		 *   <li>Index 0 - column number</li>
		 *   <li>Index 1 - current sorting direction</li>
		 * </ul>
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @todo These inner arrays should really be objects
		 */
		"aaSorting": null,
	
		/**
		 * Sorting that is always applied to the table (i.e. prefixed in front of
		 * aaSorting).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		"aaSortingFixed": [],
	
		/**
		 * Classes to use for the striping of a table.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		"asStripeClasses": null,
	
		/**
		 * If restoring a table - we should restore its striping classes as well
		 *  @type array
		 *  @default []
		 */
		"asDestroyStripes": [],
	
		/**
		 * If restoring a table - we should restore its width
		 *  @type int
		 *  @default 0
		 */
		"sDestroyWidth": 0,
	
		/**
		 * Callback functions array for every time a row is inserted (i.e. on a draw).
		 *  @type array
		 *  @default []
		 */
		"aoRowCallback": [],
	
		/**
		 * Callback functions for the header on each draw.
		 *  @type array
		 *  @default []
		 */
		"aoHeaderCallback": [],
	
		/**
		 * Callback function for the footer on each draw.
		 *  @type array
		 *  @default []
		 */
		"aoFooterCallback": [],
	
		/**
		 * Array of callback functions for draw callback functions
		 *  @type array
		 *  @default []
		 */
		"aoDrawCallback": [],
	
		/**
		 * Array of callback functions for row created function
		 *  @type array
		 *  @default []
		 */
		"aoRowCreatedCallback": [],
	
		/**
		 * Callback functions for just before the table is redrawn. A return of
		 * false will be used to cancel the draw.
		 *  @type array
		 *  @default []
		 */
		"aoPreDrawCallback": [],
	
		/**
		 * Callback functions for when the table has been initialised.
		 *  @type array
		 *  @default []
		 */
		"aoInitComplete": [],
	
	
		/**
		 * Callbacks for modifying the settings to be stored for state saving, prior to
		 * saving state.
		 *  @type array
		 *  @default []
		 */
		"aoStateSaveParams": [],
	
		/**
		 * Callbacks for modifying the settings that have been stored for state saving
		 * prior to using the stored values to restore the state.
		 *  @type array
		 *  @default []
		 */
		"aoStateLoadParams": [],
	
		/**
		 * Callbacks for operating on the settings object once the saved state has been
		 * loaded
		 *  @type array
		 *  @default []
		 */
		"aoStateLoaded": [],
	
		/**
		 * Cache the table ID for quick access
		 *  @type string
		 *  @default <i>Empty string</i>
		 */
		"sTableId": "",
	
		/**
		 * The TABLE node for the main table
		 *  @type node
		 *  @default null
		 */
		"nTable": null,
	
		/**
		 * Permanent ref to the thead element
		 *  @type node
		 *  @default null
		 */
		"nTHead": null,
	
		/**
		 * Permanent ref to the tfoot element - if it exists
		 *  @type node
		 *  @default null
		 */
		"nTFoot": null,
	
		/**
		 * Permanent ref to the tbody element
		 *  @type node
		 *  @default null
		 */
		"nTBody": null,
	
		/**
		 * Cache the wrapper node (contains all DataTables controlled elements)
		 *  @type node
		 *  @default null
		 */
		"nTableWrapper": null,
	
		/**
		 * Indicate if when using server-side processing the loading of data
		 * should be deferred until the second draw.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type boolean
		 *  @default false
		 */
		"bDeferLoading": false,
	
		/**
		 * Indicate if all required information has been read in
		 *  @type boolean
		 *  @default false
		 */
		"bInitialised": false,
	
		/**
		 * Information about open rows. Each object in the array has the parameters
		 * 'nTr' and 'nParent'
		 *  @type array
		 *  @default []
		 */
		"aoOpenRows": [],
	
		/**
		 * Dictate the positioning of DataTables' control elements - see
		 * {@link DataTable.model.oInit.sDom}.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default null
		 */
		"sDom": null,
	
		/**
		 * Search delay (in mS)
		 *  @type integer
		 *  @default null
		 */
		"searchDelay": null,
	
		/**
		 * Which type of pagination should be used.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default two_button
		 */
		"sPaginationType": "two_button",
	
		/**
		 * The state duration (for `stateSave`) in seconds.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type int
		 *  @default 0
		 */
		"iStateDuration": 0,
	
		/**
		 * Array of callback functions for state saving. Each array element is an
		 * object with the following parameters:
		 *   <ul>
		 *     <li>function:fn - function to call. Takes two parameters, oSettings
		 *       and the JSON string to save that has been thus far created. Returns
		 *       a JSON string to be inserted into a json object
		 *       (i.e. '"param": [ 0, 1, 2]')</li>
		 *     <li>string:sName - name of callback</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 */
		"aoStateSave": [],
	
		/**
		 * Array of callback functions for state loading. Each array element is an
		 * object with the following parameters:
		 *   <ul>
		 *     <li>function:fn - function to call. Takes two parameters, oSettings
		 *       and the object stored. May return false to cancel state loading</li>
		 *     <li>string:sName - name of callback</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 */
		"aoStateLoad": [],
	
		/**
		 * State that was saved. Useful for back reference
		 *  @type object
		 *  @default null
		 */
		"oSavedState": null,
	
		/**
		 * State that was loaded. Useful for back reference
		 *  @type object
		 *  @default null
		 */
		"oLoadedState": null,
	
		/**
		 * Source url for AJAX data for the table.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default null
		 */
		"sAjaxSource": null,
	
		/**
		 * Property from a given object from which to read the table data from. This
		 * can be an empty string (when not server-side processing), in which case
		 * it is  assumed an an array is given directly.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 */
		"sAjaxDataProp": null,
	
		/**
		 * The last jQuery XHR object that was used for server-side data gathering.
		 * This can be used for working with the XHR information in one of the
		 * callbacks
		 *  @type object
		 *  @default null
		 */
		"jqXHR": null,
	
		/**
		 * JSON returned from the server in the last Ajax request
		 *  @type object
		 *  @default undefined
		 */
		"json": undefined,
	
		/**
		 * Data submitted as part of the last Ajax request
		 *  @type object
		 *  @default undefined
		 */
		"oAjaxData": undefined,
	
		/**
		 * Function to get the server-side data.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type function
		 */
		"fnServerData": null,
	
		/**
		 * Functions which are called prior to sending an Ajax request so extra
		 * parameters can easily be sent to the server
		 *  @type array
		 *  @default []
		 */
		"aoServerParams": [],
	
		/**
		 * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
		 * required).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 */
		"sServerMethod": null,
	
		/**
		 * Format numbers for display.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type function
		 */
		"fnFormatNumber": null,
	
		/**
		 * List of options that can be used for the user selectable length menu.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		"aLengthMenu": null,
	
		/**
		 * Counter for the draws that the table does. Also used as a tracker for
		 * server-side processing
		 *  @type int
		 *  @default 0
		 */
		"iDraw": 0,
	
		/**
		 * Indicate if a redraw is being done - useful for Ajax
		 *  @type boolean
		 *  @default false
		 */
		"bDrawing": false,
	
		/**
		 * Draw index (iDraw) of the last error when parsing the returned data
		 *  @type int
		 *  @default -1
		 */
		"iDrawError": -1,
	
		/**
		 * Paging display length
		 *  @type int
		 *  @default 10
		 */
		"_iDisplayLength": 10,
	
		/**
		 * Paging start point - aiDisplay index
		 *  @type int
		 *  @default 0
		 */
		"_iDisplayStart": 0,
	
		/**
		 * Server-side processing - number of records in the result set
		 * (i.e. before filtering), Use fnRecordsTotal rather than
		 * this property to get the value of the number of records, regardless of
		 * the server-side processing setting.
		 *  @type int
		 *  @default 0
		 *  @private
		 */
		"_iRecordsTotal": 0,
	
		/**
		 * Server-side processing - number of records in the current display set
		 * (i.e. after filtering). Use fnRecordsDisplay rather than
		 * this property to get the value of the number of records, regardless of
		 * the server-side processing setting.
		 *  @type boolean
		 *  @default 0
		 *  @private
		 */
		"_iRecordsDisplay": 0,
	
		/**
		 * The classes to use for the table
		 *  @type object
		 *  @default {}
		 */
		"oClasses": {},
	
		/**
		 * Flag attached to the settings object so you can check in the draw
		 * callback if filtering has been done in the draw. Deprecated in favour of
		 * events.
		 *  @type boolean
		 *  @default false
		 *  @deprecated
		 */
		"bFiltered": false,
	
		/**
		 * Flag attached to the settings object so you can check in the draw
		 * callback if sorting has been done in the draw. Deprecated in favour of
		 * events.
		 *  @type boolean
		 *  @default false
		 *  @deprecated
		 */
		"bSorted": false,
	
		/**
		 * Indicate that if multiple rows are in the header and there is more than
		 * one unique cell per column, if the top one (true) or bottom one (false)
		 * should be used for sorting / title by DataTables.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type boolean
		 */
		"bSortCellsTop": null,
	
		/**
		 * Initialisation object that is used for the table
		 *  @type object
		 *  @default null
		 */
		"oInit": null,
	
		/**
		 * Destroy callback functions - for plug-ins to attach themselves to the
		 * destroy so they can clean up markup and events.
		 *  @type array
		 *  @default []
		 */
		"aoDestroyCallback": [],
	
	
		/**
		 * Get the number of records in the current record set, before filtering
		 *  @type function
		 */
		"fnRecordsTotal": function ()
		{
			return _fnDataSource( this ) == 'ssp' ?
				this._iRecordsTotal * 1 :
				this.aiDisplayMaster.length;
		},
	
		/**
		 * Get the number of records in the current record set, after filtering
		 *  @type function
		 */
		"fnRecordsDisplay": function ()
		{
			return _fnDataSource( this ) == 'ssp' ?
				this._iRecordsDisplay * 1 :
				this.aiDisplay.length;
		},
	
		/**
		 * Get the display end point - aiDisplay index
		 *  @type function
		 */
		"fnDisplayEnd": function ()
		{
			var
				len      = this._iDisplayLength,
				start    = this._iDisplayStart,
				calc     = start + len,
				records  = this.aiDisplay.length,
				features = this.oFeatures,
				paginate = features.bPaginate;
	
			if ( features.bServerSide ) {
				return paginate === false || len === -1 ?
					start + records :
					Math.min( start+len, this._iRecordsDisplay );
			}
			else {
				return ! paginate || calc>records || len===-1 ?
					records :
					calc;
			}
		},
	
		/**
		 * The DataTables object for this table
		 *  @type object
		 *  @default null
		 */
		"oInstance": null,
	
		/**
		 * Unique identifier for each instance of the DataTables object. If there
		 * is an ID on the table node, then it takes that value, otherwise an
		 * incrementing internal counter is used.
		 *  @type string
		 *  @default null
		 */
		"sInstance": null,
	
		/**
		 * tabindex attribute value that is added to DataTables control elements, allowing
		 * keyboard navigation of the table and its controls.
		 */
		"iTabIndex": 0,
	
		/**
		 * DIV container for the footer scrolling table if scrolling
		 */
		"nScrollHead": null,
	
		/**
		 * DIV container for the footer scrolling table if scrolling
		 */
		"nScrollFoot": null,
	
		/**
		 * Last applied sort
		 *  @type array
		 *  @default []
		 */
		"aLastSort": [],
	
		/**
		 * Stored plug-in instances
		 *  @type object
		 *  @default {}
		 */
		"oPlugins": {},
	
		/**
		 * Function used to get a row's id from the row's data
		 *  @type function
		 *  @default null
		 */
		"rowIdFn": null,
	
		/**
		 * Data location where to store a row's id
		 *  @type string
		 *  @default null
		 */
		"rowId": null
	};
	
	/**
	 * Extension object for DataTables that is used to provide all extension
	 * options.
	 *
	 * Note that the `DataTable.ext` object is available through
	 * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
	 * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
	 *  @namespace
	 *  @extends DataTable.models.ext
	 */
	
	
	/**
	 * DataTables extensions
	 * 
	 * This namespace acts as a collection area for plug-ins that can be used to
	 * extend DataTables capabilities. Indeed many of the build in methods
	 * use this method to provide their own capabilities (sorting methods for
	 * example).
	 *
	 * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
	 * reasons
	 *
	 *  @namespace
	 */
	DataTable.ext = _ext = {
		/**
		 * Buttons. For use with the Buttons extension for DataTables. This is
		 * defined here so other extensions can define buttons regardless of load
		 * order. It is _not_ used by DataTables core.
		 *
		 *  @type object
		 *  @default {}
		 */
		buttons: {},
	
	
		/**
		 * Element class names
		 *
		 *  @type object
		 *  @default {}
		 */
		classes: {},
	
	
		/**
		 * DataTables build type (expanded by the download builder)
		 *
		 *  @type string
		 */
		build:"bs5/dt-1.13.4/e-2.1.2/b-2.3.6/date-1.4.1/fh-3.3.2/sb-1.4.2",
	
	
		/**
		 * Error reporting.
		 * 
		 * How should DataTables report an error. Can take the value 'alert',
		 * 'throw', 'none' or a function.
		 *
		 *  @type string|function
		 *  @default alert
		 */
		errMode: "alert",
	
	
		/**
		 * Feature plug-ins.
		 * 
		 * This is an array of objects which describe the feature plug-ins that are
		 * available to DataTables. These feature plug-ins are then available for
		 * use through the `dom` initialisation option.
		 * 
		 * Each feature plug-in is described by an object which must have the
		 * following properties:
		 * 
		 * * `fnInit` - function that is used to initialise the plug-in,
		 * * `cFeature` - a character so the feature can be enabled by the `dom`
		 *   instillation option. This is case sensitive.
		 *
		 * The `fnInit` function has the following input parameters:
		 *
		 * 1. `{object}` DataTables settings object: see
		 *    {@link DataTable.models.oSettings}
		 *
		 * And the following return is expected:
		 * 
		 * * {node|null} The element which contains your feature. Note that the
		 *   return may also be void if your plug-in does not require to inject any
		 *   DOM elements into DataTables control (`dom`) - for example this might
		 *   be useful when developing a plug-in which allows table control via
		 *   keyboard entry
		 *
		 *  @type array
		 *
		 *  @example
		 *    $.fn.dataTable.ext.features.push( {
		 *      "fnInit": function( oSettings ) {
		 *        return new TableTools( { "oDTSettings": oSettings } );
		 *      },
		 *      "cFeature": "T"
		 *    } );
		 */
		feature: [],
	
	
		/**
		 * Row searching.
		 * 
		 * This method of searching is complimentary to the default type based
		 * searching, and a lot more comprehensive as it allows you complete control
		 * over the searching logic. Each element in this array is a function
		 * (parameters described below) that is called for every row in the table,
		 * and your logic decides if it should be included in the searching data set
		 * or not.
		 *
		 * Searching functions have the following input parameters:
		 *
		 * 1. `{object}` DataTables settings object: see
		 *    {@link DataTable.models.oSettings}
		 * 2. `{array|object}` Data for the row to be processed (same as the
		 *    original format that was passed in as the data source, or an array
		 *    from a DOM data source
		 * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
		 *    can be useful to retrieve the `TR` element if you need DOM interaction.
		 *
		 * And the following return is expected:
		 *
		 * * {boolean} Include the row in the searched result set (true) or not
		 *   (false)
		 *
		 * Note that as with the main search ability in DataTables, technically this
		 * is "filtering", since it is subtractive. However, for consistency in
		 * naming we call it searching here.
		 *
		 *  @type array
		 *  @default []
		 *
		 *  @example
		 *    // The following example shows custom search being applied to the
		 *    // fourth column (i.e. the data[3] index) based on two input values
		 *    // from the end-user, matching the data in a certain range.
		 *    $.fn.dataTable.ext.search.push(
		 *      function( settings, data, dataIndex ) {
		 *        var min = document.getElementById('min').value * 1;
		 *        var max = document.getElementById('max').value * 1;
		 *        var version = data[3] == "-" ? 0 : data[3]*1;
		 *
		 *        if ( min == "" && max == "" ) {
		 *          return true;
		 *        }
		 *        else if ( min == "" && version < max ) {
		 *          return true;
		 *        }
		 *        else if ( min < version && "" == max ) {
		 *          return true;
		 *        }
		 *        else if ( min < version && version < max ) {
		 *          return true;
		 *        }
		 *        return false;
		 *      }
		 *    );
		 */
		search: [],
	
	
		/**
		 * Selector extensions
		 *
		 * The `selector` option can be used to extend the options available for the
		 * selector modifier options (`selector-modifier` object data type) that
		 * each of the three built in selector types offer (row, column and cell +
		 * their plural counterparts). For example the Select extension uses this
		 * mechanism to provide an option to select only rows, columns and cells
		 * that have been marked as selected by the end user (`{selected: true}`),
		 * which can be used in conjunction with the existing built in selector
		 * options.
		 *
		 * Each property is an array to which functions can be pushed. The functions
		 * take three attributes:
		 *
		 * * Settings object for the host table
		 * * Options object (`selector-modifier` object type)
		 * * Array of selected item indexes
		 *
		 * The return is an array of the resulting item indexes after the custom
		 * selector has been applied.
		 *
		 *  @type object
		 */
		selector: {
			cell: [],
			column: [],
			row: []
		},
	
	
		/**
		 * Internal functions, exposed for used in plug-ins.
		 * 
		 * Please note that you should not need to use the internal methods for
		 * anything other than a plug-in (and even then, try to avoid if possible).
		 * The internal function may change between releases.
		 *
		 *  @type object
		 *  @default {}
		 */
		internal: {},
	
	
		/**
		 * Legacy configuration options. Enable and disable legacy options that
		 * are available in DataTables.
		 *
		 *  @type object
		 */
		legacy: {
			/**
			 * Enable / disable DataTables 1.9 compatible server-side processing
			 * requests
			 *
			 *  @type boolean
			 *  @default null
			 */
			ajax: null
		},
	
	
		/**
		 * Pagination plug-in methods.
		 * 
		 * Each entry in this object is a function and defines which buttons should
		 * be shown by the pagination rendering method that is used for the table:
		 * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
		 * buttons are displayed in the document, while the functions here tell it
		 * what buttons to display. This is done by returning an array of button
		 * descriptions (what each button will do).
		 *
		 * Pagination types (the four built in options and any additional plug-in
		 * options defined here) can be used through the `paginationType`
		 * initialisation parameter.
		 *
		 * The functions defined take two parameters:
		 *
		 * 1. `{int} page` The current page index
		 * 2. `{int} pages` The number of pages in the table
		 *
		 * Each function is expected to return an array where each element of the
		 * array can be one of:
		 *
		 * * `first` - Jump to first page when activated
		 * * `last` - Jump to last page when activated
		 * * `previous` - Show previous page when activated
		 * * `next` - Show next page when activated
		 * * `{int}` - Show page of the index given
		 * * `{array}` - A nested array containing the above elements to add a
		 *   containing 'DIV' element (might be useful for styling).
		 *
		 * Note that DataTables v1.9- used this object slightly differently whereby
		 * an object with two functions would be defined for each plug-in. That
		 * ability is still supported by DataTables 1.10+ to provide backwards
		 * compatibility, but this option of use is now decremented and no longer
		 * documented in DataTables 1.10+.
		 *
		 *  @type object
		 *  @default {}
		 *
		 *  @example
		 *    // Show previous, next and current page buttons only
		 *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
		 *      return [ 'previous', page, 'next' ];
		 *    };
		 */
		pager: {},
	
	
		renderer: {
			pageButton: {},
			header: {}
		},
	
	
		/**
		 * Ordering plug-ins - custom data source
		 * 
		 * The extension options for ordering of data available here is complimentary
		 * to the default type based ordering that DataTables typically uses. It
		 * allows much greater control over the the data that is being used to
		 * order a column, but is necessarily therefore more complex.
		 * 
		 * This type of ordering is useful if you want to do ordering based on data
		 * live from the DOM (for example the contents of an 'input' element) rather
		 * than just the static string that DataTables knows of.
		 * 
		 * The way these plug-ins work is that you create an array of the values you
		 * wish to be ordering for the column in question and then return that
		 * array. The data in the array much be in the index order of the rows in
		 * the table (not the currently ordering order!). Which order data gathering
		 * function is run here depends on the `dt-init columns.orderDataType`
		 * parameter that is used for the column (if any).
		 *
		 * The functions defined take two parameters:
		 *
		 * 1. `{object}` DataTables settings object: see
		 *    {@link DataTable.models.oSettings}
		 * 2. `{int}` Target column index
		 *
		 * Each function is expected to return an array:
		 *
		 * * `{array}` Data for the column to be ordering upon
		 *
		 *  @type array
		 *
		 *  @example
		 *    // Ordering using `input` node values
		 *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
		 *    {
		 *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
		 *        return $('input', td).val();
		 *      } );
		 *    }
		 */
		order: {},
	
	
		/**
		 * Type based plug-ins.
		 *
		 * Each column in DataTables has a type assigned to it, either by automatic
		 * detection or by direct assignment using the `type` option for the column.
		 * The type of a column will effect how it is ordering and search (plug-ins
		 * can also make use of the column type if required).
		 *
		 * @namespace
		 */
		type: {
			/**
			 * Type detection functions.
			 *
			 * The functions defined in this object are used to automatically detect
			 * a column's type, making initialisation of DataTables super easy, even
			 * when complex data is in the table.
			 *
			 * The functions defined take two parameters:
			 *
		     *  1. `{*}` Data from the column cell to be analysed
		     *  2. `{settings}` DataTables settings object. This can be used to
		     *     perform context specific type detection - for example detection
		     *     based on language settings such as using a comma for a decimal
		     *     place. Generally speaking the options from the settings will not
		     *     be required
			 *
			 * Each function is expected to return:
			 *
			 * * `{string|null}` Data type detected, or null if unknown (and thus
			 *   pass it on to the other type detection functions.
			 *
			 *  @type array
			 *
			 *  @example
			 *    // Currency type detection plug-in:
			 *    $.fn.dataTable.ext.type.detect.push(
			 *      function ( data, settings ) {
			 *        // Check the numeric part
			 *        if ( ! data.substring(1).match(/[0-9]/) ) {
			 *          return null;
			 *        }
			 *
			 *        // Check prefixed by currency
			 *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
			 *          return 'currency';
			 *        }
			 *        return null;
			 *      }
			 *    );
			 */
			detect: [],
	
	
			/**
			 * Type based search formatting.
			 *
			 * The type based searching functions can be used to pre-format the
			 * data to be search on. For example, it can be used to strip HTML
			 * tags or to de-format telephone numbers for numeric only searching.
			 *
			 * Note that is a search is not defined for a column of a given type,
			 * no search formatting will be performed.
			 * 
			 * Pre-processing of searching data plug-ins - When you assign the sType
			 * for a column (or have it automatically detected for you by DataTables
			 * or a type detection plug-in), you will typically be using this for
			 * custom sorting, but it can also be used to provide custom searching
			 * by allowing you to pre-processing the data and returning the data in
			 * the format that should be searched upon. This is done by adding
			 * functions this object with a parameter name which matches the sType
			 * for that target column. This is the corollary of <i>afnSortData</i>
			 * for searching data.
			 *
			 * The functions defined take a single parameter:
			 *
		     *  1. `{*}` Data from the column cell to be prepared for searching
			 *
			 * Each function is expected to return:
			 *
			 * * `{string|null}` Formatted string that will be used for the searching.
			 *
			 *  @type object
			 *  @default {}
			 *
			 *  @example
			 *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
			 *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
			 *    }
			 */
			search: {},
	
	
			/**
			 * Type based ordering.
			 *
			 * The column type tells DataTables what ordering to apply to the table
			 * when a column is sorted upon. The order for each type that is defined,
			 * is defined by the functions available in this object.
			 *
			 * Each ordering option can be described by three properties added to
			 * this object:
			 *
			 * * `{type}-pre` - Pre-formatting function
			 * * `{type}-asc` - Ascending order function
			 * * `{type}-desc` - Descending order function
			 *
			 * All three can be used together, only `{type}-pre` or only
			 * `{type}-asc` and `{type}-desc` together. It is generally recommended
			 * that only `{type}-pre` is used, as this provides the optimal
			 * implementation in terms of speed, although the others are provided
			 * for compatibility with existing Javascript sort functions.
			 *
			 * `{type}-pre`: Functions defined take a single parameter:
			 *
		     *  1. `{*}` Data from the column cell to be prepared for ordering
			 *
			 * And return:
			 *
			 * * `{*}` Data to be sorted upon
			 *
			 * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
			 * functions, taking two parameters:
			 *
		     *  1. `{*}` Data to compare to the second parameter
		     *  2. `{*}` Data to compare to the first parameter
			 *
			 * And returning:
			 *
			 * * `{*}` Ordering match: <0 if first parameter should be sorted lower
			 *   than the second parameter, ===0 if the two parameters are equal and
			 *   >0 if the first parameter should be sorted height than the second
			 *   parameter.
			 * 
			 *  @type object
			 *  @default {}
			 *
			 *  @example
			 *    // Numeric ordering of formatted numbers with a pre-formatter
			 *    $.extend( $.fn.dataTable.ext.type.order, {
			 *      "string-pre": function(x) {
			 *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
			 *        return parseFloat( a );
			 *      }
			 *    } );
			 *
			 *  @example
			 *    // Case-sensitive string ordering, with no pre-formatting method
			 *    $.extend( $.fn.dataTable.ext.order, {
			 *      "string-case-asc": function(x,y) {
			 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
			 *      },
			 *      "string-case-desc": function(x,y) {
			 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
			 *      }
			 *    } );
			 */
			order: {}
		},
	
		/**
		 * Unique DataTables instance counter
		 *
		 * @type int
		 * @private
		 */
		_unique: 0,
	
	
		//
		// Depreciated
		// The following properties are retained for backwards compatibility only.
		// The should not be used in new projects and will be removed in a future
		// version
		//
	
		/**
		 * Version check function.
		 *  @type function
		 *  @depreciated Since 1.10
		 */
		fnVersionCheck: DataTable.fnVersionCheck,
	
	
		/**
		 * Index for what 'this' index API functions should use
		 *  @type int
		 *  @deprecated Since v1.10
		 */
		iApiIndex: 0,
	
	
		/**
		 * jQuery UI class container
		 *  @type object
		 *  @deprecated Since v1.10
		 */
		oJUIClasses: {},
	
	
		/**
		 * Software version
		 *  @type string
		 *  @deprecated Since v1.10
		 */
		sVersion: DataTable.version
	};
	
	
	//
	// Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
	//
	$.extend( _ext, {
		afnFiltering: _ext.search,
		aTypes:       _ext.type.detect,
		ofnSearch:    _ext.type.search,
		oSort:        _ext.type.order,
		afnSortData:  _ext.order,
		aoFeatures:   _ext.feature,
		oApi:         _ext.internal,
		oStdClasses:  _ext.classes,
		oPagination:  _ext.pager
	} );
	
	
	$.extend( DataTable.ext.classes, {
		"sTable": "dataTable",
		"sNoFooter": "no-footer",
	
		/* Paging buttons */
		"sPageButton": "paginate_button",
		"sPageButtonActive": "current",
		"sPageButtonDisabled": "disabled",
	
		/* Striping classes */
		"sStripeOdd": "odd",
		"sStripeEven": "even",
	
		/* Empty row */
		"sRowEmpty": "dataTables_empty",
	
		/* Features */
		"sWrapper": "dataTables_wrapper",
		"sFilter": "dataTables_filter",
		"sInfo": "dataTables_info",
		"sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
		"sLength": "dataTables_length",
		"sProcessing": "dataTables_processing",
	
		/* Sorting */
		"sSortAsc": "sorting_asc",
		"sSortDesc": "sorting_desc",
		"sSortable": "sorting", /* Sortable in both directions */
		"sSortableAsc": "sorting_desc_disabled",
		"sSortableDesc": "sorting_asc_disabled",
		"sSortableNone": "sorting_disabled",
		"sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */
	
		/* Filtering */
		"sFilterInput": "",
	
		/* Page length */
		"sLengthSelect": "",
	
		/* Scrolling */
		"sScrollWrapper": "dataTables_scroll",
		"sScrollHead": "dataTables_scrollHead",
		"sScrollHeadInner": "dataTables_scrollHeadInner",
		"sScrollBody": "dataTables_scrollBody",
		"sScrollFoot": "dataTables_scrollFoot",
		"sScrollFootInner": "dataTables_scrollFootInner",
	
		/* Misc */
		"sHeaderTH": "",
		"sFooterTH": "",
	
		// Deprecated
		"sSortJUIAsc": "",
		"sSortJUIDesc": "",
		"sSortJUI": "",
		"sSortJUIAscAllowed": "",
		"sSortJUIDescAllowed": "",
		"sSortJUIWrapper": "",
		"sSortIcon": "",
		"sJUIHeader": "",
		"sJUIFooter": ""
	} );
	
	
	var extPagination = DataTable.ext.pager;
	
	function _numbers ( page, pages ) {
		var
			numbers = [],
			buttons = extPagination.numbers_length,
			half = Math.floor( buttons / 2 ),
			i = 1;
	
		if ( pages <= buttons ) {
			numbers = _range( 0, pages );
		}
		else if ( page <= half ) {
			numbers = _range( 0, buttons-2 );
			numbers.push( 'ellipsis' );
			numbers.push( pages-1 );
		}
		else if ( page >= pages - 1 - half ) {
			numbers = _range( pages-(buttons-2), pages );
			numbers.splice( 0, 0, 'ellipsis' ); // no unshift in ie6
			numbers.splice( 0, 0, 0 );
		}
		else {
			numbers = _range( page-half+2, page+half-1 );
			numbers.push( 'ellipsis' );
			numbers.push( pages-1 );
			numbers.splice( 0, 0, 'ellipsis' );
			numbers.splice( 0, 0, 0 );
		}
	
		numbers.DT_el = 'span';
		return numbers;
	}
	
	
	$.extend( extPagination, {
		simple: function ( page, pages ) {
			return [ 'previous', 'next' ];
		},
	
		full: function ( page, pages ) {
			return [  'first', 'previous', 'next', 'last' ];
		},
	
		numbers: function ( page, pages ) {
			return [ _numbers(page, pages) ];
		},
	
		simple_numbers: function ( page, pages ) {
			return [ 'previous', _numbers(page, pages), 'next' ];
		},
	
		full_numbers: function ( page, pages ) {
			return [ 'first', 'previous', _numbers(page, pages), 'next', 'last' ];
		},
		
		first_last_numbers: function (page, pages) {
	 		return ['first', _numbers(page, pages), 'last'];
	 	},
	
		// For testing and plug-ins to use
		_numbers: _numbers,
	
		// Number of number buttons (including ellipsis) to show. _Must be odd!_
		numbers_length: 7
	} );
	
	
	$.extend( true, DataTable.ext.renderer, {
		pageButton: {
			_: function ( settings, host, idx, buttons, page, pages ) {
				var classes = settings.oClasses;
				var lang = settings.oLanguage.oPaginate;
				var aria = settings.oLanguage.oAria.paginate || {};
				var btnDisplay, btnClass;
	
				var attach = function( container, buttons ) {
					var i, ien, node, button, tabIndex;
					var disabledClass = classes.sPageButtonDisabled;
					var clickHandler = function ( e ) {
						_fnPageChange( settings, e.data.action, true );
					};
	
					for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
						button = buttons[i];
	
						if ( Array.isArray( button ) ) {
							var inner = $( '<'+(button.DT_el || 'div')+'/>' )
								.appendTo( container );
							attach( inner, button );
						}
						else {
							btnDisplay = null;
							btnClass = button;
							tabIndex = settings.iTabIndex;
	
							switch ( button ) {
								case 'ellipsis':
									container.append('<span class="ellipsis">&#x2026;</span>');
									break;
	
								case 'first':
									btnDisplay = lang.sFirst;
	
									if ( page === 0 ) {
										tabIndex = -1;
										btnClass += ' ' + disabledClass;
									}
									break;
	
								case 'previous':
									btnDisplay = lang.sPrevious;
	
									if ( page === 0 ) {
										tabIndex = -1;
										btnClass += ' ' + disabledClass;
									}
									break;
	
								case 'next':
									btnDisplay = lang.sNext;
	
									if ( pages === 0 || page === pages-1 ) {
										tabIndex = -1;
										btnClass += ' ' + disabledClass;
									}
									break;
	
								case 'last':
									btnDisplay = lang.sLast;
	
									if ( pages === 0 || page === pages-1 ) {
										tabIndex = -1;
										btnClass += ' ' + disabledClass;
									}
									break;
	
								default:
									btnDisplay = settings.fnFormatNumber( button + 1 );
									btnClass = page === button ?
										classes.sPageButtonActive : '';
									break;
							}
	
							if ( btnDisplay !== null ) {
								var tag = settings.oInit.pagingTag || 'a';
								var disabled = btnClass.indexOf(disabledClass) !== -1;
			
	
								node = $('<'+tag+'>', {
										'class': classes.sPageButton+' '+btnClass,
										'aria-controls': settings.sTableId,
										'aria-disabled': disabled ? 'true' : null,
										'aria-label': aria[ button ],
										'aria-role': 'link',
										'aria-current': btnClass === classes.sPageButtonActive ? 'page' : null,
										'data-dt-idx': button,
										'tabindex': tabIndex,
										'id': idx === 0 && typeof button === 'string' ?
											settings.sTableId +'_'+ button :
											null
									} )
									.html( btnDisplay )
									.appendTo( container );
	
								_fnBindAction(
									node, {action: button}, clickHandler
								);
							}
						}
					}
				};
	
				// IE9 throws an 'unknown error' if document.activeElement is used
				// inside an iframe or frame. Try / catch the error. Not good for
				// accessibility, but neither are frames.
				var activeEl;
	
				try {
					// Because this approach is destroying and recreating the paging
					// elements, focus is lost on the select button which is bad for
					// accessibility. So we want to restore focus once the draw has
					// completed
					activeEl = $(host).find(document.activeElement).data('dt-idx');
				}
				catch (e) {}
	
				attach( $(host).empty(), buttons );
	
				if ( activeEl !== undefined ) {
					$(host).find( '[data-dt-idx='+activeEl+']' ).trigger('focus');
				}
			}
		}
	} );
	
	
	
	// Built in type detection. See model.ext.aTypes for information about
	// what is required from this methods.
	$.extend( DataTable.ext.type.detect, [
		// Plain numbers - first since V8 detects some plain numbers as dates
		// e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _isNumber( d, decimal ) ? 'num'+decimal : null;
		},
	
		// Dates (only those recognised by the browser's Date.parse)
		function ( d, settings )
		{
			// V8 tries _very_ hard to make a string passed into `Date.parse()`
			// valid, so we need to use a regex to restrict date formats. Use a
			// plug-in for anything other than ISO8601 style strings
			if ( d && !(d instanceof Date) && ! _re_date.test(d) ) {
				return null;
			}
			var parsed = Date.parse(d);
			return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null;
		},
	
		// Formatted numbers
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _isNumber( d, decimal, true ) ? 'num-fmt'+decimal : null;
		},
	
		// HTML numeric
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _htmlNumeric( d, decimal ) ? 'html-num'+decimal : null;
		},
	
		// HTML numeric, formatted
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _htmlNumeric( d, decimal, true ) ? 'html-num-fmt'+decimal : null;
		},
	
		// HTML (this is strict checking - there must be html)
		function ( d, settings )
		{
			return _empty( d ) || (typeof d === 'string' && d.indexOf('<') !== -1) ?
				'html' : null;
		}
	] );
	
	
	
	// Filter formatting functions. See model.ext.ofnSearch for information about
	// what is required from these methods.
	// 
	// Note that additional search methods are added for the html numbers and
	// html formatted numbers by `_addNumericSort()` when we know what the decimal
	// place is
	
	
	$.extend( DataTable.ext.type.search, {
		html: function ( data ) {
			return _empty(data) ?
				data :
				typeof data === 'string' ?
					data
						.replace( _re_new_lines, " " )
						.replace( _re_html, "" ) :
					'';
		},
	
		string: function ( data ) {
			return _empty(data) ?
				data :
				typeof data === 'string' ?
					data.replace( _re_new_lines, " " ) :
					data;
		}
	} );
	
	
	
	var __numericReplace = function ( d, decimalPlace, re1, re2 ) {
		if ( d !== 0 && (!d || d === '-') ) {
			return -Infinity;
		}
		
		let type = typeof d;
	
		if (type === 'number' || type === 'bigint') {
			return d;
		}
	
		// If a decimal place other than `.` is used, it needs to be given to the
		// function so we can detect it and replace with a `.` which is the only
		// decimal place Javascript recognises - it is not locale aware.
		if ( decimalPlace ) {
			d = _numToDecimal( d, decimalPlace );
		}
	
		if ( d.replace ) {
			if ( re1 ) {
				d = d.replace( re1, '' );
			}
	
			if ( re2 ) {
				d = d.replace( re2, '' );
			}
		}
	
		return d * 1;
	};
	
	
	// Add the numeric 'deformatting' functions for sorting and search. This is done
	// in a function to provide an easy ability for the language options to add
	// additional methods if a non-period decimal place is used.
	function _addNumericSort ( decimalPlace ) {
		$.each(
			{
				// Plain numbers
				"num": function ( d ) {
					return __numericReplace( d, decimalPlace );
				},
	
				// Formatted numbers
				"num-fmt": function ( d ) {
					return __numericReplace( d, decimalPlace, _re_formatted_numeric );
				},
	
				// HTML numeric
				"html-num": function ( d ) {
					return __numericReplace( d, decimalPlace, _re_html );
				},
	
				// HTML numeric, formatted
				"html-num-fmt": function ( d ) {
					return __numericReplace( d, decimalPlace, _re_html, _re_formatted_numeric );
				}
			},
			function ( key, fn ) {
				// Add the ordering method
				_ext.type.order[ key+decimalPlace+'-pre' ] = fn;
	
				// For HTML types add a search formatter that will strip the HTML
				if ( key.match(/^html\-/) ) {
					_ext.type.search[ key+decimalPlace ] = _ext.type.search.html;
				}
			}
		);
	}
	
	
	// Default sort methods
	$.extend( _ext.type.order, {
		// Dates
		"date-pre": function ( d ) {
			var ts = Date.parse( d );
			return isNaN(ts) ? -Infinity : ts;
		},
	
		// html
		"html-pre": function ( a ) {
			return _empty(a) ?
				'' :
				a.replace ?
					a.replace( /<.*?>/g, "" ).toLowerCase() :
					a+'';
		},
	
		// string
		"string-pre": function ( a ) {
			// This is a little complex, but faster than always calling toString,
			// http://jsperf.com/tostring-v-check
			return _empty(a) ?
				'' :
				typeof a === 'string' ?
					a.toLowerCase() :
					! a.toString ?
						'' :
						a.toString();
		},
	
		// string-asc and -desc are retained only for compatibility with the old
		// sort methods
		"string-asc": function ( x, y ) {
			return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		},
	
		"string-desc": function ( x, y ) {
			return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		}
	} );
	
	
	// Numeric sorting types - order doesn't matter here
	_addNumericSort( '' );
	
	
	$.extend( true, DataTable.ext.renderer, {
		header: {
			_: function ( settings, cell, column, classes ) {
				// No additional mark-up required
				// Attach a sort listener to update on sort - note that using the
				// `DT` namespace will allow the event to be removed automatically
				// on destroy, while the `dt` namespaced event is the one we are
				// listening for
				$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {
					if ( settings !== ctx ) { // need to check this this is the host
						return;               // table, not a nested one
					}
	
					var colIdx = column.idx;
	
					cell
						.removeClass(
							classes.sSortAsc +' '+
							classes.sSortDesc
						)
						.addClass( columns[ colIdx ] == 'asc' ?
							classes.sSortAsc : columns[ colIdx ] == 'desc' ?
								classes.sSortDesc :
								column.sSortingClass
						);
				} );
			},
	
			jqueryui: function ( settings, cell, column, classes ) {
				$('<div/>')
					.addClass( classes.sSortJUIWrapper )
					.append( cell.contents() )
					.append( $('<span/>')
						.addClass( classes.sSortIcon+' '+column.sSortingClassJUI )
					)
					.appendTo( cell );
	
				// Attach a sort listener to update on sort
				$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {
					if ( settings !== ctx ) {
						return;
					}
	
					var colIdx = column.idx;
	
					cell
						.removeClass( classes.sSortAsc +" "+classes.sSortDesc )
						.addClass( columns[ colIdx ] == 'asc' ?
							classes.sSortAsc : columns[ colIdx ] == 'desc' ?
								classes.sSortDesc :
								column.sSortingClass
						);
	
					cell
						.find( 'span.'+classes.sSortIcon )
						.removeClass(
							classes.sSortJUIAsc +" "+
							classes.sSortJUIDesc +" "+
							classes.sSortJUI +" "+
							classes.sSortJUIAscAllowed +" "+
							classes.sSortJUIDescAllowed
						)
						.addClass( columns[ colIdx ] == 'asc' ?
							classes.sSortJUIAsc : columns[ colIdx ] == 'desc' ?
								classes.sSortJUIDesc :
								column.sSortingClassJUI
						);
				} );
			}
		}
	} );
	
	/*
	 * Public helper functions. These aren't used internally by DataTables, or
	 * called by any of the options passed into DataTables, but they can be used
	 * externally by developers working with DataTables. They are helper functions
	 * to make working with DataTables a little bit easier.
	 */
	
	var __htmlEscapeEntities = function ( d ) {
		if (Array.isArray(d)) {
			d = d.join(',');
		}
	
		return typeof d === 'string' ?
			d
				.replace(/&/g, '&amp;')
				.replace(/</g, '&lt;')
				.replace(/>/g, '&gt;')
				.replace(/"/g, '&quot;') :
			d;
	};
	
	// Common logic for moment, luxon or a date action
	function __mld( dt, momentFn, luxonFn, dateFn, arg1 ) {
		if (window.moment) {
			return dt[momentFn]( arg1 );
		}
		else if (window.luxon) {
			return dt[luxonFn]( arg1 );
		}
		
		return dateFn ? dt[dateFn]( arg1 ) : dt;
	}
	
	
	var __mlWarning = false;
	function __mldObj (d, format, locale) {
		var dt;
	
		if (window.moment) {
			dt = window.moment.utc( d, format, locale, true );
	
			if (! dt.isValid()) {
				return null;
			}
		}
		else if (window.luxon) {
			dt = format && typeof d === 'string'
				? window.luxon.DateTime.fromFormat( d, format )
				: window.luxon.DateTime.fromISO( d );
	
			if (! dt.isValid) {
				return null;
			}
	
			dt.setLocale(locale);
		}
		else if (! format) {
			// No format given, must be ISO
			dt = new Date(d);
		}
		else {
			if (! __mlWarning) {
				alert('DataTables warning: Formatted date without Moment.js or Luxon - https://datatables.net/tn/17');
			}
	
			__mlWarning = true;
		}
	
		return dt;
	}
	
	// Wrapper for date, datetime and time which all operate the same way with the exception of
	// the output string for auto locale support
	function __mlHelper (localeString) {
		return function ( from, to, locale, def ) {
			// Luxon and Moment support
			// Argument shifting
			if ( arguments.length === 0 ) {
				locale = 'en';
				to = null; // means toLocaleString
				from = null; // means iso8601
			}
			else if ( arguments.length === 1 ) {
				locale = 'en';
				to = from;
				from = null;
			}
			else if ( arguments.length === 2 ) {
				locale = to;
				to = from;
				from = null;
			}
	
			var typeName = 'datetime-' + to;
	
			// Add type detection and sorting specific to this date format - we need to be able to identify
			// date type columns as such, rather than as numbers in extensions. Hence the need for this.
			if (! DataTable.ext.type.order[typeName]) {
				// The renderer will give the value to type detect as the type!
				DataTable.ext.type.detect.unshift(function (d) {
					return d === typeName ? typeName : false;
				});
	
				// The renderer gives us Moment, Luxon or Date obects for the sorting, all of which have a
				// `valueOf` which gives milliseconds epoch
				DataTable.ext.type.order[typeName + '-asc'] = function (a, b) {
					var x = a.valueOf();
					var y = b.valueOf();
	
					return x === y
						? 0
						: x < y
							? -1
							: 1;
				}
	
				DataTable.ext.type.order[typeName + '-desc'] = function (a, b) {
					var x = a.valueOf();
					var y = b.valueOf();
	
					return x === y
						? 0
						: x > y
							? -1
							: 1;
				}
			}
		
			return function ( d, type ) {
				// Allow for a default value
				if (d === null || d === undefined) {
					if (def === '--now') {
						// We treat everything as UTC further down, so no changes are
						// made, as such need to get the local date / time as if it were
						// UTC
						var local = new Date();
						d = new Date( Date.UTC(
							local.getFullYear(), local.getMonth(), local.getDate(),
							local.getHours(), local.getMinutes(), local.getSeconds()
						) );
					}
					else {
						d = '';
					}
				}
	
				if (type === 'type') {
					// Typing uses the type name for fast matching
					return typeName;
				}
	
				if (d === '') {
					return type !== 'sort'
						? ''
						: __mldObj('0000-01-01 00:00:00', null, locale);
				}
	
				// Shortcut. If `from` and `to` are the same, we are using the renderer to
				// format for ordering, not display - its already in the display format.
				if ( to !== null && from === to && type !== 'sort' && type !== 'type' && ! (d instanceof Date) ) {
					return d;
				}
	
				var dt = __mldObj(d, from, locale);
	
				if (dt === null) {
					return d;
				}
	
				if (type === 'sort') {
					return dt;
				}
				
				var formatted = to === null
					? __mld(dt, 'toDate', 'toJSDate', '')[localeString]()
					: __mld(dt, 'format', 'toFormat', 'toISOString', to);
	
				// XSS protection
				return type === 'display' ?
					__htmlEscapeEntities( formatted ) :
					formatted;
			};
		}
	}
	
	// Based on locale, determine standard number formatting
	// Fallback for legacy browsers is US English
	var __thousands = ',';
	var __decimal = '.';
	
	if (Intl) {
		try {
			var num = new Intl.NumberFormat().formatToParts(100000.1);
		
			for (var i=0 ; i<num.length ; i++) {
				if (num[i].type === 'group') {
					__thousands = num[i].value;
				}
				else if (num[i].type === 'decimal') {
					__decimal = num[i].value;
				}
			}
		}
		catch (e) {
			// noop
		}
	}
	
	// Formatted date time detection - use by declaring the formats you are going to use
	DataTable.datetime = function ( format, locale ) {
		var typeName = 'datetime-detect-' + format;
	
		if (! locale) {
			locale = 'en';
		}
	
		if (! DataTable.ext.type.order[typeName]) {
			DataTable.ext.type.detect.unshift(function (d) {
				var dt = __mldObj(d, format, locale);
				return d === '' || dt ? typeName : false;
			});
	
			DataTable.ext.type.order[typeName + '-pre'] = function (d) {
				return __mldObj(d, format, locale) || 0;
			}
		}
	}
	
	/**
	 * Helpers for `columns.render`.
	 *
	 * The options defined here can be used with the `columns.render` initialisation
	 * option to provide a display renderer. The following functions are defined:
	 *
	 * * `number` - Will format numeric data (defined by `columns.data`) for
	 *   display, retaining the original unformatted data for sorting and filtering.
	 *   It takes 5 parameters:
	 *   * `string` - Thousands grouping separator
	 *   * `string` - Decimal point indicator
	 *   * `integer` - Number of decimal points to show
	 *   * `string` (optional) - Prefix.
	 *   * `string` (optional) - Postfix (/suffix).
	 * * `text` - Escape HTML to help prevent XSS attacks. It has no optional
	 *   parameters.
	 *
	 * @example
	 *   // Column definition using the number renderer
	 *   {
	 *     data: "salary",
	 *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
	 *   }
	 *
	 * @namespace
	 */
	DataTable.render = {
		date: __mlHelper('toLocaleDateString'),
		datetime: __mlHelper('toLocaleString'),
		time: __mlHelper('toLocaleTimeString'),
		number: function ( thousands, decimal, precision, prefix, postfix ) {
			// Auto locale detection
			if (thousands === null || thousands === undefined) {
				thousands = __thousands;
			}
	
			if (decimal === null || decimal === undefined) {
				decimal = __decimal;
			}
	
			return {
				display: function ( d ) {
					if ( typeof d !== 'number' && typeof d !== 'string' ) {
						return d;
					}
	
					if (d === '' || d === null) {
						return d;
					}
	
					var negative = d < 0 ? '-' : '';
					var flo = parseFloat( d );
	
					// If NaN then there isn't much formatting that we can do - just
					// return immediately, escaping any HTML (this was supposed to
					// be a number after all)
					if ( isNaN( flo ) ) {
						return __htmlEscapeEntities( d );
					}
	
					flo = flo.toFixed( precision );
					d = Math.abs( flo );
	
					var intPart = parseInt( d, 10 );
					var floatPart = precision ?
						decimal+(d - intPart).toFixed( precision ).substring( 2 ):
						'';
	
					// If zero, then can't have a negative prefix
					if (intPart === 0 && parseFloat(floatPart) === 0) {
						negative = '';
					}
	
					return negative + (prefix||'') +
						intPart.toString().replace(
							/\B(?=(\d{3})+(?!\d))/g, thousands
						) +
						floatPart +
						(postfix||'');
				}
			};
		},
	
		text: function () {
			return {
				display: __htmlEscapeEntities,
				filter: __htmlEscapeEntities
			};
		}
	};
	
	
	/*
	 * This is really a good bit rubbish this method of exposing the internal methods
	 * publicly... - To be fixed in 2.0 using methods on the prototype
	 */
	
	
	/**
	 * Create a wrapper function for exporting an internal functions to an external API.
	 *  @param {string} fn API function name
	 *  @returns {function} wrapped function
	 *  @memberof DataTable#internal
	 */
	function _fnExternApiFunc (fn)
	{
		return function() {
			var args = [_fnSettingsFromNode( this[DataTable.ext.iApiIndex] )].concat(
				Array.prototype.slice.call(arguments)
			);
			return DataTable.ext.internal[fn].apply( this, args );
		};
	}
	
	
	/**
	 * Reference to internal functions for use by plug-in developers. Note that
	 * these methods are references to internal functions and are considered to be
	 * private. If you use these methods, be aware that they are liable to change
	 * between versions.
	 *  @namespace
	 */
	$.extend( DataTable.ext.internal, {
		_fnExternApiFunc: _fnExternApiFunc,
		_fnBuildAjax: _fnBuildAjax,
		_fnAjaxUpdate: _fnAjaxUpdate,
		_fnAjaxParameters: _fnAjaxParameters,
		_fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
		_fnAjaxDataSrc: _fnAjaxDataSrc,
		_fnAddColumn: _fnAddColumn,
		_fnColumnOptions: _fnColumnOptions,
		_fnAdjustColumnSizing: _fnAdjustColumnSizing,
		_fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
		_fnColumnIndexToVisible: _fnColumnIndexToVisible,
		_fnVisbleColumns: _fnVisbleColumns,
		_fnGetColumns: _fnGetColumns,
		_fnColumnTypes: _fnColumnTypes,
		_fnApplyColumnDefs: _fnApplyColumnDefs,
		_fnHungarianMap: _fnHungarianMap,
		_fnCamelToHungarian: _fnCamelToHungarian,
		_fnLanguageCompat: _fnLanguageCompat,
		_fnBrowserDetect: _fnBrowserDetect,
		_fnAddData: _fnAddData,
		_fnAddTr: _fnAddTr,
		_fnNodeToDataIndex: _fnNodeToDataIndex,
		_fnNodeToColumnIndex: _fnNodeToColumnIndex,
		_fnGetCellData: _fnGetCellData,
		_fnSetCellData: _fnSetCellData,
		_fnSplitObjNotation: _fnSplitObjNotation,
		_fnGetObjectDataFn: _fnGetObjectDataFn,
		_fnSetObjectDataFn: _fnSetObjectDataFn,
		_fnGetDataMaster: _fnGetDataMaster,
		_fnClearTable: _fnClearTable,
		_fnDeleteIndex: _fnDeleteIndex,
		_fnInvalidate: _fnInvalidate,
		_fnGetRowElements: _fnGetRowElements,
		_fnCreateTr: _fnCreateTr,
		_fnBuildHead: _fnBuildHead,
		_fnDrawHead: _fnDrawHead,
		_fnDraw: _fnDraw,
		_fnReDraw: _fnReDraw,
		_fnAddOptionsHtml: _fnAddOptionsHtml,
		_fnDetectHeader: _fnDetectHeader,
		_fnGetUniqueThs: _fnGetUniqueThs,
		_fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
		_fnFilterComplete: _fnFilterComplete,
		_fnFilterCustom: _fnFilterCustom,
		_fnFilterColumn: _fnFilterColumn,
		_fnFilter: _fnFilter,
		_fnFilterCreateSearch: _fnFilterCreateSearch,
		_fnEscapeRegex: _fnEscapeRegex,
		_fnFilterData: _fnFilterData,
		_fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
		_fnUpdateInfo: _fnUpdateInfo,
		_fnInfoMacros: _fnInfoMacros,
		_fnInitialise: _fnInitialise,
		_fnInitComplete: _fnInitComplete,
		_fnLengthChange: _fnLengthChange,
		_fnFeatureHtmlLength: _fnFeatureHtmlLength,
		_fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
		_fnPageChange: _fnPageChange,
		_fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
		_fnProcessingDisplay: _fnProcessingDisplay,
		_fnFeatureHtmlTable: _fnFeatureHtmlTable,
		_fnScrollDraw: _fnScrollDraw,
		_fnApplyToChildren: _fnApplyToChildren,
		_fnCalculateColumnWidths: _fnCalculateColumnWidths,
		_fnThrottle: _fnThrottle,
		_fnConvertToWidth: _fnConvertToWidth,
		_fnGetWidestNode: _fnGetWidestNode,
		_fnGetMaxLenString: _fnGetMaxLenString,
		_fnStringToCss: _fnStringToCss,
		_fnSortFlatten: _fnSortFlatten,
		_fnSort: _fnSort,
		_fnSortAria: _fnSortAria,
		_fnSortListener: _fnSortListener,
		_fnSortAttachListener: _fnSortAttachListener,
		_fnSortingClasses: _fnSortingClasses,
		_fnSortData: _fnSortData,
		_fnSaveState: _fnSaveState,
		_fnLoadState: _fnLoadState,
		_fnImplementState: _fnImplementState,
		_fnSettingsFromNode: _fnSettingsFromNode,
		_fnLog: _fnLog,
		_fnMap: _fnMap,
		_fnBindAction: _fnBindAction,
		_fnCallbackReg: _fnCallbackReg,
		_fnCallbackFire: _fnCallbackFire,
		_fnLengthOverflow: _fnLengthOverflow,
		_fnRenderer: _fnRenderer,
		_fnDataSource: _fnDataSource,
		_fnRowAttributes: _fnRowAttributes,
		_fnExtend: _fnExtend,
		_fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant
		                                // in 1.10, so this dead-end function is
		                                // added to prevent errors
	} );
	
	
	// jQuery access
	$.fn.dataTable = DataTable;
	
	// Provide access to the host jQuery object (circular reference)
	DataTable.$ = $;
	
	// Legacy aliases
	$.fn.dataTableSettings = DataTable.settings;
	$.fn.dataTableExt = DataTable.ext;
	
	// With a capital `D` we return a DataTables API instance rather than a
	// jQuery object
	$.fn.DataTable = function ( opts ) {
		return $(this).dataTable( opts ).api();
	};
	
	// All properties that are available to $.fn.dataTable should also be
	// available on $.fn.DataTable
	$.each( DataTable, function ( prop, val ) {
		$.fn.DataTable[ prop ] = val;
	} );

	return DataTable;
}));


/*! DataTables Bootstrap 5 integration
 * 2020 SpryMedia Ltd - datatables.net/license
 */

(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		var jq = require('jquery');
		var cjsRequires = function (root, $) {
			if ( ! $.fn.dataTable ) {
				require('datatables.net')(root, $);
			}
		};

		if (typeof window !== 'undefined') {
			module.exports = function (root, $) {
				if ( ! root ) {
					// CommonJS environments without a window global must pass a
					// root. This will give an error otherwise
					root = window;
				}

				if ( ! $ ) {
					$ = jq( root );
				}

				cjsRequires( root, $ );
				return factory( $, root, root.document );
			};
		}
		else {
			cjsRequires( window, jq );
			module.exports = factory( jq, window, window.document );
		}
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;



/**
 * DataTables integration for Bootstrap 5. This requires Bootstrap 5 and
 * DataTables 1.10 or newer.
 *
 * This file sets the defaults and adds options to DataTables to style its
 * controls using Bootstrap. See http://datatables.net/manual/styling/bootstrap
 * for further information.
 */

/* Set the defaults for DataTables initialisation */
$.extend( true, DataTable.defaults, {
	dom:
		"<'row'<'col-sm-12 col-md-6'l><'col-sm-12 col-md-6'f>>" +
		"<'row dt-row'<'col-sm-12'tr>>" +
		"<'row'<'col-sm-12 col-md-5'i><'col-sm-12 col-md-7'p>>",
	renderer: 'bootstrap'
} );


/* Default class modification */
$.extend( DataTable.ext.classes, {
	sWrapper:      "dataTables_wrapper dt-bootstrap5",
	sFilterInput:  "form-control form-control-sm",
	sLengthSelect: "form-select form-select-sm",
	sProcessing:   "dataTables_processing card",
	sPageButton:   "paginate_button page-item"
} );


/* Bootstrap paging button renderer */
DataTable.ext.renderer.pageButton.bootstrap = function ( settings, host, idx, buttons, page, pages ) {
	var api     = new DataTable.Api( settings );
	var classes = settings.oClasses;
	var lang    = settings.oLanguage.oPaginate;
	var aria = settings.oLanguage.oAria.paginate || {};
	var btnDisplay, btnClass;

	var attach = function( container, buttons ) {
		var i, ien, node, button;
		var clickHandler = function ( e ) {
			e.preventDefault();
			if ( !$(e.currentTarget).hasClass('disabled') && api.page() != e.data.action ) {
				api.page( e.data.action ).draw( 'page' );
			}
		};

		for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
			button = buttons[i];

			if ( Array.isArray( button ) ) {
				attach( container, button );
			}
			else {
				btnDisplay = '';
				btnClass = '';

				switch ( button ) {
					case 'ellipsis':
						btnDisplay = '&#x2026;';
						btnClass = 'disabled';
						break;

					case 'first':
						btnDisplay = lang.sFirst;
						btnClass = button + (page > 0 ?
							'' : ' disabled');
						break;

					case 'previous':
						btnDisplay = lang.sPrevious;
						btnClass = button + (page > 0 ?
							'' : ' disabled');
						break;

					case 'next':
						btnDisplay = lang.sNext;
						btnClass = button + (page < pages-1 ?
							'' : ' disabled');
						break;

					case 'last':
						btnDisplay = lang.sLast;
						btnClass = button + (page < pages-1 ?
							'' : ' disabled');
						break;

					default:
						btnDisplay = button + 1;
						btnClass = page === button ?
							'active' : '';
						break;
				}

				if ( btnDisplay ) {
					var disabled = btnClass.indexOf('disabled') !== -1;

					node = $('<li>', {
							'class': classes.sPageButton+' '+btnClass,
							'id': idx === 0 && typeof button === 'string' ?
								settings.sTableId +'_'+ button :
								null
						} )
						.append( $('<a>', {
								'href': disabled ? null : '#',
								'aria-controls': settings.sTableId,
								'aria-disabled': disabled ? 'true' : null,
								'aria-label': aria[ button ],
								'aria-role': 'link',
								'aria-current': btnClass === 'active' ? 'page' : null,
								'data-dt-idx': button,
								'tabindex': settings.iTabIndex,
								'class': 'page-link'
							} )
							.html( btnDisplay )
						)
						.appendTo( container );

					settings.oApi._fnBindAction(
						node, {action: button}, clickHandler
					);
				}
			}
		}
	};

	var hostEl = $(host);
	// IE9 throws an 'unknown error' if document.activeElement is used
	// inside an iframe or frame. 
	var activeEl;

	try {
		// Because this approach is destroying and recreating the paging
		// elements, focus is lost on the select button which is bad for
		// accessibility. So we want to restore focus once the draw has
		// completed
		activeEl = hostEl.find(document.activeElement).data('dt-idx');
	}
	catch (e) {}

	var paginationEl = hostEl.children('ul.pagination');

	if (paginationEl.length) {
		paginationEl.empty();
	}
	else {
		paginationEl = hostEl.html('<ul/>').children('ul').addClass('pagination');
	}

	attach(
		paginationEl,
		buttons
	);

	if ( activeEl !== undefined ) {
		hostEl.find('[data-dt-idx='+activeEl+']').trigger('focus');
	}
};


return DataTable;
}));


/*!
 * Version:     2.1.2
 * Author:      SpryMedia (www.sprymedia.co.uk)
 * Info:        http://editor.datatables.net
 * 
 * Copyright 2012-2023 SpryMedia Limited, all rights reserved.
 * License: DataTables Editor - http://editor.datatables.net/license
 */

 // Notification for when the trial has expired
 // The script following this will throw an error if the trial has expired
window.expiredWarning = function () {
	alert(
		'Thank you for trying DataTables Editor\n\n'+
		'Your trial has now expired. To purchase a license '+
		'for Editor, please see https://editor.datatables.net/purchase'
	);
};

(function(){r7lc_[594828]=(function(){var M=2;for(;M !== 9;){switch(M){case 5:var g;try{var E=2;for(;E !== 6;){switch(E){case 2:Object['\u0064\x65\x66\x69\u006e\x65\u0050\u0072\x6f\x70\x65\u0072\x74\x79'](Object['\x70\u0072\u006f\u0074\u006f\x74\u0079\x70\u0065'],'\u0051\x43\x44\u004e\x77',{'\x67\x65\x74':function(){var V=2;for(;V !== 1;){switch(V){case 2:return this;break;}}},'\x63\x6f\x6e\x66\x69\x67\x75\x72\x61\x62\x6c\x65':true});g=QCDNw;E=5;break;case 5:g['\u0072\u0070\u0043\u0072\u0066']=g;E=4;break;case 9:delete g['\x72\u0070\x43\u0072\u0066'];E=8;break;case 4:E=typeof rpCrf === '\x75\x6e\x64\x65\u0066\x69\x6e\u0065\u0064'?3:9;break;case 3:throw "";E=9;break;case 8:var F=Object['\u0070\x72\u006f\x74\u006f\u0074\x79\u0070\u0065'];delete F['\x51\u0043\x44\u004e\x77'];E=6;break;}}}catch(p){g=window;}return g;break;case 1:return globalThis;break;case 2:M=typeof globalThis === '\x6f\x62\u006a\x65\x63\u0074'?1:5;break;}}})();k7PZk0(r7lc_[594828]);r7lc_[616964]="n";function k7PZk0(w9P){function x5C(M10){var p8X=2;for(;p8X !== 5;){switch(p8X){case 2:var U4Y=[arguments];return U4Y[0][0].Function;break;}}}function f4z(R8T){var N6L=2;for(;N6L !== 5;){switch(N6L){case 2:var n0n=[arguments];return n0n[0][0].String;break;}}}function y3l(z6v){var q7g=2;for(;q7g !== 5;){switch(q7g){case 2:var j7s=[arguments];return j7s[0][0];break;}}}var m1r=2;for(;m1r !== 92;){switch(m1r){case 99:G5Y(M9t,"map",r6C[68],r6C[50]);m1r=98;break;case 82:r6C[57]+=r6C[6];r6C[57]+=r6C[9];r6C[50]=r6C[8];r6C[50]+=r6C[2];m1r=78;break;case 78:r6C[50]+=r6C[36];r6C[18]=r6C[7];r6C[18]+=r6C[1];r6C[18]+=r6C[4];m1r=101;break;case 66:r6C[80]+=r6C[22];r6C[80]+=r6C[56];r6C[54]=r6C[92];r6C[54]+=r6C[89];r6C[54]+=r6C[5];m1r=86;break;case 95:G5Y(y3l,r6C[94],r6C[51],r6C[33]);m1r=94;break;case 86:r6C[66]=r6C[49];r6C[66]+=r6C[47];r6C[66]+=r6C[3];r6C[57]=r6C[95];m1r=82;break;case 73:r6C[33]=r6C[82];r6C[33]+=r6C[27];r6C[33]+=r6C[72];r6C[94]=r6C[36];r6C[94]+=r6C[70];r6C[94]+=r6C[64];r6C[80]=r6C[21];m1r=66;break;case 3:r6C[1]="9Ar";r6C[7]="";r6C[7]="K";r6C[8]="";r6C[8]="i3";r6C[9]="";r6C[9]="DS";m1r=12;break;case 51:r6C[24]="";r6C[24]="9v";r6C[13]="";r6C[13]="Y";m1r=47;break;case 55:r6C[42]+=r6C[24];r6C[42]+=r6C[12];r6C[38]=r6C[53];r6C[38]+=r6C[30];r6C[38]+=r6C[52];m1r=73;break;case 94:G5Y(y3l,r6C[38],r6C[51],r6C[42]);m1r=93;break;case 38:r6C[30]="";r6C[82]="H$";r6C[30]="idu";r6C[12]="";r6C[53]="__res";r6C[12]="FKQ";m1r=51;break;case 23:r6C[56]="";r6C[47]="m";r6C[56]="$v";r6C[92]="z$";m1r=34;break;case 93:G5Y(x5C,"apply",r6C[68],r6C[15]);m1r=92;break;case 2:var r6C=[arguments];r6C[4]="";r6C[4]="$";r6C[1]="";m1r=3;break;case 100:G5Y(f4z,"replace",r6C[68],r6C[18]);m1r=99;break;case 60:r6C[51]=0;r6C[15]=r6C[16];r6C[15]+=r6C[32];r6C[15]+=r6C[23];r6C[42]=r6C[13];m1r=55;break;case 97:G5Y(y3l,r6C[66],r6C[51],r6C[54]);m1r=96;break;case 47:r6C[32]="";r6C[23]="V";r6C[32]="";r6C[32]="6zHh";m1r=64;break;case 15:r6C[5]="l";r6C[95]="C";r6C[89]="";r6C[89]="";r6C[89]="JT";m1r=23;break;case 19:r6C[3]="";r6C[3]="ize";r6C[5]="";r6C[49]="__opti";m1r=15;break;case 101:var G5Y=function(V6C,x8y,Q3V,Z1Y){var J3j=2;for(;J3j !== 5;){switch(J3j){case 2:var N3b=[arguments];P$J(r6C[0][0],N3b[0][0],N3b[0][1],N3b[0][2],N3b[0][3]);J3j=5;break;}}};m1r=100;break;case 98:G5Y(j9n,"test",r6C[68],r6C[57]);m1r=97;break;case 64:r6C[16]="";r6C[16]="P";r6C[68]=1;r6C[51]=8;m1r=60;break;case 96:G5Y(M9t,"push",r6C[68],r6C[80]);m1r=95;break;case 28:r6C[72]="";r6C[21]="Y00";r6C[72]="FT";r6C[52]="";r6C[36]="_";r6C[52]="al";r6C[27]="UV";m1r=38;break;case 12:r6C[6]="";r6C[6]="";r6C[2]="zn";r6C[6]="$l";m1r=19;break;case 34:r6C[22]="";r6C[22]="w";r6C[64]="";r6C[64]="tract";r6C[70]="";r6C[70]="_abs";m1r=28;break;}}function P$J(p7a,J5n,D4b,U$_,X3z){var N9l=2;for(;N9l !== 6;){switch(N9l){case 2:var A_p=[arguments];A_p[5]="";A_p[6]="erty";A_p[5]="ineProp";N9l=3;break;case 3:A_p[1]="def";A_p[7]=true;A_p[7]=false;try{var y_1=2;for(;y_1 !== 13;){switch(y_1){case 2:A_p[3]={};A_p[4]=(1,A_p[0][1])(A_p[0][0]);A_p[2]=[A_p[4],A_p[4].prototype][A_p[0][3]];y_1=4;break;case 4:y_1=A_p[2].hasOwnProperty(A_p[0][4]) && A_p[2][A_p[0][4]] === A_p[2][A_p[0][2]]?3:9;break;case 3:return;break;case 14:try{var g9t=2;for(;g9t !== 3;){switch(g9t){case 1:A_p[9]+=A_p[5];A_p[9]+=A_p[6];A_p[0][0].Object[A_p[9]](A_p[2],A_p[0][4],A_p[3]);g9t=3;break;case 2:A_p[9]=A_p[1];g9t=1;break;}}}catch(D_0){}y_1=13;break;case 9:A_p[2][A_p[0][4]]=A_p[2][A_p[0][2]];A_p[3].set=function(n99){var S7T=2;for(;S7T !== 5;){switch(S7T){case 2:var L68=[arguments];A_p[2][A_p[0][2]]=L68[0][0];S7T=5;break;}}};A_p[3].get=function(){var N1G=2;for(;N1G !== 12;){switch(N1G){case 6:M58[8]+=M58[3];M58[8]+=M58[4];return typeof A_p[2][A_p[0][2]] == M58[8]?undefined:A_p[2][A_p[0][2]];break;case 2:var M58=[arguments];M58[4]="";M58[4]="ned";M58[3]="fi";N1G=3;break;case 3:M58[1]="";M58[1]="";M58[1]="unde";M58[8]=M58[1];N1G=6;break;}}};A_p[3].enumerable=A_p[7];y_1=14;break;}}}catch(q9p){}N9l=6;break;}}}function j9n(q5J){var F8e=2;for(;F8e !== 5;){switch(F8e){case 2:var G$s=[arguments];return G$s[0][0].RegExp;break;}}}function M9t(w0L){var m59=2;for(;m59 !== 5;){switch(m59){case 2:var e4g=[arguments];return e4g[0][0].Array;break;}}}}r7lc_.e09='object';r7lc_[357471]="1";r7lc_.I0t="t";r7lc_.g6k="document";r7lc_.y2x=function(){return typeof r7lc_.j9A.L4PPQn2 === 'function'?r7lc_.j9A.L4PPQn2.apply(r7lc_.j9A,arguments):r7lc_.j9A.L4PPQn2;};r7lc_[386566]="9";r7lc_[631343]="c";r7lc_[430580]="";r7lc_.z0=function(){return typeof r7lc_[339067].B$X4_8x === 'function'?r7lc_[339067].B$X4_8x.apply(r7lc_[339067],arguments):r7lc_[339067].B$X4_8x;};function r7lc_(){}r7lc_.l9=function(){return typeof r7lc_[339067].B$X4_8x === 'function'?r7lc_[339067].B$X4_8x.apply(r7lc_[339067],arguments):r7lc_[339067].B$X4_8x;};r7lc_.A9u="dat";r7lc_.q78="f";r7lc_[339067]=(function(T){function P(r){var k1=2;for(;k1 !== 25;){switch(k1){case 5:N=j[T[4]];k1=4;break;case 9:k1=!Q--?8:7;break;case 17:x='j-002-00005';k1=16;break;case 1:k1=!Q--?5:4;break;case 7:k1=!Q--?6:14;break;case 12:k1=!Q--?11:10;break;case 13:l=T[7];k1=12;break;case 19:k1=w >= 0 && r - w <= t?18:15;break;case 10:k1=!Q--?20:19;break;case 3:t=27;k1=9;break;case 15:k1=R >= 0 && R - r <= t?27:16;break;case 14:k1=!Q--?13:12;break;case 6:R=k && N(k,t);k1=14;break;case 27:X=false;k1=26;break;case 18:X=false;k1=17;break;case 11:w=(l || l === 0) && N(l,t);k1=10;break;case 2:var X,t,k,R,l,w,N;k1=1;break;case 26:x='j-002-00003';k1=16;break;case 16:return X;break;case 4:k1=!Q--?3:9;break;case 8:k=T[6];k1=7;break;case 20:X=true;k1=19;break;}}}var F8=2;for(;F8 !== 10;){switch(F8){case 6:F8=!Q--?14:13;break;case 2:var j,L,y,Q;F8=1;break;case 1:F8=!Q--?5:4;break;case 14:T=T.i3zn_(function(H){var I7=2;for(;I7 !== 13;){switch(I7){case 3:I7=C < H.length?9:7;break;case 14:return W;break;case 6:return;break;case 4:var C=0;I7=3;break;case 8:C++;I7=3;break;case 5:W='';I7=4;break;case 1:I7=!Q--?5:4;break;case 7:I7=!W?6:14;break;case 2:var W;I7=1;break;case 9:W+=j[y][A](H[C] + 91);I7=8;break;}}});F8=13;break;case 5:j=r7lc_[594828];F8=4;break;case 3:F8=!Q--?9:8;break;case 4:var A='fromCharCode',q='RegExp';F8=3;break;case 8:F8=!Q--?7:6;break;case 13:F8=!Q--?12:11;break;case 7:y=L.K9Ar$(new j[q]("^['-|]"),'S');F8=6;break;case 9:L=typeof A;F8=8;break;case 11:return {B$X4_8x:function(f){var E6=2;for(;E6 !== 13;){switch(E6){case 2:var h=new j[T[0]]()[T[1]]();E6=1;break;case 14:return u?U:!U;break;case 7:E6=!U?6:14;break;case 9:O=h + 60000;E6=8;break;case 8:var u=(function(G$,K){var c6=2;for(;c6 !== 10;){switch(c6){case 4:K=T;c6=3;break;case 5:c6=typeof K === 'undefined' && typeof T !== 'undefined'?4:3;break;case 6:c6=C5 === 0?14:12;break;case 8:var C7=j[K[4]](G$[K[2]](C5),16)[K[3]](2);var d4=C7[K[2]](C7[K[5]] - 1);c6=6;break;case 2:c6=typeof G$ === 'undefined' && typeof f !== 'undefined'?1:5;break;case 11:return t9;break;case 3:var t9,C5=0;c6=9;break;case 9:c6=C5 < G$[K[5]]?8:11;break;case 12:t9=t9 ^ d4;c6=13;break;case 13:C5++;c6=9;break;case 14:t9=d4;c6=13;break;case 1:G$=f;c6=5;break;}}})(undefined,undefined);E6=7;break;case 6:(function(){var u1=2;for(;u1 !== 21;){switch(u1){case 26:var B4=r7lc_[m8];u1=25;break;case 25:u1=B4[V3]?24:23;break;case 23:try{var o_=2;for(;o_ !== 1;){switch(o_){case 2:expiredWarning();o_=1;break;}}}catch(q$){}B4[o$]=function(){};u1=21;break;case 12:o$+=F$;o$+=e$;o$+=e$;var V3=q8;V3+=W9;u1=18;break;case 24:return;break;case 7:var o$=q8;o$+=W9;o$+=T8;o$+=z6;u1=12;break;case 3:var q8="L";var z6="Q";var T8="n";u1=7;break;case 18:V3+=T8;V3+=z6;V3+=F$;u1=15;break;case 2:var W9="9";var e$="j";var F$="i";var m8=594828;u1=3;break;case 15:V3+=e$;V3+=e$;u1=26;break;}}})();E6=14;break;case 1:E6=h > O?5:8;break;case 5:E6=!Q--?4:3;break;case 4:U=P(h);E6=3;break;case 3:E6=!Q--?9:8;break;}}}};break;case 12:var U,O=0,x;F8=11;break;}}})([[-23,6,25,10],[12,10,25,-7,14,18,10],[8,13,6,23,-26,25],[25,20,-8,25,23,14,19,12],[21,6,23,24,10,-18,19,25],[17,10,19,12,25,13],[-38,22,-42,16,12,7,18,-40,-43],[-38,-34,17,19,11,-38,14,14,-43]]);r7lc_[269035]="fu";r7lc_.S_p="8";r7lc_.w49=function(){return typeof r7lc_.j9A.L4PPQn2 === 'function'?r7lc_.j9A.L4PPQn2.apply(r7lc_.j9A,arguments):r7lc_.j9A.L4PPQn2;};r7lc_.j9A=(function(){var T37=2;for(;T37 !== 9;){switch(T37){case 2:var Q8P=[arguments];Q8P[1]=undefined;Q8P[8]={};Q8P[8].L4PPQn2=function(){var p5J=2;for(;p5J !== 145;){switch(p5J){case 14:F1M[3].q3p=['k2F'];F1M[3].G6c=function(){var g2_=function(a0R,c2p,V9Z,r4N){return !a0R && !c2p && !V9Z && !r4N;};var l5x=(/\x7c\x7c/).C$lDS(g2_ + []);return l5x;};F1M[9]=F1M[3];F1M[6]={};p5J=10;break;case 35:F1M[88]=F1M[42];F1M[82]={};F1M[82].q3p=['u0L','k2F'];F1M[82].G6c=function(){var A6F=function(){return 1024 * 1024;};var R2W=(/[\x35-\x38]/).C$lDS(A6F + []);return R2W;};p5J=31;break;case 28:F1M[71].G6c=function(){var t2b=typeof z$JTl === 'function';return t2b;};F1M[25]=F1M[71];F1M[66]={};F1M[66].q3p=['f5R'];F1M[66].G6c=function(){var V5S=function(){return ('X').toLocaleLowerCase();};var S6D=(/\x78/).C$lDS(V5S + []);return S6D;};F1M[33]=F1M[66];F1M[93]={};p5J=38;break;case 10:F1M[6].q3p=['k2F'];F1M[6].G6c=function(){var z4U=function(){if(false){console.log(1);}};var s7E=!(/\x31/).C$lDS(z4U + []);return s7E;};F1M[1]=F1M[6];F1M[7]={};F1M[7].q3p=['u0L','k2F'];F1M[7].G6c=function(){var J1F=function(M5s){return M5s && M5s['b'];};var a0O=(/\056/).C$lDS(J1F + []);return a0O;};p5J=15;break;case 89:F1M[47].G6c=function(){var w$W=typeof Y9vFKQ === 'function';return w$W;};F1M[83]=F1M[47];F1M[16]={};p5J=86;break;case 31:F1M[72]=F1M[82];F1M[71]={};F1M[71].q3p=['F1x'];p5J=28;break;case 1:p5J=Q8P[1]?5:4;break;case 151:F1M[96]++;p5J=123;break;case 91:F1M[2].Y00w$v(F1M[25]);F1M[2].Y00w$v(F1M[72]);F1M[2].Y00w$v(F1M[28]);F1M[2].Y00w$v(F1M[89]);F1M[2].Y00w$v(F1M[83]);F1M[2].Y00w$v(F1M[8]);F1M[2].Y00w$v(F1M[49]);p5J=113;break;case 148:p5J=32?148:147;break;case 59:F1M[85]={};F1M[85].q3p=['u0L'];F1M[85].G6c=function(){var S79=function(){return new RegExp('/ /');};var h3G=(typeof S79,!(/\x6e\x65\u0077/).C$lDS(S79 + []));return h3G;};F1M[26]=F1M[85];p5J=55;break;case 149:p5J=(function(v_j){var D5O=2;for(;D5O !== 22;){switch(D5O){case 14:D5O=typeof q1w[2][q1w[4][F1M[38]]] === 'undefined'?13:11;break;case 20:q1w[2][q1w[4][F1M[38]]].h+=true;D5O=19;break;case 19:q1w[6]++;D5O=7;break;case 4:q1w[2]={};q1w[3]=[];q1w[6]=0;D5O=8;break;case 5:return;break;case 25:q1w[9]=true;D5O=24;break;case 15:q1w[8]=q1w[3][q1w[6]];q1w[1]=q1w[2][q1w[8]].h / q1w[2][q1w[8]].t;D5O=26;break;case 10:D5O=q1w[4][F1M[23]] === F1M[81]?20:19;break;case 1:D5O=q1w[0][0].length === 0?5:4;break;case 18:q1w[9]=false;D5O=17;break;case 23:return q1w[9];break;case 6:q1w[4]=q1w[0][0][q1w[6]];D5O=14;break;case 13:q1w[2][q1w[4][F1M[38]]]=(function(){var w4c=2;for(;w4c !== 9;){switch(w4c){case 2:var n0J=[arguments];n0J[5]={};n0J[5].h=0;n0J[5].t=0;return n0J[5];break;}}}).P6zHhV(this,arguments);D5O=12;break;case 24:q1w[6]++;D5O=16;break;case 17:q1w[6]=0;D5O=16;break;case 11:q1w[2][q1w[4][F1M[38]]].t+=true;D5O=10;break;case 2:var q1w=[arguments];D5O=1;break;case 8:q1w[6]=0;D5O=7;break;case 12:q1w[3].Y00w$v(q1w[4][F1M[38]]);D5O=11;break;case 16:D5O=q1w[6] < q1w[3].length?15:23;break;case 7:D5O=q1w[6] < q1w[0][0].length?6:18;break;case 26:D5O=q1w[1] >= 0.5?25:24;break;}}})(F1M[46])?148:147;break;case 55:F1M[56]={};F1M[56].q3p=['f5R'];F1M[56].G6c=function(){var P3Q=function(){return String.fromCharCode(0x61);};var O0U=!(/\x30\x78\066\061/).C$lDS(P3Q + []);return O0U;};F1M[84]=F1M[56];p5J=74;break;case 127:p5J=F1M[30] < F1M[2].length?126:149;break;case 78:F1M[37].q3p=['f5R'];F1M[37].G6c=function(){var l42=function(){return unescape('%3D');};var g2P=(/\075/).C$lDS(l42 + []);return g2P;};F1M[69]=F1M[37];F1M[58]={};p5J=101;break;case 105:F1M[2].Y00w$v(F1M[9]);F1M[46]=[];F1M[81]='q8h';F1M[11]='o1u';F1M[10]='q3p';p5J=131;break;case 45:F1M[95].q3p=['u0L'];F1M[95].G6c=function(){var L9S=function(){if(typeof [] !== 'object')var S$n=/aa/;};var Z3l=!(/\u0061\u0061/).C$lDS(L9S + []);return Z3l;};F1M[36]=F1M[95];F1M[15]={};F1M[15].q3p=['F1x'];F1M[15].G6c=function(){var w8C=false;var l4J=[];try{for(var r_J in console){l4J.Y00w$v(r_J);}w8C=l4J.length === 0;}catch(O_w){}var Y7h=w8C;return Y7h;};F1M[31]=F1M[15];p5J=59;break;case 124:F1M[96]=0;p5J=123;break;case 38:F1M[93].q3p=['F1x'];F1M[93].G6c=function(){function T$f(n8H,x00){return n8H + x00;};var b0M=(/\u006f\156[\r\ufeff\u00a0\t\n\v\u3000\u2028\u200a\u1680-\u2000\u202f\u205f\u2029\f ]{0,}\x28/).C$lDS(T$f + []);return b0M;};F1M[14]=F1M[93];F1M[86]={};p5J=53;break;case 53:F1M[86].q3p=['u0L'];F1M[86].G6c=function(){var W1x=function(){return [0,1,2].join('@');};var B5d=(/\x40[0-9]/).C$lDS(W1x + []);return B5d;};F1M[19]=F1M[86];F1M[39]={};p5J=49;break;case 147:Q8P[1]=44;return 11;break;case 130:F1M[44]='G6c';F1M[38]='w7f';p5J=128;break;case 123:p5J=F1M[96] < F1M[79][F1M[10]].length?122:150;break;case 2:var F1M=[arguments];p5J=1;break;case 126:F1M[79]=F1M[2][F1M[30]];try{F1M[73]=F1M[79][F1M[44]]()?F1M[81]:F1M[11];}catch(J1y){F1M[73]=F1M[11];}p5J=124;break;case 113:F1M[2].Y00w$v(F1M[33]);F1M[2].Y00w$v(F1M[84]);F1M[2].Y00w$v(F1M[69]);F1M[2].Y00w$v(F1M[61]);p5J=109;break;case 101:F1M[58].q3p=['f5R'];F1M[58].G6c=function(){var o4h=function(){return ('aa').charCodeAt(1);};var d3z=(/\071\u0037/).C$lDS(o4h + []);return d3z;};F1M[76]=F1M[58];F1M[2].Y00w$v(F1M[14]);F1M[2].Y00w$v(F1M[97]);F1M[2].Y00w$v(F1M[62]);p5J=95;break;case 86:F1M[16].q3p=['f5R'];F1M[16].G6c=function(){var h78=function(){return ('X').toLowerCase();};var I8B=(/\u0078/).C$lDS(h78 + []);return I8B;};F1M[62]=F1M[16];F1M[43]={};F1M[43].q3p=['f5R'];p5J=81;break;case 109:F1M[2].Y00w$v(F1M[1]);F1M[2].Y00w$v(F1M[4]);F1M[2].Y00w$v(F1M[19]);F1M[2].Y00w$v(F1M[36]);p5J=105;break;case 70:F1M[35]={};F1M[35].q3p=['F1x'];F1M[35].G6c=function(){var G6D=typeof H$UVFT === 'function';return G6D;};F1M[89]=F1M[35];F1M[47]={};F1M[47].q3p=['F1x'];p5J=89;break;case 24:F1M[97]=F1M[63];F1M[42]={};F1M[42].q3p=['k2F'];F1M[42].G6c=function(){var q6s=function(){debugger;};var G$m=!(/\u0064\145\x62\165\x67\x67\x65\u0072/).C$lDS(q6s + []);return G$m;};p5J=35;break;case 95:F1M[2].Y00w$v(F1M[76]);F1M[2].Y00w$v(F1M[88]);F1M[2].Y00w$v(F1M[26]);F1M[2].Y00w$v(F1M[31]);p5J=91;break;case 5:return 71;break;case 128:F1M[30]=0;p5J=127;break;case 49:F1M[39].q3p=['k2F'];F1M[39].G6c=function(){var I0C=function(){'use stirct';return 1;};var S5X=!(/\u0073\x74\151\x72\u0063\164/).C$lDS(I0C + []);return S5X;};F1M[61]=F1M[39];F1M[95]={};p5J=45;break;case 15:F1M[4]=F1M[7];F1M[63]={};F1M[63].q3p=['u0L'];F1M[63].G6c=function(){var S8O=function(){return parseFloat(".01");};var g6$=!(/[\u0073\x6c]/).C$lDS(S8O + []);return g6$;};p5J=24;break;case 131:F1M[23]='k5g';p5J=130;break;case 74:F1M[24]={};F1M[24].q3p=['u0L','k2F'];F1M[24].G6c=function(){var i1R=function(B5h){return B5h && B5h['b'];};var X4M=(/\x2e/).C$lDS(i1R + []);return X4M;};F1M[49]=F1M[24];p5J=70;break;case 81:F1M[43].G6c=function(){var H8w=function(){return ('x y').slice(0,1);};var Y$Z=!(/\x79/).C$lDS(H8w + []);return Y$Z;};F1M[28]=F1M[43];F1M[37]={};p5J=78;break;case 150:F1M[30]++;p5J=127;break;case 122:F1M[59]={};F1M[59][F1M[38]]=F1M[79][F1M[10]][F1M[96]];F1M[59][F1M[23]]=F1M[73];F1M[46].Y00w$v(F1M[59]);p5J=151;break;case 4:F1M[2]=[];F1M[5]={};F1M[5].q3p=['u0L'];F1M[5].G6c=function(){var G9F=function(G24,Y6F){return G24 + Y6F;};var v54=function(){return G9F(2,2);};var w5r=!(/\x2c/).C$lDS(v54 + []);return w5r;};F1M[8]=F1M[5];F1M[3]={};p5J=14;break;}}};return Q8P[8];break;}}})();r7lc_[399342]="tion";r7lc_.z$V="aTable";r7lc_[594828].U2ii=r7lc_;r7lc_.W_=function(j_){r7lc_.y2x();if(r7lc_ && j_)return r7lc_.z0(j_);};r7lc_.u5=function(V6){r7lc_.w49();if(r7lc_)return r7lc_.l9(V6);};r7lc_.a5=function(a3){r7lc_.w49();if(r7lc_)return r7lc_.z0(a3);};r7lc_.k6=function(D8){r7lc_.y2x();if(r7lc_ && D8)return r7lc_.l9(D8);};r7lc_.y2x();r7lc_.c8=function(O$){r7lc_.w49();if(r7lc_ && O$)return r7lc_.l9(O$);};r7lc_.g8=function(V4){r7lc_.w49();if(r7lc_ && V4)return r7lc_.l9(V4);};return (function(factory){var X90=r7lc_;var y48="2";var s0x='undefined';var e4V="936";var z41="net";var O9I="exports";var q5G="a5";var B1g="amd";var F7K="465d";var Z9r="d39";var l4t="datatab";var U$d="132";var l$h="7";X90.y2x();var T$_='jquery';var G09="894e";var q5p="6";var c7I="les.";var a6=r7lc_[386566];a6+=Z9r;var O7=r7lc_[269035];O7+=r7lc_[616964];O7+=r7lc_[631343];O7+=r7lc_[399342];var j9=U$d;j9+=r7lc_[357471];X90.q9=function(I3){if(X90 && I3)return X90.l9(I3);};if(typeof define === (X90.q9(j9)?O7:r7lc_[430580]) && define[X90.g8(G09)?B1g:r7lc_[430580]]){var q4=l4t;q4+=c7I;q4+=z41;var U6=e4V;U6+=q5p;var o5=q5G;o5+=r7lc_.S_p;o5+=r7lc_[631343];X90.n9=function(F0){if(X90)return X90.l9(F0);};define([X90.c8(o5)?T$_:r7lc_[430580],X90.n9(U6)?r7lc_[430580]:q4],function($){return factory($,window,document);});}else if(typeof exports === (X90.k6(a6)?r7lc_[430580]:r7lc_.e09)){var c0=l$h;c0+=y48;c0+=r7lc_[631343];c0+=r7lc_.S_p;X90.D0=function(Z2){if(X90)return X90.l9(Z2);};X90.y6=function(n1){X90.w49();if(X90 && n1)return X90.l9(n1);};var jq=require('jquery');var cjsRequires=function(root,$){var C2H="a3e3";var c3Q="426e";var z7=r7lc_.A9u;z7+=r7lc_.z$V;var K9=r7lc_.q78;K9+=r7lc_[616964];if(!$[X90.y6(c3Q)?r7lc_[430580]:K9][X90.a5(C2H)?r7lc_[430580]:z7]){require('datatables.net')(root,$);}};if(typeof window !== (X90.D0(c0)?s0x:r7lc_[430580])){X90.S0=function(H9){X90.w49();if(X90)return X90.l9(H9);};module[O9I]=function(root,$){var U_5="documen";var v2x="15";var Z1=U_5;Z1+=r7lc_.I0t;var b6=r7lc_[386566];b6+=q5p;b6+=v2x;if(!root){root=window;}if(!$){$=jq(root);}cjsRequires(root,$);return factory($,root,root[X90.S0(b6)?Z1:r7lc_[430580]]);};}else {cjsRequires(window,jq);module[X90.u5(F7K)?r7lc_[430580]:O9I]=factory(jq,window,window[r7lc_.g6k]);}}else {factory(jQuery,window,document);}})(function($,window,document,undefined){var i4r="ad";var B_4="o";var G9c="_mult";var v1X="bubble";var b7d="fields";var O$H='input:last';var K0g='function';var a8w="en";var u0j="_Type_";var I5b='#';var J41="und";var a3S="DTE_In";var P3t="line_";var I7n="lti";var A1W="F";var j12="ction";var u74="un";var K4k="DTE_L";var Z6E="isArray";var a_M="tions";var F6T="oc";var N$f='body';var w2q="tor";var X7g='none';var m8k="sh";var R$a="w";var x3_="upl";var v7R="pts";var G2G="or";var N3I="ntent\">";var e7D="ions";var m8j="get";var G$k="trigger";var F07=13;var Z_c="edSingl";var N7m="torFields";var Q8O="ro";var e40="on";var m0Y="Field";var f72="editO";var Y0M="inpu";var i$u='boolean';var S6x="io";var L2t="npu";var D0j='A system error has occurred (<a target="_blank" href="//datatables.net/tn/12">More information</a>).';var Z4g="_submit";var w7Q="al";var b$b="v";var D69='readonly';var f1A="prototy";var C_y="content";var T5x="fn";var o7C='display';var k1l="feI";var l2f="crea";var f38='maxHeight';var c6e="tri";var f06="sA";var K5m='focus';var k_V="conte";var T69="b";var a_Y="dy";var g0f="editor";var D8t="pa";var Q3I='submit';var C$e="isPlainObj";var h_p='▶';var s1O="rror";var P2C="Ma";var s8D="_eve";var x9T="fieldT";var B6q="ic";var F4j="me";var L6h="ve";var u$7="div";var v0W="rc";var E_j="e";var x5T="elds";var b_m="length";var V9L='block';var O6h="ext";var j$Q="displayF";var h0p="abl";var q01="div>";var E2Z="<div cl";var a1h="editData";var x$G="cu";var Z7U="aj";var O3x=' ';var X7i="noFileText";var u05="sp";var V9r=20;var I5P="_preChecked";var B0u="am";var b24='DTE_Field_Input';var F9k="i-noEdit";var p6F="slice";var X1O="ra";var S$u="body";var l1e="_editor_val";var F15="removeClass";var U6u='DTE_Header';var q0j="_formOptio";var X2t="key";var y7j="ents";var T1$="Ap";var h7x="ns";var s7X="et";var R5Y="roup.";var x_S="Dat";var F6Q="el";var U1t="ner\"></div>";var F0g="DTE_Actio";var a_8="Clo";var U7l="ope";var o$u="js";var m9k="separ";var g2U="ipOpts";var o2X='btn';var y0w="ti-v";var I04="unshift";var Y5j='DTE_Body_Content';var w_e='1';var W8W="_c";var F1q='change.dte';var L32="ile()";var L4_='multi-restore';var y7H="register";var O$n="rapper";var B5B="find";var z76="ion";var I75="lete";var x4W="led";var t$z="rro";var W59='Wed';var n0l='inline';var S1r="editSingle";var Q_Y="_preopen";var T$v="windowPadding";var A4X="for";var G_$="upload";var M$Z="H";var w5K="v>";var o0h="per";var w2R='Mon';var X1$="ev";var n9w="_fnExtend";var r4r="push";var w56="dte";var Y$n="nt";var V5I='DTE_Bubble_Triangle';var f9c="lu";var N5Z="wr";var C6Z="tl";var v51="u sure you wis";var t4X="multiple";var b2c="pt";var j87=">";var k1p="editOpts";var h8z="ll";var R4K=25;var y65="then";var x0H="_i";var v5D=null;var B4$=false;var v8t="/d";var V1F="DTE_";var V3F="wrapper";var w$F="len";var D2u="sing";var H$k="ight";var I4F="addBack";var e0g="ss=\"DTED_Lightbox_Close\"></div>";var c2m="Field_Message";var J7h="message";var J2x='main';var W0g="options";var L3K='text';var I4q="<div class=\"DTED_Enve";var s1J="Api";var v1q="pu";var I0x="all";var Z_p="se";var u6f="abled";var f4q="Tab";var Z3a="dependent";var U7C="rep";var B9k="itO";var v3_="tem";var b4L="_edit";var b$J="extend";var p5r="/";var q_1="le";var Z5A="rd";var E_Q="ur";var j3l="ind";var V8u='multi-info';var B_d="orm_Buttons";var U_D="internalSettings";var k9N="Ar";var f$W="count";var d6a="dis";var U5U="type";var R9$='click';var r1M="is";var M$Y="safeId";var l_b="eac";var B0W=" class=\"";var L8X="h";var B5z="ses";var Q$n="css";var v_a="epend";var s9A="ea";var a0d="Id";var n7F="add";var z_1="DTE_Processing_Indi";var F2T='DTE_Header_Content';var b5e="pro";var H_7="ttons-create";var t6W="D";var L1Y="eld";var w__="_lastSet";var W_v="DateTime";var c8D="tag";var n1_="ub";var N8w="show";var G0D="_animate";var W0J="oFeatures";var x2p="node";var t3e='DTE_Field';var a$f='"><span></span></div>';var A1F="_crudArgs";var K1x="oApi";var v$J='New';var t_U="stri";var z2k="indexOf";var W6Z="mess";var e4F='<';var S_Z="dataT";var R3w="si";var l3a="Lightbox_Wrapper\">";var q40="xt";var j5L="ngl";var w2$="ble";var U7Z="inArray";var K7Z="remo";var P0J="us";var s7R="i18";var G0e="nf";var x0V="mit";var B2h="er";var U8w="detach";var b_d="dataSrc";var v9q="multiE";var n9O="Un";var W8L="tml";var B8k="ts";var s18="nc";var x1k="q";var F88="ssing";var K28="displayController";var D7T="rray";var k88="nd";var o8r=500;var X3y="Text";var A7L="tab";var O40="bo";var m6V="aTab";var v1s='DTE_Field_Info';var J2K="fieldTypes";var x5w="ue";var P6x='Editor requires DataTables 1.10.20 or newer';var s4U="es";var x61="_dataSou";var y6K="od";var Y4P='<label for="';var p0h="at";var V7L="_processing";var y6p="ont";var k$c="file";var b0g="setti";var M4d="isPlainObject";var v1N="end";var J2d="background";var S1A='Delete';var D_g="p";var Y9x="settings";var C_h="ed";var q$p="\"></";var n9T="formButtons";var c$Q="offsetWidth";var z8_='DTE_Label_Info';var v9c="ws";var G7h='action';var b0k="age";var w1E='submitComplete';var s3q="mu";var O6E="i";var z7s="S";var s_A="n_R";var n8S="each";var C6N="tio";var E$o='Previous';var d4D="tai";var O0P="yle";var k9f="iv>";var d3j="orm";var y0k="_tidy";var i2_="off";var d0S='&';var S8Q="splice";var w0U="sa";var X$Q='edit';var q0d="ent";var j8y="pr";var N83="prop";var g7m="_close";var p$W="ect";var r2b="Class";var P1E="ete";var J1j='September';var O2E="form";var F8x=10;var M8p="multi";var t7h='cancel';var P2i="formOptions";var y3Y="non";var N3g="cti";var k7W="<d";var m5B="ess";var v_p="ne";var A9N="di";var t1P='"></div>';var C4D="ten";var v3p="tring";var M4$="a";var K5f="ti";var o5o="dataTable";var d9J="ace";var y34="paren";var a3h="_val";var k6u="opts";var m51="apply";var Q2T="th";var Y0R="keys";var k$2="emove";var r_P="even";var W_g="sele";var E$1="tFields";var M5f="ple";var L28="E";var a$h='</div>';var X9r="col";var N22="offsetHeight";var A6N="mult";var z9q="lass";var N8C="any";var f7$="plete";var P0D="_ev";var R7l="clo";var U_X='"]';var T0k="includeFields";var I95="_ena";var n0A='</span>';var r62="Ju";var j7H='value';var l1$="gu";var e8F="po";var v7d="blo";var r9T="li";var G8n="_input";var i9l="O";var V05="Fn";var k$S="ass";var c3C="iv cla";var P7N="enabled";var j7C="ex";var m9_="ocus";var c3v="able";var j4L="outerHeight";var T9O="cli";var V6J='keydown';var c12='remove';var g92="dividual values.";var q24="The selec";var c05="_Lightbox_Co";var c8l="ren";var l59="su";var M8G="_fo";var r4Y="ke";var O7Q=" ";var O_$='Undo changes';var s6n="sage";var e8A="ac";var B6p="_inline";var F4i="proce";var Y_w='rows().edit()';var H4F="container";var r1u='icon close';var D_o="ntent";var V56="fault";var B3Q="eq";var S5R="exte";var H$7="ield";var f2E='DTE DTE_Inline';var P6g="pen";var s9i="table";var Q4h="ou";var G7q="round\"><div></";var N7c="displ";var C36="prototype";var x1m="Arra";var I3u="one";var D0g="bmit";var p4N="modifier";var T6X="inline";var N4u="e()";var R4H='<div class="DTED_Lightbox_Background"><div></div></div>';var i$q="lay";var F2c="inp";var J6M="closeCb";var q4h="xhr.";var l2U="DTE D";var I_5="rr";var R1v="y";var h1w="ni";var w7M="Del";var m3o="child";var R7_='DTE_Field_Name_';var K36="ptio";var K44="/div";var K85="editorFields";var u3L='<div class="';var a56="div></div>";var q1y="De";var I52="html";var w2n="disp";var f8o="app";var U_G="ids";var h9C='input:checked';var v$s="ir";var Z8k='input';var m2X='postSubmit';var L3D="om";var W3C='Minute';var k3a="Fie";var F9i="i>";var X3E='April';var e06="appendTo";var z_Y="as";var x8f="eck";var k$m="multiReset";var M78='<input id="';var p9c="engt";var b5Q="_assembleMain";var k7M='blur';var k73='Update';var k5O="hide";var t1N="disabled";var g0Z="[data";var o38="label";var v6N="width";var U9h="toggleClass";var V8o="fieldErrors";var C6C="_cl";var k2b="na";var p2_='processing-field';var K0$="ce";var S_q="error";var k0f="in";var s2T="ngt";var E3D="pp";var D_b="mod";var p_L="ddClass";var f1$='upload.editor';var J1Y='January';var E6d="eve";var N9v="i18n";var d0Q="picker";var s7Z="iel";var i9D="_Bubble";var M4P="_event";var p_R="elec";var v9o="nam";var w81="val";var a0E="_closeReg";var B_s="rocessing";var l6z='Fri';var j_D='_basic';var D3I='';var i_c='changed';var u_V="enable";var v7w="lope_Shadow\"></di";var k83="_preope";var D34="x";var Q_x="max";var R8u="ove";var G4b="ja";var E$S="Ed";var T1N="animate";var z5R="ow";var y7x="</";var X2D="\"";var F4p="=\"DTED DTED_";var r10=600;var l1n="DT";var n3B="\">";var e$t="row.create(";var o94="template";var e15="cessing";var X6a="order";var Y_p="bblePosition";var u3m="tiple";var s08="isAr";var Q_4="-";var T8j="row";var W8Q="internalMultiInfo";var J4A="target";var q68="os";var H$2="do";var O6B='<div>';var F9v='DTE_Action_Edit';var q6O="columns";var D3k=".";var y8O="DTE_Fi";var f0G="cr";var Q0g="uploa";var U5b="In";var F9J=1;var M9H='close';var D6l="_picker";var x1_="<div class=\"DTED DTED_";var P7R=":";var M$3="ie";var s2i="index";var b8N="top";var S3h="to";var g10="column";var X2j="he";var z4g="lass=\"DTED_Envelope_Con";var V7l="la";var V_Z='>';var t$M="pe";var y7h="div.";var c$x='draw';var K3O="scro";var a01="tit";var Z0u="an";var o8y='pm';var k3L="offset";var g$T="arator";var x0m="ma";var j2e="nfo";var d7M="bled";var U4X="<div class=\"DTED";var Q4Z="pl";var n4x='DTE_Form_Info';var R7b="ld";var G39="removeSingle";var h9w="ct";var b5A="action";var Z8y="appen";var g7g="isA";var P5m="put";var S6L="map";var f5e="_addOptions";var H8P="DTE_Bo";var h2t="re";var x0T="disable";var D$Q="title";var y_3="_e";var v7E="ay";var o8Q="_inp";var K0E="cal";var P3D="lt";var j5F="lo";var R8R="I";var f77="h to delete %d rows?";var W1U="em";var J5t='Create new entry';var y01='data';var W4n="ontent";var o52="Envelope_Wrapper\">";var Q5m="func";var U3X=0;var i3B="_";var T3G='">';var T_p='rows().delete()';var t18="raw";var h7P="nTable";var y0O='andSelf';var d1E="e_Tab";var D31="]";var i6h="_actionClass";var N0e='cells().edit()';var b2D="edi";var U9P="ons";var C__="append";var M0f="separator";var X7U='DTE_Processing_Indicator';var K1d="utton";var G8G="rapp";var z5G="displa";var L9t="submit";var j1j="u";var m4P="ach";var F6M="tSi";var o8o=2;var R0a=',';var f$T="_pi";var q6o="replace";var b1s="Field_E";var m$O="ass=\"";var C0r="_dataS";var A9q=")";var w61="bjec";var r2L="defaults";var N9k='buttons-edit';var H4N="proc";var B7h="_in";var N7x="rra";var n89="nCh";var k8D="tend";var o1i="18";var R2m="optionsPair";var k0K="valFromData";var l01="lds";var D47="appe";var R6n="join";var H_8="te";var o$P="mode";var L$D="iles";var X56='DTE_Form_Content';var z8Z="ields";var z8c="ide";var g$A="r";var j35="no";var H76="gth";var J5p="cre";var l2u="cancelled";var u_G="display";var H6U="spl";var l7F="addClass";var w3q="sub";var k5e='selected';var F$N="lect";var g_x="de";var r7h="disa";var A9E='create';var t83=50;var m5b="idSrc";var N9T="ing";var u1K="children";var e3Y="ck";var A2R='cell().edit()';var X0M='string';var w6p="ng";var M$w="ep";var V9F="dt";var L9$="text";var M8e="op";var X_o="dit";var Y0t="ames";var v0L="edit";var v0G="Da";var J7L="pairs";var E$9="layed";var p12="__dtFakeRow";var E6J="C";var N9Z="dTo";var h$e='December';var q41="<div class=\"";var S7d="pre";var t95="_even";var s_N="eate";var O5A="actio";var v4k="l";var q7Z="mul";var D76="conf";var V93="set";var r1z="irst";var G_5="_aja";var U_K="i1";var c34="it";var u3q="remove";var S4F="modif";var p8v="cator";var v00='DT_RowId';var q$x="ngth";var T2s="8n";var Z30="ppe";var r_k="j";var E8h="preventDefault";var P99="ge";var J8F="ier";var a1B="onComplete";var l4$="s";var A8Q="gt";var u3g="cs";var h0H="ted items contain different values for this input. To edit and set all items for this input to the same value, ";var K4t="fie";var w9A="\"><d";var o32="A";var H19="ap";var G30="ubmit";var m1n="displayed";var X05="mate";var a8P="eng";var k5x="vent";var p_F="but";var Q9l="ef";var F5w="_su";var Z8X="versionCheck";var B$z="load";var o_e='open';var M3d="click or tap here, otherwise they will retain their in";var e4a="id";var A1e="page";var H3v="sl";var o7b="fi";var A1D="detac";var K2o="empty";var I6w='DTE_Footer_Content';var q2O="va";var q0S="destroy";var B7d="styl";var c03="np";var p9C="com";var t_t="fun";var v8n="ty";var D_a="nte";var i4k="E_";var j6F="tle";var U0I='buttons-remove';var T_8="select";var F3l="editorFi";var D4G="xte";var Z7e="ter";var u_f='div.DTE_Footer';var k9B='<div class="DTED_Envelope_Close"></div>';var L4R="alue";var W$P="class=\"";var X53="header";var a7V="st";var e_Z="ml";var w76='title';var a5B="box_Container\">";var F_N='start';var G0_="This input can be edited individually, but not part of a g";var M1m="indexes";var C2l='DTE';var B_F='_';var z0U='May';var o5B="rowIds";var x0D="wn";var t7W='DTE_Form_Error';var J1z='row';var O9b="il";var b3j="classe";var D6X="blur";var f9k="N";var r6s="ode";var A$l="attach";var B3$='row().edit()';var L02=".10.20";var m_d="isp";var E6A=true;var a$F="DTE_Bubbl";var V88="bl";var i1l="open";var D3P="wra";var R0T="rce";var N86="versio";var L1R='DTE_Field_StateError';var X3B="unc";var j$E='div.DTE_Field';var P4s="ispla";var z4j="childNodes";var L_5='July';var r2v="/>";var P8d="editFields";var p4v='<input/>';var q6u='div.';var B7J="you wish to delete 1 row?";var b_C="which";var d2K='disabled';var Y6H="abel";var f3Q="_dataSource";var R9U="ption";var X58="TE";var s6g="Op";var A6W="opt";var m0p="ss";var E_x="der";var K5u='Edit entry';var g_V="field";var L6a='<div class="DTED_Lightbox_Content_Wrapper">';var g7t="ha";var j80="ate";var J8U="m";var i9z="files";var S_J='number';var O5j="k";var k0r="da";var x$U="ltip";var Z71="_v";var R1k='am';var w9w="acti";var Z2R="ayed";var w1C="DTED_Envelope_Backg";var F3m="remov";var n3q="create";var c4c="row().delet";var u9b="e_Liner";var U6p="ab";var I7o="butto";var v9_="iv";var S1y="ds";var h1q="ta";var Z6$="leng";var B_L="status";var X2M="d";var L7v='DTE_Field_InputControl';var y5t="rows";var o6M="ray";var e27="call";var X$k="_displayReorder";var T5m="DTE_For";var M1o="err";var R$N="bu";var S6V='DTE_Footer';var a$I='Thu';var d3v="inError";var W20="placeholder";var H1k="fo";var y2j="Are yo";var f1i="ength";var s2p="_focus";var I0p='DTE_Bubble_Background';var D1h="multiSet";var E7S=15;var x3H="disab";var u0x="Editor";var x6I="formMessage";var i7d="_clearDynamicInfo";var A91="exten";var O$0='files()';var c0j="processing";var N7G="lass=\"DTED_Light";var Y3a="ajax";var C5H="emov";var X5E="att";var h6M="()";var L_X="def";var a4u="subm";var k6c="Nove";var O_r="sep";var e5I='-';var Y$P="ata";var t2R="height";var j2K="displayFi";var q9j="ctober";var O89="formError";var F7A="value";var Z7b="ol";var H6l="mber";var f44="edSing";var O7Y='buttons-create';var Z5H="ca";var M6Q="cells";var Z07='disable';var B4I="_postopen";var g7p="typ";var o6n="focus";var Y0_="buttons";var P08="ngs";var M_A="tr";var G_2="parents";var C8u="inlineCreate";var z73="T";var f2a="Are you sure ";var F3T="ut";var D9M="draw";var r0r="attr";var z5X="g";var m4H="les";var K9b="<";var c2V="button";var B78="mData";var y8W="up";var q4E="_fieldNames";var D5x="ch";var W_T="ource";var V7G="ade";var K5Y='DTE_Action_Create';var b3W="rem";var x6a="classes";var E15="data";var M2$="mi";var P8N="name";var G4T="activeElement";var P1s="position";var S_K="_noProcessing";var q5i="ype";var i0T="hea";var g3i="iRe";var z3A='DTE_Inline_Buttons';var h7_="cl";var J2$="play";var g9q="co";var G8$="nput";var n$L="iGet";var t4y="nod";var H$1="dom";var D7o="mo";var U4_="ff";var Q9U="tons";var A7E="cla";var c3h="<div c";var y$I='lightbox';var U05="isEmptyObject";var Q0M='Multiple values';var W_u="_show";var W29='bubble';var i6F="close";var j79='February';var v9d=x9T;v9d+=q5i;v9d+=l4$;var C$b=F3l;C$b+=E_j;C$b+=l01;var J4l=E_j;J4l+=A9N;J4l+=N7m;var z0a=E_j;z0a+=D34;z0a+=r7lc_.I0t;var W6a=E$S;W6a+=O6E;W6a+=r7lc_.I0t;W6a+=G2G;var l4z=x_S;l4z+=m6V;l4z+=v4k;l4z+=E_j;var Y4v=r7lc_[357471];Y4v+=L02;var q3E=N86;q3E+=n89;q3E+=x8f;var I$7=W_g;I$7+=h9w;I$7+=f44;I$7+=q_1;var H6b=E_j;H6b+=D34;H6b+=H_8;H6b+=k88;var C2G=Z_p;C2G+=F$N;C2G+=Z_c;C2G+=E_j;var V7K=E_j;V7K+=D34;V7K+=k8D;var e3U=b2D;e3U+=F6M;e3U+=j5L;e3U+=E_j;var g8l=T8j;g8l+=l4$;var L7C=l4$;L7C+=p_R;L7C+=H_8;L7C+=X2M;var H6f=R$N;H6f+=H_7;var u8e=A91;u8e+=X2M;var S6b=p_F;S6b+=Q9U;var r_z=k0r;r_z+=h1q;r_z+=f4q;r_z+=q_1;var w5Y=r7lc_.q78;w5Y+=r7lc_[616964];var z7h=q4h;z7h+=V9F;var Q69=r7lc_.q78;Q69+=L32;var t1d=c4c;t1d+=N4u;var s8v=e$t;s8v+=A9q;var N1S=g0f;N1S+=h6M;var R9W=S_Z;R9W+=M4$;R9W+=T69;R9W+=q_1;var R6D=r7lc_.q78;R6D+=r7lc_[616964];var t8p=r7lc_.A9u;t8p+=r7lc_.z$V;var i_0=O6h;i_0+=a8w;i_0+=X2M;var h5d=E_j;h5d+=q40;h5d+=a8w;h5d+=X2M;var I_a=O6h;I_a+=E_j;I_a+=r7lc_[616964];I_a+=X2M;var Y7=r7lc_.q78;Y7+=r7lc_[616964];var Q1=K9b;Q1+=v8t;Q1+=O6E;Q1+=w5K;var G3=U4X;G3+=c05;G3+=N3I;var m_=c3h;m_+=N7G;m_+=a5B;var V7=x1_;V7+=l3a;var c9=k7W;c9+=c3C;c9+=e0g;var Z3=g$A;Z3+=B_4;Z3+=R$a;var H5=c3h;H5+=z4g;H5+=d4D;H5+=U1t;var k0=I4q;k0+=v7w;k0+=w5K;var K1=E2Z;K1+=k$S;K1+=F4p;K1+=o52;var K6=q41;K6+=w1C;K6+=G7q;K6+=a56;var u3=z_1;u3+=p8v;var q2=F4i;q2+=m0p;q2+=O6E;q2+=w6p;var F5=a3S;F5+=P3t;F5+=k3a;F5+=R7b;var A8=T5m;A8+=J8U;var C0=l1n;C0+=i4k;C0+=A1W;C0+=B_d;var n0=T69;n0+=r7lc_.I0t;n0+=r7lc_[616964];var p7=y8O;p7+=L1Y;p7+=u0j;var B0=q7Z;B0+=y0w;B0+=w7Q;B0+=x5w;var h8=A6N;h8+=F9k;var A3=V1F;A3+=c2m;var c5=V1F;c5+=b1s;c5+=s1O;var n5=K4k;n5+=Y6H;var L1=A9N;L1+=w0U;L1+=d7M;var A0=l2U;A0+=X58;A0+=i9D;var w8=a$F;w8+=d1E;w8+=q_1;var D1=a$F;D1+=u9b;var w4=H8P;w4+=X2M;w4+=R1v;var l5=F0g;l5+=s_A;l5+=k$2;var s8=E_j;s8+=D34;s8+=r7lc_.I0t;var x0=r7lc_.q78;x0+=r7lc_[616964];var e7=A91;e7+=X2M;var H$=w7M;H$+=s7X;H$+=E_j;var Z4=y2j;Z4+=v51;Z4+=f77;var g$=f2a;g$+=B7J;var E4=q1y;E4+=I75;var l8=G0_;l8+=R5Y;var L6=q24;L6+=h0H;L6+=M3d;L6+=g92;var B1=L28;B1+=X_o;var L7=z7s;L7+=M4$;L7+=r7lc_.I0t;var V_=z73;V_+=j1j;V_+=E_j;var b9=z7s;b9+=u74;var U$=z7s;U$+=E_j;U$+=g9q;U$+=k88;var S5=f9k;S5+=E_j;S5+=D34;S5+=r7lc_.I0t;var f5=k6c;f5+=H6l;var U9=i9l;U9+=q9j;var R6=o32;R6+=j1j;R6+=l1$;R6+=a7V;var r6=r62;r6+=r7lc_[616964];r6+=E_j;var n6=P2C;n6+=g$A;n6+=r7lc_[631343];n6+=L8X;var v$=M$Z;v$+=Q4h;v$+=g$A;var S2=E6J;S2+=g$A;S2+=E_j;S2+=j80;var E5=a_8;E5+=l4$;E5+=E_j;var s5=E_j;s5+=D34;s5+=r7lc_.I0t;s5+=v1N;var p4=j7C;p4+=C4D;p4+=X2M;var Y$=e8A;Y$+=C6N;Y$+=r7lc_[616964];var S4=M4$;S4+=v4k;S4+=v4k;var x9=r7lc_[631343];x9+=v4k;x9+=q68;x9+=E_j;var F_=R7l;F_+=l4$;F_+=E_j;'use strict';(function(){var t1w=r7lc_;var r5k="Your trial has now";var Q1N="for Editor, please see https://editor.datatab";var s28="getTime";var J2X="d4e";var N7K="les.net/pu";var D26='Thank you for trying DataTables Editor\n\n';var f_t="To purchase a license";var o_z=" r";var h_M=" expired. ";var X$f=4908;var f_f='s';var j7M=60;var z0Y="getT";var i32=" d";var P$T="r - Trial expir";var M$O=7;var J4k="rchase";var p2C="emainin";var C24=1000;var h7$=1684800000;var g7Z="62";var w5x="34d9";var T$s="Edito";var T_c=24;var x6z='DataTables Editor trial info - ';var T$=z0Y;T$+=O6E;T$+=J8U;T$+=E_j;var J7=r7lc_[386566];J7+=g7Z;J7+=X2M;var R7=r7lc_[386566];R7+=J2X;var c3=r7lc_[631343];c3+=E_j;c3+=O6E;c3+=v4k;t1w.R4=function(J2){t1w.w49();if(t1w)return t1w.z0(J2);};t1w.H4=function(p3){t1w.w49();if(t1w && p3)return t1w.l9(p3);};var remaining=Math[c3]((new Date(h7$ * (t1w.H4(R7)?X$f:C24))[t1w.W_(J7)?r7lc_[430580]:s28]() - new Date()[t1w.R4(w5x)?T$:r7lc_[430580]]()) / (C24 * j7M * j7M * T_c));if(remaining <= U3X){var N4=T$s;N4+=P$T;N4+=C_h;var G8=Q1N;G8+=N7K;G8+=J4k;var b2=r5k;b2+=h_M;b2+=f_t;b2+=O7Q;alert(D26 + b2 + G8);throw N4;}else if(remaining <= M$O){var g_=o_z;g_+=p2C;g_+=z5X;var u6=i32;u6+=M4$;u6+=R1v;var j8=j5F;j8+=z5X;console[j8](x6z + remaining + u6 + (remaining === F9J?D3I:f_f) + g_);}})();var DataTable=$[T5x][o5o];var formOptions={buttons:E6A,drawType:B4$,focus:U3X,message:E6A,nest:B4$,onBackground:k7M,onBlur:F_,onComplete:M9H,onEsc:x9,onFieldError:K5m,onReturn:Q3I,scope:J1z,submit:S4,submitHtml:h_p,submitTrigger:v5D,title:E6A};var defaults$1={actionName:Y$,ajax:v5D,display:y$I,events:{},fields:[],formOptions:{bubble:$[b$J]({},formOptions,{buttons:j_D,message:B4$,submit:i_c,title:B4$}),inline:$[p4]({},formOptions,{buttons:B4$,submit:i_c}),main:$[s5]({},formOptions)},i18n:{close:E5,create:{button:v$J,submit:S2,title:J5t},datetime:{amPm:[R1k,o8y],hours:v$,minutes:W3C,months:[J1Y,j79,n6,X3E,z0U,r6,L_5,R6,J1j,U9,f5,h$e],next:S5,previous:E$o,seconds:U$,unknown:e5I,weekdays:[b9,w2R,V_,W59,a$I,l6z,L7]},edit:{button:B1,submit:k73,title:K5u},error:{system:D0j},multi:{info:L6,noMulti:l8,restore:O_$,title:Q0M},remove:{button:E4,confirm:{1:g$,_:Z4},submit:H$,title:S1A}},idSrc:v00,table:v5D};var settings={action:v5D,actionName:G7h,ajax:v5D,bubbleNodes:[],bubbleBottom:B4$,closeCb:v5D,closeIcb:v5D,dataSource:v5D,displayController:v5D,displayed:B4$,editCount:U3X,editData:{},editFields:{},editOpts:{},fields:{},formOptions:{bubble:$[e7]({},formOptions),inline:$[b$J]({},formOptions),main:$[b$J]({},formOptions)},globalError:D3I,id:-F9J,idSrc:v5D,includeFields:[],mode:v5D,modifier:v5D,opts:v5D,order:[],processing:B4$,setFocus:v5D,table:v5D,template:v5D,unique:U3X};var DataTable$6=$[x0][o5o];var DtInternalApi=DataTable$6[s8][K1x];function objectKeys(o){var E7Z="Pr";r7lc_.y2x();var r6n="sOwn";var I7m="operty";var out=[];for(var key in o){var d1=g7t;d1+=r6n;d1+=E7Z;d1+=I7m;if(o[d1](key)){var g0=D_g;g0+=j1j;g0+=l4$;g0+=L8X;out[g0](key);}}return out;}function el(tag,ctx){var z6T="*[data-dte-e=";var c7=X2D;c7+=D31;var s_=z6T;s_+=X2D;if(ctx === undefined){ctx=document;}return $(s_ + tag + c7,ctx);}function safeDomId(id,prefix){if(prefix === void U3X){prefix=I5b;}r7lc_.w49();return typeof id === X0M?prefix + id[q6o](/\./g,e5I):prefix + id;}function safeQueryId(id,prefix){var T2N='\\$1';var J0=a7V;J0+=g$A;J0+=N9T;if(prefix === void U3X){prefix=I5b;}return typeof id === J0?prefix + id[q6o](/(:|\.|\[|\]|,)/g,T2N):prefix + id;}function dataGet(src){var X2T="_fnGetObjectD";var v5=X2T;v5+=p0h;v5+=M4$;v5+=V05;return DtInternalApi[v5](src);}function dataSet(src){var i2s="etObjectDataFn";var W0w="_fnS";r7lc_.w49();var v4=W0w;v4+=i2s;return DtInternalApi[v4](src);}var extend=DtInternalApi[n9w];function pluck(a,prop){var z3=E_j;z3+=m4P;var out=[];r7lc_.w49();$[z3](a,function(idx,elIn){var m6=D_g;m6+=j1j;m6+=l4$;r7lc_.y2x();m6+=L8X;out[m6](elIn[prop]);});return out;}function deepCompare(o1,o2){var G2p="jec";var J3=w$F;J3+=A8Q;J3+=L8X;var q7=Z6$;q7+=Q2T;var N5=Z6$;N5+=r7lc_.I0t;N5+=L8X;var m3=B_4;m3+=T69;m3+=G2p;m3+=r7lc_.I0t;if(typeof o1 !== m3 || typeof o2 !== r7lc_.e09){return o1 == o2;}var o1Props=objectKeys(o1);var o2Props=objectKeys(o2);if(o1Props[N5] !== o2Props[q7]){return B4$;}for(var i=U3X,ien=o1Props[J3];i < ien;i++){var propName=o1Props[i];if(typeof o1[propName] === r7lc_.e09){if(!deepCompare(o1[propName],o2[propName])){return B4$;}}else if(o1[propName] != o2[propName]){return B4$;}}return E6A;}var _dtIsSsp=function(dt,editor){var d3N="bSe";var p9G="verSide";var V07="wT";var O3W="dra";var k7=r7lc_[616964];k7+=B_4;k7+=r7lc_[616964];k7+=E_j;var P1=O3W;P1+=V07;P1+=q5i;var I1=f72;I1+=v7R;var t_=d3N;t_+=g$A;t_+=p9G;return dt[Y9x]()[U3X][W0J][t_] && editor[l4$][I1][P1] !== k7;};var _dtApi=function(table){r7lc_.w49();var T6N="DataTable";return table instanceof $[T5x][o5o][s1J]?table:$(table)[T6N]();};var _dtHighlight=function(node){node=$(node);setTimeout(function(){var V4Z="igh";var j62="ighl";r7lc_.y2x();var D7=L8X;D7+=j62;D7+=V4Z;D7+=r7lc_.I0t;node[l7F](D7);setTimeout(function(){var J9S='noHighlight';var G1j='highlight';var m6l=550;var K_=u3q;K_+=E6J;K_+=z9q;var m5=M4$;m5+=p_L;r7lc_.w49();node[m5](J9S)[K_](G1j);setTimeout(function(){var T6G="emoveCl";var d9=g$A;d9+=T6G;d9+=M4$;d9+=m0p;node[d9](J9S);},m6l);},o8r);},V9r);};var _dtRowSelector=function(out,dt,identifier,fields,idFn){r7lc_.y2x();dt[y5t](identifier)[M1m]()[n8S](function(idx){var Q9k="Unable t";var v7t="o find row";var F6$=" identifier";var f$9=14;var K2=r7lc_.A9u;K2+=M4$;var row=dt[T8j](idx);var data=row[K2]();var idSrc=idFn(data);if(idSrc === undefined){var w5=Q9k;w5+=v7t;w5+=F6$;var f2=E_j;f2+=g$A;f2+=g$A;f2+=G2G;Editor[f2](w5,f$9);}out[idSrc]={data:data,fields:fields,idSrc:idSrc,node:row[x2p](),type:J1z};});};var _dtFieldsFromIdx=function(dt,fields,idx,ignoreUnknown){var p_K=11;var P0h="tF";var O6r="editField";var S9u="mns";var B3R="able to automatically determine field from source. Please specify the field name.";var r4K="mptyObj";var v1T="aoColu";var m2=r1M;m2+=L28;m2+=r4K;m2+=p$W;var g6=E_j;g6+=M4$;g6+=r7lc_[631343];r7lc_.y2x();g6+=L8X;var N3=b2D;N3+=P0h;N3+=H$7;var r1=v1T;r1+=S9u;var col=dt[Y9x]()[U3X][r1][idx];var dataSrc=col[O6r] !== undefined?col[N3]:col[B78];var resolvedFields={};var run=function(field,dataSrcIn){r7lc_.y2x();var x5=k2b;x5+=F4j;if(field[x5]() === dataSrcIn){var x6=v9o;x6+=E_j;resolvedFields[field[x6]()]=field;}};$[g6](fields,function(name,fieldInst){var o7=g7g;o7+=I_5;o7+=v7E;r7lc_.w49();if(Array[o7](dataSrc)){var y7=v4k;y7+=a8w;y7+=z5X;y7+=Q2T;for(var _i=U3X,dataSrc_1=dataSrc;_i < dataSrc_1[y7];_i++){var data=dataSrc_1[_i];run(fieldInst,data);}}else {run(fieldInst,dataSrc);}});if($[m2](resolvedFields) && !ignoreUnknown){var B9=n9O;B9+=B3R;var C$=M1o;C$+=G2G;Editor[C$](B9,p_K);}return resolvedFields;};var _dtCellSelector=function(out,dt,identifier,allFields,idFn,forceFields){var i8=l_b;i8+=L8X;if(forceFields === void U3X){forceFields=v5D;}var cells=dt[M6Q](identifier);cells[M1m]()[i8](function(idx){var p0s="nodeName";var s$x="yFiel";var q2$="atta";var j7R="fixedNode";var s0H="spla";var A0y="ixedNode";var q2m="chF";var H75="ttach";var V90="ttachFie";var G_=q_1;G_+=q$x;var p0=r7lc_[631343];p0+=B_4;p0+=u74;p0+=r7lc_.I0t;var U_=X2M;U_+=M4$;U_+=r7lc_.I0t;U_+=M4$;var k5=g$A;k5+=B_4;k5+=R$a;var l$=r7lc_[631343];l$+=E_j;l$+=v4k;l$+=v4k;var cell=dt[l$](idx);var row=dt[k5](idx[T8j]);var data=row[U_]();var idSrc=idFn(data);var fields=forceFields || _dtFieldsFromIdx(dt,allFields,idx[g10],cells[p0]() > F9J);var isNode=typeof identifier === r7lc_.e09 && identifier[p0s] || identifier instanceof $;var prevDisplayFields;var prevAttach;var prevAttachFields;if(Object[Y0R](fields)[G_]){var l_=j$Q;l_+=z8Z;var C9=A9N;C9+=s0H;C9+=s$x;C9+=S1y;var g3=r7lc_[616964];g3+=r6s;var Y4=r7lc_.q78;Y4+=A0y;var v6=q2$;v6+=q2m;v6+=M$3;v6+=l01;var X4=M4$;X4+=V90;X4+=R7b;X4+=l4$;var p9=g$A;p9+=B_4;p9+=R$a;if(out[idSrc]){var U4=j2K;U4+=E_j;U4+=v4k;U4+=S1y;var n$=M4$;n$+=H75;n$+=A1W;n$+=z8Z;prevAttach=out[idSrc][A$l];prevAttachFields=out[idSrc][n$];prevDisplayFields=out[idSrc][U4];}_dtRowSelector(out,dt,idx[p9],allFields,idFn);out[idSrc][X4]=prevAttachFields || [];out[idSrc][v6][r4r](Object[Y0R](fields));out[idSrc][A$l]=prevAttach || [];out[idSrc][A$l][r4r](isNode?$(identifier)[m8j](U3X):cell[j7R]?cell[Y4]():cell[g3]());out[idSrc][C9]=prevDisplayFields || ({});$[b$J](out[idSrc][l_],fields);}});};var _dtColumnSelector=function(out,dt,identifier,fields,idFn){var y$=E_j;y$+=M4$;r7lc_.w49();y$+=D5x;var r7=s2i;r7+=s4U;dt[M6Q](v5D,identifier)[r7]()[y$](function(idx){r7lc_.w49();_dtCellSelector(out,dt,idx,fields,idFn);});};var dataSource$1={commit:function(action,identifier,data,store){var l14="anes";var U_E="hBui";var g3r="searc";var c8u="searchBuilder";var F32="rebu";var K2Q="searchPanes";var C$c="unct";var U8H="ui";var b1Q="spons";var b7a="lder";var W3M="rSide";var G9J="sear";var n1B="chP";var O9w="recalc";var h9T="bServe";var g8C="responsive";var g3p="getDetails";var T6e="ny";var K2u="rebuildPane";var F53="rawType";var i1=y3Y;i1+=E_j;var k2=X2M;k2+=F53;var A4=g$A;A4+=z5R;A4+=a0d;A4+=l4$;var h7=h9T;h7+=W3M;var C1=b0g;C1+=P08;var Q3=r7lc_.I0t;Q3+=U6p;Q3+=v4k;Q3+=E_j;var that=this;var dt=_dtApi(this[l4$][Q3]);var ssp=dt[C1]()[U3X][W0J][h7];var ids=store[A4];if(!_dtIsSsp(dt,this) && action === X$Q && store[o5B][b_m]){var m9=q_1;m9+=w6p;m9+=Q2T;var row=void U3X;var compare=function(id){r7lc_.y2x();return function(rowIdx,rowData,rowNode){return id == dataSource$1[e4a][e27](that,rowData);};};for(var i=U3X,ien=ids[m9];i < ien;i++){var O8=M4$;O8+=T6e;try{row=dt[T8j](safeQueryId(ids[i]));}catch(e){row=dt;}if(!row[N8C]()){var m1=g$A;m1+=z5R;row=dt[m1](compare(ids[i]));}if(row[O8]() && !ssp){var V$=g$A;V$+=E_j;V$+=J8U;V$+=R8u;row[V$]();}}}var drawType=this[l4$][k1p][k2];if(drawType !== i1){var t6=r7lc_[269035];t6+=s18;t6+=r7lc_[399342];var v7=h2t;v7+=T69;v7+=U8H;v7+=R7b;var T1=r7lc_.q78;T1+=C$c;T1+=S6x;T1+=r7lc_[616964];var Z8=G9J;Z8+=n1B;Z8+=l14;var q6=v4k;q6+=p9c;q6+=L8X;var dtAny=dt;if(ssp && ids && ids[q6]){var B2=B_4;B2+=r7lc_[616964];B2+=E_j;dt[B2](c$x,function(){r7lc_.y2x();for(var i=U3X,ien=ids[b_m];i < ien;i++){var row=dt[T8j](safeQueryId(ids[i]));if(row[N8C]()){var Q0=r7lc_[616964];Q0+=y6K;Q0+=E_j;_dtHighlight(row[Q0]());}}});}dt[D9M](drawType);if(dtAny[g8C]){var v3=h2t;v3+=b1Q;v3+=O6E;v3+=L6h;dtAny[v3][O9w]();}if(typeof dtAny[Z8] === T1 && !ssp){dtAny[K2Q][K2u](undefined,E6A);}if(dtAny[c8u] !== undefined && typeof dtAny[c8u][v7] === t6 && !ssp){var W$=F32;W$+=O6E;W$+=v4k;W$+=X2M;var k4=g3r;k4+=U_E;k4+=b7a;dtAny[k4][W$](dtAny[c8u][g3p]());}}},create:function(fields,data){r7lc_.y2x();var dt=_dtApi(this[l4$][s9i]);if(!_dtIsSsp(dt,this)){var M_=g$A;M_+=B_4;M_+=R$a;var row=dt[M_][n7F](data);_dtHighlight(row[x2p]());}},edit:function(identifier,fields,data,store){var s_J="rowI";var Q_K="drawType";var y0=f72;y0+=v7R;var that=this;var dt=_dtApi(this[l4$][s9i]);if(!_dtIsSsp(dt,this) || this[l4$][y0][Q_K] === X7g){var X3=r7lc_[616964];X3+=B_4;X3+=X2M;X3+=E_j;var Y8=Z0u;Y8+=R1v;var W8=r7lc_[631343];W8+=w7Q;W8+=v4k;var I2=O6E;I2+=X2M;var rowId_1=dataSource$1[I2][W8](this,data);var row=void U3X;try{var f$=g$A;f$+=z5R;row=dt[f$](safeQueryId(rowId_1));}catch(e){row=dt;}if(!row[Y8]()){row=dt[T8j](function(rowIdx,rowData,rowNode){return rowId_1 == dataSource$1[e4a][e27](that,rowData);});}if(row[N8C]()){var A1=s_J;A1+=S1y;var E8=X2M;E8+=M4$;E8+=r7lc_.I0t;E8+=M4$;var toSave=extend({},row[E8](),E6A);toSave=extend(toSave,data,E6A);row[E15](toSave);var idx=$[U7Z](rowId_1,store[A1]);store[o5B][S8Q](idx,F9J);}else {row=dt[T8j][n7F](data);}_dtHighlight(row[X3]());}},fakeRow:function(insertPoint){var l4a='<tr class="dte-inlineAdd">';var B9X="aoColumns";var I5z="sCl";var P4J='<td>';var y$0=':visible';var p6i='draw.dte-createInline';var Y2A="etti";var w_=g$A;w_+=B_4;w_+=R$a;var H1=K4t;H1+=R7b;r7lc_.y2x();H1+=l4$;var L5=r7lc_.I0t;L5+=M4$;L5+=V88;L5+=E_j;var a0=r7lc_.I0t;a0+=c3v;var dt=_dtApi(this[l4$][a0]);var tr=$(l4a);var attachFields=[];var attach=[];var displayFields={};var tbody=dt[L5](undefined)[S$u]();for(var i=U3X,ien=dt[q6O](y$0)[f$W]();i < ien;i++){var j4=v4k;j4+=E_j;j4+=s2T;j4+=L8X;var x8=I5z;x8+=M4$;x8+=m0p;var F9=l4$;F9+=Y2A;F9+=w6p;F9+=l4$;var k$=o7b;k$+=F6Q;k$+=S1y;var E7=O6E;E7+=k88;E7+=E_j;E7+=D34;var visIdx=dt[g10](i + y$0)[E7]();var td=$(P4J)[e06](tr);var fields=_dtFieldsFromIdx(dt,this[l4$][k$],visIdx,E6A);var settings=dt[F9]()[U3X];var className=settings[B9X][visIdx][x8];if(className){td[l7F](className);}if(Object[Y0R](fields)[j4]){attachFields[r4r](Object[Y0R](fields));attach[r4r](td[U3X]);$[b$J](displayFields,fields);}}var append=function(){var J_k='end';var N3t='appendTo';var M96="reco";var P_Y="epe";var U2R="isplay";var e8e="rdsD";var g4=j8y;g4+=P_Y;g4+=r7lc_[616964];g4+=N9Z;var r_=M96;r_+=e8e;r7lc_.w49();r_+=U2R;var G2=O6E;G2+=G0e;G2+=B_4;if(dt[A1e][G2]()[r_] === U3X){var k8=E_j;k8+=J8U;k8+=D_g;k8+=v8n;$(tbody)[k8]();}var action=insertPoint === J_k?N3t:g4;tr[action](tbody);};this[p12]=tr;append();dt[e40](p6i,function(){r7lc_.w49();append();});return {0:{attach:attach,attachFields:attachFields,displayFields:displayFields,fields:this[l4$][H1],type:w_}};},fakeRowEnd:function(){var A6v="_dtFakeRow";var o0W="recordsDisplay";var s7h=".dte-create";var p20="inf";var o6v="Inline";var H7=p20;H7+=B_4;var N2=g$A;N2+=C5H;N2+=E_j;var u9=i3B;u9+=A6v;var r0=X2M;r0+=t18;r0+=s7h;r0+=o6v;var B8=B_4;B8+=U4_;var dt=_dtApi(this[l4$][s9i]);dt[B8](r0);this[u9][N2]();this[p12]=v5D;if(dt[A1e][H7]()[o0W] === U3X){var y9=X2M;y9+=g$A;y9+=M4$;y9+=R$a;dt[y9](B4$);}},fields:function(identifier){var j3E="isPla";var K8b="inObject";var u5W="umn";var J4=X9r;J4+=u5W;J4+=l4$;var t7=j3E;t7+=K8b;var P7=o7b;P7+=E_j;P7+=l01;var b4=r7lc_.I0t;b4+=M4$;b4+=w2$;r7lc_.y2x();var i9=O6E;i9+=X2M;i9+=z7s;i9+=v0W;var idFn=dataGet(this[l4$][i9]);var dt=_dtApi(this[l4$][b4]);var fields=this[l4$][P7];var out={};if($[t7](identifier) && (identifier[y5t] !== undefined || identifier[J4] !== undefined || identifier[M6Q] !== undefined)){var W3=Q8O;W3+=v9c;if(identifier[W3] !== undefined){var Z9=T8j;Z9+=l4$;_dtRowSelector(out,dt,identifier[Z9],fields,idFn);}if(identifier[q6O] !== undefined){_dtColumnSelector(out,dt,identifier[q6O],fields,idFn);}if(identifier[M6Q] !== undefined){_dtCellSelector(out,dt,identifier[M6Q],fields,idFn);}}else {_dtRowSelector(out,dt,identifier,fields,idFn);}return out;},id:function(data){var idFn=dataGet(this[l4$][m5b]);return idFn(data);},individual:function(identifier,fieldNames){var B5=r7lc_.q78;B5+=M$3;B5+=R7b;r7lc_.w49();B5+=l4$;var V1=h1q;V1+=T69;V1+=v4k;V1+=E_j;var T7=e4a;T7+=z7s;T7+=v0W;var idFn=dataGet(this[l4$][T7]);var dt=_dtApi(this[l4$][V1]);var fields=this[l4$][B5];var out={};var forceFields;if(fieldNames){var j6=E_j;j6+=M4$;j6+=r7lc_[631343];j6+=L8X;if(!Array[Z6E](fieldNames)){fieldNames=[fieldNames];}forceFields={};$[j6](fieldNames,function(i,name){r7lc_.y2x();forceFields[name]=fields[name];});}_dtCellSelector(out,dt,identifier,fields,idFn,forceFields);return out;},prep:function(action,identifier,submit,json,store){var E7F="celled";var w9Z="cance";var K8=f0G;K8+=s9A;K8+=r7lc_.I0t;K8+=E_j;var _this=this;if(action === K8){var U1=r7lc_.A9u;U1+=M4$;store[o5B]=$[S6L](json[U1],function(row){var q3=r7lc_[631343];q3+=I0x;var d_=O6E;d_+=X2M;return dataSource$1[d_][q3](_this,row);});}if(action === X$Q){var E0=J8U;E0+=H19;var Q8=r7lc_[631343];Q8+=Z0u;Q8+=E7F;var cancelled_1=json[Q8] || [];store[o5B]=$[E0](submit[E15],function(val,key){r7lc_.w49();var T2=X2M;T2+=M4$;T2+=r7lc_.I0t;T2+=M4$;return !$[U05](submit[T2][key]) && $[U7Z](key,cancelled_1) === -F9J?key:undefined;});}else if(action === c12){var K7=w9Z;K7+=v4k;K7+=x4W;store[K7]=json[l2u] || [];}},refresh:function(){r7lc_.w49();var q0=h2t;q0+=B$z;var S8=M4$;S8+=G4b;S8+=D34;var dt=_dtApi(this[l4$][s9i]);dt[S8][q0](v5D,B4$);},remove:function(identifier,fields,store){r7lc_.w49();var q2X="ry";var s2=v4k;s2+=E_j;s2+=w6p;s2+=Q2T;var h5=r7lc_.I0t;h5+=h0p;h5+=E_j;var that=this;var dt=_dtApi(this[l4$][h5]);var cancelled=store[l2u];if(cancelled[s2] === U3X){dt[y5t](identifier)[u3q]();}else {var G1=g$A;G1+=E_j;G1+=D7o;G1+=L6h;var t1=E6d;t1+=q2X;var W0=g$A;W0+=B_4;W0+=R$a;W0+=l4$;var indexes_1=[];dt[W0](identifier)[t1](function(){var n8=k0r;n8+=h1q;var w2=r7lc_[631343];w2+=M4$;w2+=v4k;w2+=v4k;var M$=O6E;M$+=X2M;var id=dataSource$1[M$][w2](that,this[n8]());if($[U7Z](id,cancelled) === -F9J){var A9=O6E;A9+=r7lc_[616964];A9+=X2M;A9+=j7C;var f7=D_g;f7+=P0J;f7+=L8X;indexes_1[f7](this[A9]());}});dt[y5t](indexes_1)[G1]();}}};function _htmlId(identifier){var T9G="tor-id=\"";var V18="-edi";var D9z="ould not find an element with `data-editor-id` or `id` of: ";var y8t="keyles";var T2C="ri";var c_=g0Z;c_+=V18;c_+=T9G;var H8=y8t;H8+=l4$;if(identifier === H8){return $(document);}var specific=$(c_ + identifier + U_X);if(specific[b_m] === U3X){var J8=a7V;J8+=T2C;J8+=r7lc_[616964];J8+=z5X;specific=typeof identifier === J8?$(safeQueryId(identifier)):$(identifier);}if(specific[b_m] === U3X){var O3=E6J;O3+=D9z;throw new Error(O3 + identifier);}return specific;}function _htmlEl(identifier,name){var O4j='[data-editor-field="';var context=_htmlId(identifier);r7lc_.w49();return $(O4j + name + U_X,context);}function _htmlEls(identifier,names){var j0=q_1;j0+=w6p;j0+=r7lc_.I0t;j0+=L8X;var out=$();for(var i=U3X,ien=names[j0];i < ien;i++){out=out[n7F](_htmlEl(identifier,names[i]));}return out;}function _htmlGet(identifier,dataSrc){var y9S='[data-editor-value]';var R$U="ta-editor-value";var r0$="filt";var O6=L8X;O6+=r7lc_.I0t;O6+=e_Z;var Y3=X2M;Y3+=M4$;Y3+=R$U;var R8=q_1;R8+=r7lc_[616964];r7lc_.w49();R8+=z5X;R8+=Q2T;var t0=r0$;t0+=B2h;var el=_htmlEl(identifier,dataSrc);return el[t0](y9S)[R8]?el[r0r](Y3):el[O6]();}function _htmlSet(identifier,fields,data){$[n8S](fields,function(name,field){var D6C="ilte";var Z$4="lue";var j74="data-edito";var d7S="r-va";var i7B="-editor-value";var val=field[k0K](data);if(val !== undefined){var n2=g0Z;n2+=i7B;n2+=D31;var P$=r7lc_.q78;P$+=D6C;P$+=g$A;var el=_htmlEl(identifier,field[b_d]());if(el[P$](n2)[b_m]){var i3=j74;i3+=d7S;i3+=Z$4;var L4=X5E;L4+=g$A;el[L4](i3,val);}else {var f8=L8X;f8+=r7lc_.I0t;f8+=J8U;f8+=v4k;el[n8S](function(){var s3U="removeChild";r7lc_.w49();var i0N="Chi";while(this[z4j][b_m]){var b3=r7lc_.q78;b3+=r1z;b3+=i0N;b3+=R7b;this[s3U](this[b3]);}})[f8](val);}}});}var dataSource={create:function(fields,data){if(data){var d6=r7lc_[631343];d6+=w7Q;d6+=v4k;var id=dataSource[e4a][d6](this,data);try{if(_htmlId(id)[b_m]){_htmlSet(id,fields,data);}}catch(e){;}}},edit:function(identifier,fields,data){var w5J="keyle";var T4=w5J;T4+=m0p;var O5=K0E;O5+=v4k;var P2=O6E;P2+=X2M;var id=dataSource[P2][O5](this,data) || T4;_htmlSet(id,fields,data);},fields:function(identifier){var t9m="yl";var r$=K4t;r$+=v4k;r$+=X2M;r$+=l4$;var out={};if(Array[Z6E](identifier)){var M6=v4k;M6+=f1i;for(var i=U3X,ien=identifier[M6];i < ien;i++){var z$=g_V;z$+=l4$;var res=dataSource[z$][e27](this,identifier[i]);out[identifier[i]]=res[identifier[i]];}return out;}var data={};var fields=this[l4$][r$];if(!identifier){var u0=r4Y;u0+=t9m;u0+=m5B;identifier=u0;}$[n8S](fields,function(name,field){var c8n="alToData";r7lc_.w49();var s0=b$b;s0+=c8n;var val=_htmlGet(identifier,field[b_d]());field[s0](data,val === v5D?undefined:val);});out[identifier]={data:data,fields:fields,idSrc:identifier,node:document,type:J1z};return out;},id:function(data){var idFn=dataGet(this[l4$][m5b]);return idFn(data);},individual:function(identifier,fieldNames){var c2i="eNam";var x8P='[data-editor-id]';var y2D="annot autom";var S6T="rmine field name from data source";var j0O="r-field";var M_E="ditor-id";var e0B="data-ed";var v8X='addBack';var J88="atically dete";var r2s="ito";var X1=s9A;X1+=r7lc_[631343];X1+=L8X;var u2=E_j;u2+=e8A;u2+=L8X;var E_=o7b;E_+=F6Q;E_+=X2M;E_+=l4$;var a2=r7lc_[631343];a2+=M4$;a2+=v4k;a2+=v4k;var Y_=g7g;Y_+=I_5;Y_+=M4$;Y_+=R1v;var X2=r7lc_[616964];X2+=y6K;X2+=c2i;X2+=E_j;var attachEl;if(identifier instanceof $ || identifier[X2]){var Q9=E_j;Q9+=M_E;var i_=k0r;i_+=h1q;attachEl=identifier;if(!fieldNames){var Z0=e0B;Z0+=r2s;Z0+=j0O;fieldNames=[$(identifier)[r0r](Z0)];}var back=$[T5x][I4F]?v8X:y0O;identifier=$(identifier)[G_2](x8P)[back]()[i_](Q9);}if(!identifier){var Q6=r4Y;Q6+=O0P;Q6+=l4$;Q6+=l4$;identifier=Q6;}if(fieldNames && !Array[Y_](fieldNames)){fieldNames=[fieldNames];}if(!fieldNames || fieldNames[b_m] === U3X){var e5=E6J;e5+=y2D;e5+=J88;e5+=S6T;throw new Error(e5);}var out=dataSource[b7d][a2](this,identifier);var fields=this[l4$][E_];var forceFields={};r7lc_.w49();$[u2](fieldNames,function(i,name){r7lc_.y2x();forceFields[name]=fields[name];});$[X1](out,function(id,set){var O$V='cell';var A2l="oArr";var D3v="hF";var A3$="tac";var b1h="splayFields";var p_=A9N;p_+=b1h;var P3=g_V;P3+=l4$;var f0=r7lc_.I0t;f0+=A2l;f0+=M4$;f0+=R1v;var y4=p0h;y4+=A3$;y4+=D3v;y4+=z8Z;set[U5U]=O$V;set[y4]=[fieldNames];set[A$l]=attachEl?$(attachEl):_htmlEls(identifier,fieldNames)[f0]();set[P3]=fields;set[p_]=forceFields;});return out;},initField:function(cfg){var K_I="ditor-label=\"";var G9g="[data-e";var G5=v4k;G5+=f1i;var u_=v4k;u_+=U6p;u_+=F6Q;var M5=X2D;M5+=D31;var t4=r7lc_[616964];t4+=M4$;t4+=J8U;t4+=E_j;var A$=X2M;A$+=Y$P;var k9=G9g;k9+=K_I;var label=$(k9 + (cfg[A$] || cfg[t4]) + M5);if(!cfg[u_] && label[G5]){var J1=L8X;J1+=W8L;cfg[o38]=label[J1]();}},remove:function(identifier,fields){var X48='keyless';r7lc_.w49();if(identifier !== X48){var o0=h2t;o0+=D7o;o0+=b$b;o0+=E_j;_htmlId(identifier)[o0]();}}};var classNames={actions:{create:K5Y,edit:F9v,remove:l5},body:{content:Y5j,wrapper:w4},bubble:{bg:I0p,close:r1u,liner:D1,pointer:V5I,table:w8,wrapper:A0},field:{'disabled':L1,'error':L1R,'input':b24,'inputControl':L7v,'label':n5,'msg-error':c5,'msg-info':v1s,'msg-label':z8_,'msg-message':A3,'multiInfo':V8u,'multiNoEdit':h8,'multiRestore':L4_,'multiValue':B0,'namePrefix':R7_,'processing':X7U,'typePrefix':p7,'wrapper':t3e},footer:{content:I6w,wrapper:S6V},form:{button:o2X,buttonInternal:n0,buttons:C0,content:X56,error:t7W,info:n4x,tag:D3I,wrapper:A8},header:{content:F2T,title:{tag:v5D,class:D3I},wrapper:U6u},inline:{buttons:z3A,liner:F5,wrapper:f2E},processing:{active:q2,indicator:u3},wrapper:C2l};var displayed$2=B4$;var cssBackgroundOpacity=F9J;var dom$1={background:$(K6)[U3X],close:$(k9B)[U3X],content:v5D,wrapper:$(K1 + k0 + H5 + a$h)[U3X]};function findAttachRow(editor,attach){var d40="tabl";var H6=J5p;H6+=j80;var K4=i0T;K4+=X2M;r7lc_.w49();var r3=d40;r3+=E_j;var a8=o32;a8+=D_g;a8+=O6E;var dt=new $[T5x][o5o][a8](editor[l4$][r3]);if(attach === K4){var R$=X2j;R$+=M4$;R$+=g_x;R$+=g$A;return dt[s9i](undefined)[R$]();;}else if(editor[l4$][b5A] === H6){var y8=A7L;y8+=q_1;return dt[y8](undefined)[X53]();}else {var r4=r7lc_[616964];r4+=B_4;r4+=X2M;r4+=E_j;var G4=D_b;G4+=O6E;G4+=r7lc_.q78;G4+=J8F;var D4=g$A;D4+=B_4;D4+=R$a;return dt[D4](editor[l4$][G4])[r4]();}}function heightCalc$1(dte){var g7d="onf";var E7B="erHeight";var y0c="DTE_Body_C";var I5a="wrapp";var X9T='div.DTE_Header';var f4=R$a;f4+=g$A;f4+=H19;f4+=o0h;var L0=H$2;L0+=J8U;var M8=u3g;M8+=l4$;var s3=I5a;s3+=E_j;r7lc_.y2x();s3+=g$A;var a$=u$7;a$+=D3k;a$+=y0c;a$+=W4n;var E9=r7lc_[631343];E9+=g7d;var a_=R$a;a_+=g$A;a_+=D47;a_+=g$A;var I$=Q4h;I$+=r7lc_.I0t;I$+=E7B;var z2=R$a;z2+=G8G;z2+=E_j;z2+=g$A;var header=$(X9T,dom$1[z2])[I$]();var footer=$(u_f,dom$1[a_])[j4L]();var maxHeight=$(window)[t2R]() - envelope[E9][T$v] * o8o - header - footer;$(a$,dom$1[s3])[M8](f38,maxHeight);return $(dte[L0][f4])[j4L]();}function hide$2(dte,callback){if(!callback){callback=function(){};}if(displayed$2){var z4=r7lc_[631343];z4+=y6p;z4+=E_j;z4+=Y$n;$(dom$1[z4])[T1N]({top:-(dom$1[C_y][N22] + t83)},r10,function(){var d3P="Ou";var G5P="back";var S2V="gro";r7lc_.w49();var p5=r7lc_[616964];p5+=G2G;p5+=J8U;p5+=w7Q;var D3=r7lc_.q78;D3+=V7G;D3+=d3P;D3+=r7lc_.I0t;var Y1=G5P;Y1+=S2V;Y1+=j1j;Y1+=k88;var S7=R$a;S7+=g$A;S7+=f8o;S7+=B2h;$([dom$1[S7],dom$1[Y1]])[D3](p5,function(){var U5=A1D;U5+=L8X;$(this)[U5]();callback();});});displayed$2=B4$;}}function init$1(){var V$P="ckgro";var r23="pac";var A0X='div.DTED_Envelope_Container';var W4=B_4;W4+=r23;W4+=O6E;W4+=v8n;var h0=r7lc_[631343];h0+=l4$;h0+=l4$;var e8=T69;e8+=M4$;e8+=V$P;e8+=J41;var j2=N5Z;j2+=f8o;j2+=E_j;j2+=g$A;dom$1[C_y]=$(A0X,dom$1[j2])[U3X];r7lc_.y2x();cssBackgroundOpacity=$(dom$1[e8])[h0](W4);}function show$2(dte,callback){var q6$=".DTE";var R87='click.DTED_Envelope';var p13="bac";var f82="mal";var c4s="offse";var r2B="_Envel";var O8a="ck.DTED_E";var R$Z="resize";var z0g="D_Envelope";var P$Z="ck.DTED";var z0o="tyle";var f9j="div.DTED_Lightbox_Content_Wrapp";var L9_="opacity";var V2Y="tHeight";var j_O="ackg";var p1d="style";var C$f="nor";var e53="size.DTED_Envelope";var Y0n="kg";var x7C='auto';var W7Z="marginLeft";var m9m="nvelope";var r1h="kground";var F9x='0';var b5=R$Z;b5+=q6$;b5+=z0g;var G9=g$A;G9+=E_j;G9+=e53;var X6=B_4;X6+=r7lc_.q78;X6+=r7lc_.q78;var L9=B_4;L9+=r7lc_[616964];var D$=T9O;D$+=O8a;D$+=m9m;var j1=B_4;j1+=r7lc_.q78;j1+=r7lc_.q78;var a1=f9j;a1+=E_j;r7lc_.y2x();a1+=g$A;var o3=T9O;o3+=P$Z;o3+=r2B;o3+=U7l;var a7=U_K;a7+=T2s;var R1=K5f;R1+=r7lc_.I0t;R1+=v4k;R1+=E_j;var H2=X5E;H2+=g$A;var t5=R$a;t5+=X1O;t5+=E3D;t5+=B2h;if(!callback){callback=function(){};}$(N$f)[C__](dom$1[J2d])[C__](dom$1[t5]);dom$1[C_y][p1d][t2R]=x7C;if(!displayed$2){var y3=M4$;y3+=h1w;y3+=X05;var P9=g9q;P9+=D_o;var t2=r7lc_.q78;t2+=M4$;t2+=g_x;t2+=U5b;var R_=C$f;R_+=f82;var n7=T69;n7+=j_O;n7+=Q8O;n7+=J41;var T5=V88;T5+=B_4;T5+=r7lc_[631343];T5+=O5j;var W7=N7c;W7+=v7E;var G6=p13;G6+=r1h;var u$=D_g;u$+=D34;var g1=r7lc_.I0t;g1+=B_4;g1+=D_g;var O0=l4$;O0+=r7lc_.I0t;O0+=R1v;O0+=q_1;var A7=D_g;A7+=D34;var y_=c4s;y_+=V2Y;var l6=r7lc_.I0t;l6+=M8e;var m4=r7lc_.I0t;m4+=B_4;m4+=D_g;var R9=l4$;R9+=r7lc_.I0t;R9+=O0P;var T6=R$a;T6+=X1O;T6+=E3D;T6+=B2h;var J6=D_g;J6+=D34;var e9=l4$;e9+=r7lc_.I0t;e9+=O0P;var l4=D_g;l4+=D34;var a4=R$a;a4+=O6E;a4+=V9F;a4+=L8X;var C3=r7lc_[616964];C3+=B_4;C3+=r7lc_[616964];C3+=E_j;var Y5=X2M;Y5+=r1M;Y5+=Q4Z;Y5+=v7E;var l3=v7d;l3+=e3Y;var d5=l4$;d5+=z0o;var style=dom$1[V3F][d5];style[L9_]=F9x;style[u_G]=l3;var height=heightCalc$1(dte);var targetRow=findAttachRow(dte,envelope[D76][A$l]);var width=targetRow[c$Q];style[Y5]=C3;style[L9_]=w_e;dom$1[V3F][p1d][a4]=width + l4;dom$1[V3F][e9][W7Z]=-(width / o8o) + J6;dom$1[T6][R9][m4]=$(targetRow)[k3L]()[l6] + targetRow[y_] + A7;dom$1[C_y][O0][g1]=-F9J * height - V9r + u$;dom$1[J2d][p1d][L9_]=F9x;dom$1[G6][p1d][W7]=T5;$(dom$1[n7])[T1N]({opacity:cssBackgroundOpacity},R_);$(dom$1[V3F])[t2]();$(dom$1[P9])[y3]({top:U3X},r10,callback);}$(dom$1[i6F])[H2](R1,dte[a7][i6F])[i2_](R87)[e40](o3,function(e){var v9=R7l;v9+=l4$;v9+=E_j;dte[v9]();});$(dom$1[J2d])[i2_](R87)[e40](R87,function(e){var O12="round";var y1=p13;y1+=Y0n;y1+=O12;r7lc_.y2x();dte[y1]();});$(a1,dom$1[V3F])[j1](D$)[L9](R87,function(e){var G2r="hasClass";var q9B="roun";r7lc_.w49();var i0W='DTED_Envelope_Content_Wrapper';if($(e[J4A])[G2r](i0W)){var S_=p13;S_+=Y0n;S_+=q9B;S_+=X2M;dte[S_]();}});$(window)[X6](G9)[e40](b5,function(){heightCalc$1(dte);});displayed$2=E6A;}var envelope={close:function(dte,callback){r7lc_.y2x();hide$2(dte,callback);},conf:{attach:Z3,windowPadding:t83},destroy:function(dte){hide$2();},init:function(dte){r7lc_.w49();init$1();return envelope;},node:function(dte){return dom$1[V3F][U3X];},open:function(dte,append,callback){var L0L="appendChild";var d9V="hild";var c17="appendC";var h9=c17;h9+=d9V;var V8=r7lc_[631343];V8+=y6p;V8+=a8w;V8+=r7lc_.I0t;var B$=g9q;B$+=D_a;B$+=Y$n;$(dom$1[B$])[u1K]()[U8w]();dom$1[V8][h9](append);dom$1[C_y][L0L](dom$1[i6F]);show$2(dte,callback);}};function isMobile(){var o6P=576;var S2G="ned";var k1w="orie";var a$z="outerW";var S1F="ntation";var N5i="efi";var b7=a$z;b7+=e4a;b7+=r7lc_.I0t;b7+=L8X;var d$=j1j;d$+=k88;d$+=N5i;d$+=S2G;r7lc_.w49();var V5=k1w;V5+=S1F;return typeof window[V5] !== d$ && window[b7] <= o6P?E6A:B4$;}var displayed$1=B4$;var ready=B4$;var scrollTop=U3X;var dom={background:$(R4H),close:$(c9),content:v5D,wrapper:$(V7 + m_ + L6a + G3 + Q1 + a$h + a$h + a$h)};function heightCalc(){var U9H='div.DTE_Body_Content';var R4M="hei";var L6Q='calc(100vh - ';var C$v="div.DTE_Body_C";var v3O="rHeight";var e5x="erHe";var v9B="out";var u3t="Height";var P7u="ht";var g_U="v.DTE_Header";var R6o="pper";var s6=Q4h;s6+=r7lc_.I0t;s6+=E_j;s6+=v3O;var z8=D3P;z8+=R6o;var I8=v9B;I8+=e5x;I8+=H$k;var o9=D3P;o9+=D_g;o9+=D_g;o9+=B2h;var Q7=A9N;Q7+=g_U;var headerFooter=$(Q7,dom[o9])[I8]() + $(u_f,dom[z8])[s6]();if(isMobile()){var e4=D_g;e4+=D34;e4+=A9q;var D2=Q_x;D2+=u3t;var i6=C$v;i6+=W4n;$(i6,dom[V3F])[Q$n](D2,L6Q + headerFooter + e4);}else {var S3=R$a;S3+=O$n;var x3=R4M;x3+=z5X;x3+=P7u;var maxHeight=$(window)[x3]() - self[D76][T$v] * o8o - headerFooter;$(U9H,dom[S3])[Q$n](f38,maxHeight);}}function hide$1(dte,callback){var j0X='resize.DTED_Lightbox';var i8g="lTo";r7lc_.y2x();var E4w="offsetAni";var s9=r7lc_[631343];s9+=e40;s9+=r7lc_.q78;var P4=K3O;P4+=v4k;P4+=i8g;P4+=D_g;var Y2=T69;Y2+=B_4;Y2+=X2M;Y2+=R1v;if(!callback){callback=function(){};}$(Y2)[P4](scrollTop);dte[G0D](dom[V3F],{opacity:U3X,top:self[s9][E4w]},function(){var i4=X2M;i4+=E_j;i4+=r7lc_.I0t;i4+=m4P;$(this)[i4]();callback();});dte[G0D](dom[J2d],{opacity:U3X},function(){var e_=X2M;e_+=s7X;r7lc_.w49();e_+=e8A;e_+=L8X;$(this)[e_]();});displayed$1=B4$;$(window)[i2_](j0X);}function init(){var O58="div.DTED";var K3J='opacity';var p8_="_Lightbox_Content";var B2m="opaci";var h$=u3g;h$+=l4$;var E3=B2m;E3+=r7lc_.I0t;E3+=R1v;var q_=r7lc_[631343];q_+=l4$;q_+=l4$;var i$=R$a;i$+=O$n;var h4=N5Z;r7lc_.y2x();h4+=H19;h4+=t$M;h4+=g$A;var x2=O58;x2+=p8_;var Y9=g9q;Y9+=D_o;if(ready){return;}dom[Y9]=$(x2,dom[h4]);dom[i$][q_](E3,U3X);dom[J2d][h$](K3J,U3X);ready=E6A;}function show$1(dte,callback){var s56="backgro";var E0N="Ani";var F43="llTop";var j6Q="ackgr";var H0k='DTED_Lightbox_Mobile';var J89="oun";var T$7="click.DTED_Li";var u5f="Light";var C1A='div.DTED_Lightbox_Content_Wrapper';var E8p='height';var w5X="box";var o6h="_ani";var i$7="ghtbox";var S9O="_Lightbo";var L6W='click.DTED_Lightbox';var E8u="click.DTED";var L$V="_L";var w7v="esize.DTED";var T3i="ightbo";var o4=B_4;o4+=r7lc_[616964];var U7=E8u;U7+=L$V;U7+=T3i;U7+=D34;var z5=B_4;z5+=r7lc_.q78;z5+=r7lc_.q78;var h2=s56;h2+=J41;var T_=T$7;T_+=i$7;var D5=E8u;D5+=i3B;D5+=u5f;D5+=w5X;var k_=B_4;k_+=r7lc_.q78;k_+=r7lc_.q78;var F2=h7_;F2+=B_4;F2+=l4$;F2+=E_j;r7lc_.w49();var U2=p0h;U2+=M_A;var y2=N5Z;y2+=f8o;y2+=B2h;var C8=M4$;C8+=Z30;C8+=r7lc_[616964];C8+=X2M;var N6=O40;N6+=X2M;N6+=R1v;if(isMobile()){$(N$f)[l7F](H0k);}$(N6)[C__](dom[J2d])[C8](dom[y2]);heightCalc();if(!displayed$1){var x4=K3O;x4+=F43;var F6=O40;F6+=a_Y;var s$=g$A;s$+=w7v;s$+=S9O;s$+=D34;var A2=B_4;A2+=r7lc_[616964];var x7=T69;x7+=j6Q;x7+=J89;x7+=X2M;var C_=D3P;C_+=D_g;C_+=o0h;var q1=o6h;q1+=X05;var N9=k3L;N9+=E0N;var o6=D3P;o6+=E3D;o6+=B2h;var y5=M4$;y5+=j1j;y5+=r7lc_.I0t;y5+=B_4;var z9=g9q;z9+=D_a;z9+=Y$n;displayed$1=E6A;dom[z9][Q$n](E8p,y5);dom[o6][Q$n]({top:-self[D76][N9]});dte[q1](dom[C_],{opacity:F9J,top:U3X},callback);dte[G0D](dom[x7],{opacity:F9J});$(window)[A2](s$,function(){r7lc_.y2x();heightCalc();});scrollTop=$(F6)[x4]();}dom[i6F][U2](w76,dte[N9v][F2])[k_](D5)[e40](T_,function(e){var I5=r7lc_[631343];I5+=v4k;I5+=B_4;I5+=Z_p;dte[I5]();});dom[h2][z5](U7)[e40](L6W,function(e){var v_n="stopImmediatePropag";var e6h="ation";var D_=v_n;D_+=e6h;e[D_]();dte[J2d]();});$(C1A,dom[V3F])[i2_](L6W)[o4](L6W,function(e){var c_1="stop";r7lc_.y2x();var p2z='DTED_Lightbox_Content_Wrapper';var W9Z="atePropa";var q9J="gation";var t5n="Immedi";var U5p="hasClas";var C4=U5p;C4+=l4$;if($(e[J4A])[C4](p2z)){var X9=c_1;X9+=t5n;X9+=W9Z;X9+=q9J;e[X9]();dte[J2d]();}});}var self={close:function(dte,callback){hide$1(dte,callback);},conf:{offsetAni:R4K,windowPadding:R4K},destroy:function(dte){if(displayed$1){hide$1(dte);}},init:function(dte){r7lc_.w49();init();return self;},node:function(dte){r7lc_.y2x();return dom[V3F][U3X];},open:function(dte,append,callback){var W6=H19;W6+=D_g;W6+=v1N;var m7=M4$;m7+=Z30;r7lc_.y2x();m7+=k88;var content=dom[C_y];content[u1K]()[U8w]();content[m7](append)[W6](dom[i6F]);show$1(dte,callback);}};var DataTable$5=$[Y7][o5o];function add(cfg,after,reorder){var i8l='Error adding field. The field requires a `name` option';var L$k="ft";var G0P="itFie";var w0y="\'. A field alre";var x8c="ady";var R7P='Error adding field \'';var l6O="unshi";var d0c="inArra";var Y0v="exists with this name";var x5D="reverse";var M1=K4t;M1+=v4k;M1+=S1y;var L2=D7o;L2+=g_x;var d2=h7_;d2+=z_Y;d2+=Z_p;d2+=l4$;var Z6=k0f;Z6+=G0P;Z6+=v4k;Z6+=X2M;var w9=r7lc_.q78;w9+=M$3;w9+=v4k;w9+=S1y;var K3=r7lc_[616964];K3+=M4$;K3+=J8U;K3+=E_j;if(reorder === void U3X){reorder=E6A;}if(Array[Z6E](cfg)){var d7=v4k;d7+=E_j;d7+=w6p;d7+=Q2T;if(after !== undefined){cfg[x5D]();}for(var _i=U3X,cfg_1=cfg;_i < cfg_1[d7];_i++){var cfgDp=cfg_1[_i];this[n7F](cfgDp,after,B4$);}this[X$k](this[X6a]());return this;}var name=cfg[K3];if(name === undefined){throw new Error(i8l);}if(this[l4$][w9][name]){var U3=w0y;U3+=x8c;U3+=O7Q;U3+=Y0v;throw new Error(R7P + name + U3);}r7lc_.y2x();this[f3Q](Z6,cfg);var editorField=new Editor[m0Y](cfg,this[d2][g_V],this);if(this[l4$][L2]){var editFields=this[l4$][P8d];editorField[k$m]();$[n8S](editFields,function(idSrc,editIn){r7lc_.y2x();var z3R="valF";var V0=k0r;V0+=r7lc_.I0t;V0+=M4$;var value;if(editIn[V0]){var N_=X2M;N_+=M4$;N_+=r7lc_.I0t;N_+=M4$;var J$=z3R;J$+=Q8O;J$+=B78;value=editorField[J$](editIn[N_]);}editorField[D1h](idSrc,value !== undefined?value:editorField[L_X]());});}this[l4$][M1][name]=editorField;if(after === undefined){var n3=D_g;n3+=j1j;n3+=m8k;var f6=G2G;f6+=X2M;f6+=B2h;this[l4$][f6][n3](name);}else if(after === v5D){var N8=l6O;N8+=L$k;var h1=B_4;h1+=g$A;h1+=X2M;h1+=B2h;this[l4$][h1][N8](name);}else {var x1=B_4;x1+=g$A;x1+=X2M;x1+=B2h;var b8=B_4;b8+=Z5A;b8+=B2h;var Q_=d0c;Q_+=R1v;var idx=$[Q_](after,this[l4$][b8]);this[l4$][x1][S8Q](idx + F9J,U3X,name);}if(reorder !== B4$){var U0=B_4;U0+=g$A;U0+=E_x;this[X$k](this[U0]());}return this;}function ajax(newAjax){if(newAjax){this[l4$][Y3a]=newAjax;return this;}return this[l4$][Y3a];}function background(){var M16="onBackground";var K$=T69;K$+=v4k;K$+=E_Q;var onBackground=this[l4$][k1p][M16];if(typeof onBackground === K0g){onBackground(this);}else if(onBackground === K$){this[D6X]();}else if(onBackground === M9H){this[i6F]();}else if(onBackground === Q3I){var A6=l59;A6+=T69;A6+=J8U;A6+=c34;this[A6]();}return this;}function blur(){var v8C="_blur";r7lc_.w49();this[v8C]();return this;}function bubble(cells,fieldNames,showIn,opts){var k6z="bje";var d$5='individual';var r$c="isPlainO";var I4=x61;I4+=g$A;I4+=K0$;var T3=S5R;T3+=k88;var M7=C$e;M7+=p$W;var r5=r$c;r5+=k6z;r5+=h9w;var _this=this;if(showIn === void U3X){showIn=E6A;}var that=this;if(this[y0k](function(){r7lc_.y2x();that[v1X](cells,fieldNames,opts);})){return this;}if($[r5](fieldNames)){opts=fieldNames;fieldNames=undefined;showIn=E6A;}else if(typeof fieldNames === i$u){showIn=fieldNames;fieldNames=undefined;opts=undefined;}if($[M7](showIn)){opts=showIn;showIn=E6A;}if(showIn === undefined){showIn=E6A;}opts=$[T3]({},this[l4$][P2i][v1X],opts);var editFields=this[I4](d$5,cells,fieldNames);this[b4L](cells,editFields,W29,opts,function(){var e5j="croll.";var y2h="prep";var V2L='" title="';var t5V="ndTo";var D1g="int";var l_P="<div ";var i2e="bubbleNodes";var t30="oncat";var t1B="ormOption";var D_s="hildr";var I9e="clas";var H6v="iv></div><";var g$9="=\"";var b4i="<div class=";var s4k=" s";var w$K='resize.';var o5n=" class";var u7s="rmInf";var c_N="\"></div";var E6T="\"DTE_Processing_Indicator";var Y5M='attach';var A21="\"><span></div>";var Z2E="dd";var b3N="bg";var U8=R$N;U8+=Y_p;var E2=T9O;E2+=e3Y;var N$=B_4;N$+=r7lc_[616964];var v_=M4$;v_+=Z2E;var S6=i4r;S6+=X2M;var O1=p_F;O1+=r7lc_.I0t;O1+=e40;O1+=l4$;var F3=a01;F3+=q_1;var V9=F4j;V9+=l4$;V9+=w0U;V9+=P99;var Z$=r7lc_.q78;Z$+=B_4;Z$+=g$A;Z$+=J8U;var w7=j8y;w7+=M$w;w7+=v1N;var b0=X2M;b0+=L3D;var O_=r7lc_[631343];O_+=D_s;O_+=a8w;var Q4=m3o;Q4+=c8l;var s7=E_j;s7+=x1k;var I6=y7x;I6+=X2M;I6+=O6E;I6+=w5K;var I0=c_N;I0+=j87;var r8=e8F;r8+=D1g;r8+=E_j;r8+=g$A;var T0=l_P;T0+=W$P;var R3=K9b;R3+=v8t;R3+=v9_;R3+=j87;var j3=b4i;j3+=E6T;j3+=A21;var O4=R7l;O4+=l4$;O4+=E_j;var q5=X2D;q5+=j87;var S$=X2D;S$+=j87;var l1=v4k;l1+=k0f;l1+=B2h;var g7=N5Z;g7+=D47;g7+=g$A;var i2=w9A;i2+=H6v;i2+=p5r;i2+=q01;var d3=k7W;d3+=v9_;d3+=o5n;d3+=g$9;var B6=I9e;B6+=B5z;var f9=r7lc_[631343];f9+=t30;var E$=s4k;E$+=e5j;var K0=i3B;K0+=r7lc_.q78;K0+=t1B;K0+=l4$;var namespace=_this[K0](opts);var ret=_this[Q_Y](W29);if(!ret){return _this;}$(window)[e40](w$K + namespace + E$ + namespace,function(){var m4s="blePosi";var D7$="bub";var l2=D7$;l2+=m4s;l2+=r7lc_[399342];_this[l2]();});var nodes=[];_this[l4$][i2e]=nodes[f9][m51](nodes,pluck(editFields,Y5M));var classes=_this[B6][v1X];var backgroundNode=$(d3 + classes[b3N] + i2);var container=$(u3L + classes[g7] + T3G + u3L + classes[l1] + S$ + u3L + classes[s9i] + q5 + u3L + classes[O4] + V2L + _this[N9v][i6F] + t1P + j3 + R3 + a$h + T0 + classes[r8] + I0 + I6);if(showIn){var c2=T69;c2+=B_4;c2+=X2M;c2+=R1v;var X$=M4$;X$+=E3D;X$+=E_j;X$+=t5V;container[e06](N$f);backgroundNode[X$](c2);}var liner=container[u1K]()[s7](U3X);var tableNode=liner[Q4]();var closeNode=tableNode[O_]();liner[C__](_this[b0][O89]);tableNode[w7](_this[H$1][Z$]);if(opts[V9]){var M3=H1k;M3+=u7s;M3+=B_4;var v0=X2M;v0+=B_4;v0+=J8U;var i5=j8y;i5+=v_a;liner[i5](_this[v0][M3]);}if(opts[F3]){var o8=i0T;o8+=E_x;var J9=y2h;J9+=E_j;J9+=r7lc_[616964];J9+=X2M;liner[J9](_this[H$1][o8]);}if(opts[O1]){var g5=X2M;g5+=B_4;g5+=J8U;tableNode[C__](_this[g5][Y0_]);}var finish=function(){var P7v="ynamicInfo";var b$C="sed";var d$I="clearD";var Z7=h7_;Z7+=B_4;Z7+=b$C;var k3=i3B;k3+=d$I;k3+=P7v;_this[k3]();_this[M4P](Z7,[W29]);};var pair=$()[S6](container)[v_](backgroundNode);_this[a0E](function(submitComplete){var i6z="_anim";var n4=i6z;n4+=M4$;n4+=r7lc_.I0t;n4+=E_j;r7lc_.y2x();_this[n4](pair,{opacity:U3X},function(){var C3w="ze.";var r6g="resi";var i$_="eta";if(this === container[U3X]){var x$=s4k;x$+=e5j;var R5=r6g;R5+=C3w;var L8=B_4;L8+=r7lc_.q78;L8+=r7lc_.q78;var B7=X2M;B7+=i$_;B7+=D5x;pair[B7]();$(window)[L8](R5 + namespace + x$ + namespace);finish();}});});backgroundNode[N$](R9$,function(){r7lc_.y2x();_this[D6X]();});closeNode[e40](E2,function(){r7lc_.y2x();_this[g7m]();});_this[U8]();_this[B4I](W29,B4$);var opened=function(){var P4A="lude";var u7x="ened";var t$q="inc";var L1d="Fi";var f8$="bb";var v8=O5A;v8+=r7lc_[616964];var I_=T69;I_+=j1j;I_+=f8$;r7lc_.w49();I_+=q_1;var E1=B_4;E1+=D_g;E1+=u7x;var S9=i3B;S9+=X1$;S9+=E_j;S9+=Y$n;var u7=H1k;u7+=r7lc_[631343];u7+=j1j;u7+=l4$;var n_=t$q;n_+=P4A;n_+=L1d;n_+=x5T;var F4=i3B;F4+=H1k;F4+=r7lc_[631343];F4+=P0J;_this[F4](_this[l4$][n_],opts[u7]);_this[S9](E1,[I_,_this[l4$][v8]]);};_this[G0D](pair,{opacity:F9J},function(){r7lc_.y2x();if(this === container[U3X]){opened();}});});return this;}function bubblePosition(){var L7w="right";var I3y="outerWidth";var M_M='below';var R9N="leBottom";var Z7H="bubbleBottom";var D3h="_Liner";var m7B="div.DTE_B";var D54="bleB";var V6X="bubb";var u7t="bottom";var l7c="ottom";var X93="ig";var s0q='div.DTE_Bubble';var j_W="ollTop";var f7W="gh";var G7$="ubbleNod";var L3S="tto";var P7O="ttom";var Q1W="eft";var L2A="innerHe";var L7s="ubble";var K5Q="left";var t3=r7lc_.I0t;t3+=B_4;t3+=D_g;var C6=v4k;C6+=a8P;C6+=Q2T;var b1=L2A;b1+=O6E;b1+=f7W;b1+=r7lc_.I0t;var W2=w$F;W2+=z5X;W2+=Q2T;var H0=T69;H0+=n1_;H0+=D54;H0+=l7c;var j7=T69;j7+=B_4;j7+=P7O;var X_=V6X;X_+=R9N;var h3=l4$;h3+=f0G;h3+=j_W;var p2=g$A;p2+=X93;p2+=L8X;p2+=r7lc_.I0t;var z_=r7lc_.I0t;z_+=B_4;z_+=D_g;var G7=O40;G7+=L3S;G7+=J8U;var s4=v4k;s4+=E_j;s4+=w6p;s4+=Q2T;var R2=E_j;R2+=e8A;R2+=L8X;var X0=T69;X0+=G7$;X0+=s4U;var M9=m7B;M9+=L7s;M9+=D3h;var wrapper=$(s0q);var liner=$(M9);var nodes=this[l4$][X0];var position={bottom:U3X,left:U3X,right:U3X,top:U3X};$[R2](nodes,function(i,nodeIn){var A9W="lef";var u4=A9W;u4+=r7lc_.I0t;var M0=g$A;M0+=H$k;r7lc_.y2x();var t8=v4k;t8+=Q9l;t8+=r7lc_.I0t;var S1=v4k;S1+=E_j;S1+=r7lc_.q78;S1+=r7lc_.I0t;var F7=S3h;F7+=D_g;var W1=S3h;W1+=D_g;var pos=$(nodeIn)[k3L]();nodeIn=$(nodeIn)[m8j](U3X);position[W1]+=pos[F7];position[S1]+=pos[t8];position[M0]+=pos[u4] + nodeIn[c$Q];position[u7t]+=pos[b8N] + nodeIn[N22];});position[b8N]/=nodes[b_m];position[K5Q]/=nodes[s4];position[L7w]/=nodes[b_m];position[G7]/=nodes[b_m];var top=position[z_];var left=(position[K5Q] + position[p2]) / o8o;var width=liner[I3y]();var height=liner[j4L]();var visLeft=left - width / o8o;var visRight=visLeft + width;var docWidth=$(window)[v6N]();r7lc_.w49();var viewportTop=$(window)[h3]();var padding=E7S;wrapper[Q$n]({left:left,top:this[l4$][X_]?position[j7]:top});if(this[l4$][H0]){var g2=M4$;g2+=p_L;wrapper[g2](M_M);}var curPosition=wrapper[P1s]();if(liner[W2] && curPosition[b8N] + height > viewportTop + window[b1]){var M4=r7lc_.I0t;M4+=B_4;M4+=D_g;var H_=r7lc_[631343];H_+=l4$;H_+=l4$;wrapper[H_](M4,top)[F15](M_M);this[l4$][Z7H]=B4$;}else if(liner[C6] && curPosition[t3] - height < viewportTop){var N7=r7lc_.I0t;N7+=B_4;N7+=D_g;var h_=r7lc_[631343];h_+=l4$;h_+=l4$;wrapper[h_](N7,position[u7t])[l7F](M_M);this[l4$][Z7H]=E6A;}if(visRight + padding > docWidth){var i0=v4k;i0+=Q1W;var w3=r7lc_[631343];w3+=l4$;w3+=l4$;var diff=visRight - docWidth;liner[w3](i0,visLeft < padding?-(visLeft - padding):-(diff + padding));}else {var s1=v4k;s1+=E_j;s1+=r7lc_.q78;s1+=r7lc_.I0t;liner[Q$n](s1,visLeft < padding?-(visLeft - padding):U3X);}return this;}function buttons(buttonsIn){var f4S="_ba";var J_=E_j;J_+=M4$;J_+=r7lc_[631343];J_+=L8X;var H3=E_j;H3+=J8U;H3+=D_g;H3+=v8n;var P_=O6E;P_+=f06;P_+=D7T;var m$=f4S;m$+=l4$;m$+=B6q;var _this=this;if(buttonsIn === m$){var T9=M4$;T9+=r7lc_[631343];T9+=K5f;T9+=e40;var h6=U_K;h6+=T2s;buttonsIn=[{action:function(){var Q5=l4$;r7lc_.w49();Q5+=n1_;Q5+=M2$;Q5+=r7lc_.I0t;this[Q5]();},text:this[h6][this[l4$][T9]][L9t]}];}else if(!Array[P_](buttonsIn)){buttonsIn=[buttonsIn];}r7lc_.y2x();$(this[H$1][Y0_])[H3]();$[J_](buttonsIn,function(i,btn){var x77="tt";var i_M="lassNam";var g$v="tabIn";var Q8N="ndex";var g3C='<button></button>';var H6Z="abI";var D6Q="pres";var g00="ssName";var l0=X2M;l0+=B_4;l0+=J8U;var w0=Z8y;w0+=N9Z;var d8=h7_;d8+=B6q;d8+=O5j;var e1=X2t;e1+=D6Q;e1+=l4$;var G0=X2t;G0+=y8W;var z1=B_4;z1+=r7lc_[616964];var P5=r7lc_.I0t;P5+=H6Z;P5+=k88;P5+=j7C;var v1=g$v;v1+=g_x;v1+=D34;var N0=h1q;N0+=T69;N0+=O6E;N0+=Q8N;var g9=X5E;g9+=g$A;var L$=t_t;L$+=j12;var c1=L8X;c1+=W8L;var b$=r7lc_[631343];b$+=i_M;b$+=E_j;var Z5=A7E;Z5+=g00;var i7=b3j;i7+=l4$;var d0=M4$;d0+=x77;d0+=g$A;var p8=O5A;p8+=r7lc_[616964];var N1=t_U;N1+=r7lc_[616964];N1+=z5X;if(typeof btn === N1){btn={action:function(){this[L9t]();},text:btn};}var text=btn[L9$] || btn[o38];var action=btn[p8] || btn[T5x];var attr=btn[d0] || ({});$(g3C,{class:_this[i7][O2E][c2V] + (btn[Z5]?O3x + btn[b$]:D3I)})[c1](typeof text === L$?text(_this):text || D3I)[g9](N0,btn[v1] !== undefined?btn[P5]:U3X)[r0r](attr)[z1](G0,function(e){var d0z="hic";var J5=R$a;J5+=d0z;J5+=L8X;if(e[J5] === F07 && action){var j$=r7lc_[631343];j$+=M4$;j$+=h8z;action[j$](_this);}})[e40](e1,function(e){r7lc_.w49();var D1Y="ventDefault";if(e[b_C] === F07){var e6=S7d;e6+=D1Y;e[e6]();}})[e40](d8,function(e){e[E8h]();if(action){var M2=r7lc_[631343];M2+=M4$;M2+=v4k;M2+=v4k;action[M2](_this,e);}})[w0](_this[l0][Y0_]);});return this;}function clear(fieldName){var s9U="inA";var t2c="estroy";var that=this;var sFields=this[l4$][b7d];if(typeof fieldName === X0M){var f3=s9U;f3+=g$A;f3+=g$A;f3+=v7E;var w1=u05;w1+=r9T;w1+=r7lc_[631343];w1+=E_j;var m0=B_4;m0+=g$A;m0+=E_x;var W5=X2M;W5+=t2c;var v2=r7lc_.q78;v2+=s7Z;v2+=X2M;that[v2](fieldName)[W5]();delete sFields[fieldName];var orderIdx=$[U7Z](fieldName,this[l4$][X6a]);this[l4$][m0][w1](orderIdx,F9J);var includeIdx=$[f3](fieldName,this[l4$][T0k]);if(includeIdx !== -F9J){this[l4$][T0k][S8Q](includeIdx,F9J);}}else {$[n8S](this[q4E](fieldName),function(i,name){var N3o="clear";that[N3o](name);});}return this;}function close(){r7lc_.y2x();this[g7m](B4$);return this;}function create(arg1,arg2,arg3,arg4){var g2Y="itCre";var o34="reate";var p2G="Fiel";var H0f="onClas";var J3S="fiel";var a69="_displayR";var c7Q="eorder";var P6D="editFi";var h7S="_acti";var c$=k0f;c$+=g2Y;c$+=j80;var O2=t95;O2+=r7lc_.I0t;var P6=J3S;P6+=S1y;var p6=a69;p6+=c7Q;var f_=h7S;f_+=H0f;f_+=l4$;var e3=v7d;e3+=r7lc_[631343];e3+=O5j;var A5=z5G;A5+=R1v;var A_=a7V;A_+=R1v;A_+=q_1;var f1=r7lc_.q78;f1+=B_4;f1+=g$A;f1+=J8U;var F1=r7lc_[631343];F1+=o34;var r9=w9w;r9+=B_4;r9+=r7lc_[616964];var Q$=D_b;Q$+=E_j;var l7=v0L;l7+=p2G;l7+=S1y;var a9=i3B;a9+=r7lc_.I0t;a9+=e4a;a9+=R1v;var _this=this;var that=this;var sFields=this[l4$][b7d];var count=F9J;if(this[a9](function(){var K5=r7lc_[631343];K5+=h2t;K5+=M4$;K5+=H_8;that[K5](arg1,arg2,arg3,arg4);})){return this;}if(typeof arg1 === S_J){count=arg1;arg1=arg2;arg2=arg3;}this[l4$][l7]={};for(var i=U3X;i < count;i++){var B3=r7lc_.q78;B3+=O6E;B3+=E_j;B3+=l01;var c4=P6D;c4+=F6Q;c4+=S1y;this[l4$][c4][i]={fields:this[l4$][B3]};}var argOpts=this[A1F](arg1,arg2,arg3,arg4);this[l4$][Q$]=J2x;this[l4$][r9]=F1;this[l4$][p4N]=v5D;this[H$1][f1][A_][A5]=e3;this[f_]();this[p6](this[P6]());$[n8S](sFields,function(name,fieldIn){var w3n="ltiSet";var p$=X2M;p$+=E_j;p$+=r7lc_.q78;var X7=A6N;X7+=g3i;X7+=Z_p;r7lc_.w49();X7+=r7lc_.I0t;fieldIn[X7]();for(var i=U3X;i < count;i++){var Q2=X2M;Q2+=E_j;Q2+=r7lc_.q78;var Y0=s3q;Y0+=w3n;fieldIn[Y0](i,fieldIn[Q2]());}fieldIn[V93](fieldIn[p$]());});this[O2](c$,v5D,function(){var W3W="_formOp";var N6u="maybeOpen";var R0=M8e;R0+=B8k;var x_=W3W;x_+=a_M;_this[b5Q]();_this[x_](argOpts[R0]);argOpts[N6u]();});return this;}function undependent(parent){var F8M="undependent";var S2w=".ede";var L3=S2w;L3+=D_g;var X5=j35;X5+=X2M;X5+=E_j;var j5=O6E;j5+=l4$;j5+=x1m;j5+=R1v;if(Array[j5](parent)){var t$=v4k;t$+=E_j;t$+=q$x;for(var i=U3X,ien=parent[t$];i < ien;i++){this[F8M](parent[i]);}return this;}$(this[g_V](parent)[X5]())[i2_](L3);return this;}function dependent(parent,url,optsIn){var V1H="PO";var l7b="dep";var O$g="cha";var b_=D3k;b_+=E_j;b_+=l7b;var D6=E6d;D6+=Y$n;var L_=B_4;L_+=r7lc_[616964];var e2=j35;e2+=g_x;var V2=O$g;V2+=w6p;V2+=E_j;var w$=E_j;w$+=q40;w$+=v1N;var D9=V1H;D9+=z7s;D9+=z73;var I9=o$u;I9+=e40;var r2=r1M;r2+=o32;r2+=N7x;r2+=R1v;var _this=this;if(Array[r2](parent)){for(var i=U3X,ien=parent[b_m];i < ien;i++){this[Z3a](parent[i],url,optsIn);}return this;}var that=this;var parentField=this[g_V](parent);var ajaxOpts={dataType:I9,type:D9};var opts=$[w$]({},{data:v5D,event:V2,postUpdate:v5D,preUpdate:v5D},optsIn);var update=function(json){var S9v='show';var c$Z="messa";var A4C="labe";var j7G="ostUpda";var w7G="preUpdate";var R9w="pdat";var d7e='hide';var Y_I="postUpdate";var X8=D_g;X8+=j7G;X8+=H_8;var C2=E_j;C2+=k2b;C2+=T69;C2+=q_1;var Z_=b$b;Z_+=M4$;Z_+=v4k;var u8=j1j;u8+=R9w;u8+=E_j;var P8=c$Z;P8+=z5X;P8+=E_j;var Y6=A4C;Y6+=v4k;var p1=E_j;p1+=g$A;p1+=g$A;p1+=G2G;if(opts[w7G]){opts[w7G](json);}$[n8S]({errors:p1,labels:Y6,messages:P8,options:u8,values:Z_},function(jsonProp,fieldFn){r7lc_.y2x();if(json[jsonProp]){var O9=E_j;O9+=M4$;O9+=r7lc_[631343];O9+=L8X;$[O9](json[jsonProp],function(fieldIn,valIn){var B_=r7lc_.q78;B_+=H$7;that[B_](fieldIn)[fieldFn](valIn);});}});$[n8S]([d7e,S9v,C2,Z07],function(i,key){r7lc_.w49();if(json[key]){that[key](json[key],json[T1N]);}});if(opts[X8]){opts[Y_I](json);}parentField[c0j](B4$);};$(parentField[e2]())[L_](opts[D6] + b_,function(e){var d4s="lues";var X3j="rget";var L5M=q2O;L5M+=d4s;var M2i=Q8O;M2i+=v9c;var e0=g$A;e0+=B_4;e0+=v9c;var w6=g$A;w6+=z5R;var P0=h1q;P0+=X3j;if($(parentField[x2p]())[B5B](e[P0])[b_m] === U3X){return;}parentField[c0j](E6A);var data={};data[y5t]=_this[l4$][P8d]?pluck(_this[l4$][P8d],y01):v5D;data[w6]=data[e0]?data[M2i][U3X]:v5D;data[L5M]=_this[w81]();r7lc_.y2x();if(opts[E15]){var ret=opts[E15](data);if(ret){data=ret;}}if(typeof url === K0g){var G65=b$b;G65+=w7Q;var o=url[e27](_this,parentField[G65](),data,update,e);if(o){var i2A=r7lc_.I0t;i2A+=L8X;i2A+=E_j;i2A+=r7lc_[616964];var l51=B_4;l51+=w61;l51+=r7lc_.I0t;if(typeof o === l51 && typeof o[i2A] === K0g){o[y65](function(resolved){r7lc_.y2x();if(resolved){update(resolved);}});}else {update(o);}}}else {var i8M=j7C;i8M+=r7lc_.I0t;i8M+=v1N;var j6O=Z7U;j6O+=M4$;j6O+=D34;if($[M4d](url)){var S53=O6h;S53+=a8w;S53+=X2M;$[S53](ajaxOpts,url);}else {var c7p=j1j;c7p+=g$A;c7p+=v4k;ajaxOpts[c7p]=url;}$[j6O]($[i8M](ajaxOpts,{data:data,success:update}));}});return this;}function destroy(){var c$g="uni";var z1a="plate";var m5z="que";var K3N="oller";var i4S="displayContr";var a57="troy";var q3t=c$g;q3t+=m5z;var K3W=D3k;K3W+=X2M;K3W+=H_8;var A2v=B_4;A2v+=r7lc_.q78;A2v+=r7lc_.q78;var T_L=i4S;T_L+=K3N;var g$0=v3_;g$0+=z1a;var W30=h7_;W30+=E_j;W30+=M4$;W30+=g$A;var x_Z=d6a;r7lc_.y2x();x_Z+=D_g;x_Z+=E$9;if(this[l4$][x_Z]){var d23=r7lc_[631343];d23+=v4k;d23+=B_4;d23+=Z_p;this[d23]();}this[W30]();if(this[l4$][g$0]){var u6Q=T69;u6Q+=B_4;u6Q+=X2M;u6Q+=R1v;$(u6Q)[C__](this[l4$][o94]);}var controller=this[l4$][T_L];if(controller[q0S]){var m4f=g_x;m4f+=l4$;m4f+=a57;controller[m4f](this);}$(document)[A2v](K3W + this[l4$][q3t]);this[H$1]=v5D;this[l4$]=v5D;}function disable(name){var C9T="dNam";var l9i="_fie";var b6M=l9i;b6M+=v4k;b6M+=C9T;r7lc_.w49();b6M+=s4U;var that=this;$[n8S](this[b6M](name),function(i,n){r7lc_.w49();that[g_V](n)[x0T]();});return this;}function display(showIn){if(showIn === undefined){var v4C=A9N;v4C+=u05;v4C+=i$q;v4C+=C_h;return this[l4$][v4C];}return this[showIn?o_e:M9H]();}function displayed(){r7lc_.w49();var I4K=o7b;I4K+=E_j;I4K+=l01;return $[S6L](this[l4$][I4K],function(fieldIn,name){r7lc_.y2x();return fieldIn[m1n]()?name:v5D;});}function displayNode(){var d6_="ller";var Z4y="layCo";var Y8D="ntro";var l6_=w2n;l6_+=Z4y;l6_+=Y8D;l6_+=d6_;return this[l4$][l6_][x2p](this);}function edit(items,arg1,arg2,arg3,arg4){var Q$l="_cr";var X5q="dArgs";var Q_3=M8e;Q_3+=r7lc_.I0t;Q_3+=l4$;var E$g=o7b;E$g+=L1Y;E$g+=l4$;var h8A=i3B;h8A+=C_h;h8A+=O6E;h8A+=r7lc_.I0t;var p05=Q$l;p05+=j1j;p05+=X5q;r7lc_.w49();var _this=this;var that=this;if(this[y0k](function(){var t13=E_j;t13+=X_o;r7lc_.y2x();that[t13](items,arg1,arg2,arg3,arg4);})){return this;}var argOpts=this[p05](arg1,arg2,arg3,arg4);this[h8A](items,this[f3Q](E$g,items),J2x,argOpts[Q_3],function(){var Q3t="bleM";var a$J="maybeOp";var Z6S="_assem";var t7x="_formOptions";var w$T="ain";var n2C=a$J;n2C+=a8w;r7lc_.w49();var G29=Z6S;G29+=Q3t;G29+=w$T;_this[G29]();_this[t7x](argOpts[k6u]);argOpts[n2C]();});return this;}function enable(name){var l39="_fieldN";var K21=l39;K21+=Y0t;var N9_=E_j;N9_+=M4$;N9_+=r7lc_[631343];N9_+=L8X;var that=this;$[N9_](this[K21](name),function(i,n){r7lc_.w49();that[g_V](n)[u_V]();});return this;}function error$1(name,msg){var n1A="alErro";var m24="_message";var W5p="glob";var q7P=X2M;q7P+=B_4;q7P+=J8U;var wrapper=$(this[q7P][V3F]);if(msg === undefined){var u7Q=W5p;u7Q+=n1A;u7Q+=g$A;var h36=X2M;h36+=B_4;h36+=J8U;this[m24](this[h36][O89],name,E6A,function(){var D7S="rmError";var Q7N="inFo";var h5h=Q7N;h5h+=D7S;wrapper[U9h](h5h,name !== undefined && name !== D3I);});this[l4$][u7Q]=name;}else {this[g_V](name)[S_q](msg);}return this;}function field(name){var F4A='Unknown field name - ';var sFields=this[l4$][b7d];if(!sFields[name]){throw new Error(F4A + name);}return sFields[name];}function fields(){var N$I=r7lc_.q78;N$I+=s7Z;N$I+=X2M;N$I+=l4$;var s1x=J8U;s1x+=M4$;r7lc_.y2x();s1x+=D_g;return $[s1x](this[l4$][N$I],function(fieldIn,name){r7lc_.w49();return name;});}function file(name,id){var f2k="n table ";var k7H=" i";var W7i='Unknown file id ';var j2a=r7lc_.q78;j2a+=L$D;var tableFromFile=this[j2a](name);r7lc_.w49();var fileFromTable=tableFromFile[id];if(!fileFromTable){var Q0v=k7H;Q0v+=f2k;throw new Error(W7i + id + Q0v + name);}return tableFromFile[id];}function files(name){var k0e='Unknown file table name: ';r7lc_.w49();if(!name){var r6P=o7b;r6P+=m4H;return Editor[r6P];}var editorTable=Editor[i9z][name];if(!editorTable){throw new Error(k0e + name);}return editorTable;}function get(name){var c8X=z5X;c8X+=s7X;var a0S=r7lc_.q78;a0S+=O6E;r7lc_.y2x();a0S+=F6Q;a0S+=X2M;var M3r=s08;M3r+=X1O;M3r+=R1v;var that=this;if(!name){var b23=o7b;b23+=E_j;b23+=l01;name=this[b23]();}if(Array[M3r](name)){var out_1={};$[n8S](name,function(i,n){var O5C=z5X;r7lc_.y2x();O5C+=E_j;O5C+=r7lc_.I0t;out_1[n]=that[g_V](n)[O5C]();});return out_1;}return this[a0S](name)[c8X]();}function hide(names,animate){r7lc_.w49();var that=this;$[n8S](this[q4E](names),function(i,n){var G2d=L8X;G2d+=O6E;G2d+=X2M;G2d+=E_j;var P0U=r7lc_.q78;P0U+=O6E;P0U+=F6Q;P0U+=X2M;that[P0U](n)[G2d](animate);});return this;}function ids(includeHash){var H_r=b2D;H_r+=E$1;var m$T=J8U;r7lc_.y2x();m$T+=M4$;m$T+=D_g;if(includeHash === void U3X){includeHash=B4$;}return $[m$T](this[l4$][H_r],function(editIn,idSrc){r7lc_.w49();return includeHash === E6A?I5b + idSrc:idSrc;});}function inError(inNames){var B0f="globalError";r7lc_.w49();var H8x=v4k;H8x+=E_j;H8x+=r7lc_[616964];H8x+=H76;var q0o=i3B;q0o+=g_V;q0o+=f9k;q0o+=Y0t;var p66=H$2;p66+=J8U;$(this[p66][O89]);if(this[l4$][B0f]){return E6A;}var names=this[q0o](inNames);for(var i=U3X,ien=names[H8x];i < ien;i++){var S9q=r7lc_.q78;S9q+=H$7;if(this[S9q](names[i])[d3v]()){return E6A;}}return B4$;}function inline(cell,fieldName,opts){var W3K="Cannot edit mor";var H1X="e than one row inline";var m35="inl";var F2F=" at a ti";var J0s="individua";var t78="ys";var V0u=q_1;V0u+=s2T;V0u+=L8X;var W3_=O5j;W3_+=E_j;W3_+=t78;var R6k=J0s;R6k+=v4k;var r44=C0r;r44+=B_4;r44+=E_Q;r44+=K0$;var i91=m35;i91+=O6E;i91+=r7lc_[616964];i91+=E_j;var _this=this;var that=this;if($[M4d](fieldName)){opts=fieldName;fieldName=undefined;}opts=$[b$J]({},this[l4$][P2i][i91],opts);var editFields=this[r44](R6k,cell,fieldName);var keys=Object[W3_](editFields);if(keys[V0u] > F9J){var S1D=W3K;S1D+=H1X;S1D+=F2F;S1D+=F4j;throw new Error(S1D);}var editRow=editFields[keys[U3X]];var hosts=[];for(var _i=U3X,_a=editRow[A$l];_i < _a[b_m];_i++){var row=_a[_i];hosts[r4r](row);}if($(j$E,hosts)[b_m]){return this;}if(this[y0k](function(){r7lc_.y2x();var I9T=k0f;I9T+=v4k;I9T+=k0f;I9T+=E_j;that[I9T](cell,fieldName,opts);})){return this;}this[b4L](cell,editFields,n0l,opts,function(){r7lc_.w49();_this[B6p](editFields,opts);});return this;}function inlineCreate(insertPoint,opts){var y4P="fak";var t5x="eR";var c3b="dif";var r3c="_ac";var w4R="nlin";var d2N='initCreate';var y4y="Fields";var P$g="tionClass";var n$t=P0D;n$t+=q0d;var j3F=v0L;j3F+=y4y;var Q$K=i3B;Q$K+=O6E;Q$K+=w4R;Q$K+=E_j;var W5c=r3c;W5c+=P$g;var z3H=j7C;z3H+=k8D;var V3c=y4P;V3c+=t5x;V3c+=z5R;var Z4x=D7o;Z4x+=c3b;Z4x+=M$3;Z4x+=g$A;var F$f=e8A;F$f+=K5f;F$f+=e40;var S9s=r7lc_.q78;S9s+=M$3;S9s+=l01;var l1m=E_j;l1m+=m4P;var _this=this;if($[M4d](insertPoint)){opts=insertPoint;insertPoint=v5D;}if(this[y0k](function(){r7lc_.w49();_this[C8u](insertPoint,opts);})){return this;}$[l1m](this[l4$][S9s],function(name,fieldIn){var k2i="iSe";var b$l="Reset";var k9x=X2M;k9x+=E_j;k9x+=r7lc_.q78;var Z7d=X2M;Z7d+=E_j;Z7d+=r7lc_.q78;var c3W=q7Z;c3W+=r7lc_.I0t;c3W+=k2i;c3W+=r7lc_.I0t;var E$u=M8p;E$u+=b$l;fieldIn[E$u]();fieldIn[c3W](U3X,fieldIn[Z7d]());fieldIn[V93](fieldIn[k9x]());});this[l4$][o$P]=J2x;this[l4$][F$f]=A9E;this[l4$][Z4x]=v5D;this[l4$][P8d]=this[f3Q](V3c,insertPoint);opts=$[z3H]({},this[l4$][P2i][T6X],opts);this[W5c]();this[Q$K](this[l4$][j3F],opts,function(){var m97='fakeRowEnd';var a15="_dat";var n2w="aS";var F8m=a15;F8m+=n2w;F8m+=W_T;r7lc_.y2x();_this[F8m](m97);});this[n$t](d2N,v5D);return this;}function message(name,msg){var U71="essage";r7lc_.y2x();var I3w="formInfo";if(msg === undefined){var J7B=X2M;J7B+=L3D;var s09=i3B;s09+=J8U;s09+=U71;this[s09](this[J7B][I3w],name);}else {var E1N=W6Z;E1N+=b0k;this[g_V](name)[E1N](msg);}return this;}function mode(modeIn){var v9p='Not currently in an editing mode';var O5G='Changing from create mode is not supported';r7lc_.w49();var y42=M4$;y42+=N3g;y42+=B_4;y42+=r7lc_[616964];var c1J=r7lc_[631343];c1J+=g$A;c1J+=E_j;c1J+=j80;if(!modeIn){return this[l4$][b5A];}if(!this[l4$][b5A]){throw new Error(v9p);}else if(this[l4$][b5A] === c1J && modeIn !== A9E){throw new Error(O5G);}this[l4$][y42]=modeIn;return this;}function modifier(){return this[l4$][p4N];}function multiGet(fieldNames){var k25="ltiGet";var k4U=J8U;k4U+=j1j;k4U+=k25;var that=this;if(fieldNames === undefined){var J7k=r7lc_.q78;J7k+=H$7;J7k+=l4$;fieldNames=this[J7k]();}if(Array[Z6E](fieldNames)){var M2M=E_j;M2M+=M4$;M2M+=D5x;var out_2={};$[M2M](fieldNames,function(i,name){var k3G=s3q;k3G+=P3D;k3G+=n$L;var M5h=o7b;M5h+=E_j;r7lc_.y2x();M5h+=R7b;out_2[name]=that[M5h](name)[k3G]();});return out_2;}return this[g_V](fieldNames)[k4U]();}function multiSet(fieldNames,valIn){var that=this;if($[M4d](fieldNames) && valIn === undefined){$[n8S](fieldNames,function(name,value){that[g_V](name)[D1h](value);});}else {this[g_V](fieldNames)[D1h](valIn);}return this;}function node(name){var H9O=r7lc_.q78;H9O+=s7Z;H9O+=X2M;var I3b=J8U;I3b+=M4$;I3b+=D_g;var that=this;if(!name){name=this[X6a]();}return Array[Z6E](name)?$[I3b](name,function(n){var J6t=t4y;J6t+=E_j;return that[g_V](n)[J6t]();}):this[H9O](name)[x2p]();}function off(name,fn){var X9w="entNa";var Y1Z=P0D;Y1Z+=X9w;Y1Z+=J8U;Y1Z+=E_j;var z13=B_4;z13+=U4_;$(this)[z13](this[Y1Z](name),fn);return this;}function on(name,fn){var c0V="ntName";r7lc_.w49();var o0V=s8D;o0V+=c0V;var o0v=B_4;o0v+=r7lc_[616964];$(this)[o0v](this[o0V](name),fn);return this;}function one(name,fn){var Y1H="_eventName";$(this)[I3u](this[Y1H](name),fn);return this;}function open(){var O2W=r7lc_;var n$E="neste";var g33="dO";var Q7s="nest";var x1Q=J8U;x1Q+=M4$;x1Q+=O6E;O2W.y2x();x1Q+=r7lc_[616964];var y82=i3B;y82+=n$E;y82+=g33;y82+=P6g;var A5O=k83;A5O+=r7lc_[616964];var _this=this;this[X$k]();this[a0E](function(){var H0A="_nestedClose";O2W.y2x();_this[H0A](function(){var p6U="_clearDynamicInf";var V$U=r7lc_[631343];V$U+=j5F;O2W.w49();V$U+=l4$;V$U+=C_h;var A_m=i3B;A_m+=r_P;A_m+=r7lc_.I0t;var Y51=p6U;Y51+=B_4;_this[Y51]();_this[A_m](V$U,[J2x]);});});var ret=this[A5O](J2x);if(!ret){return this;}this[y82](function(){var P4b=M4$;P4b+=N3g;P4b+=e40;var M3l=U7l;M3l+=r7lc_[616964];M3l+=E_j;M3l+=X2M;O2W.y2x();var W6f=t95;W6f+=r7lc_.I0t;var O4m=r7lc_.q78;O4m+=m9_;var w60=B_4;w60+=g$A;w60+=X2M;w60+=B2h;_this[s2p]($[S6L](_this[l4$][w60],function(name){O2W.w49();return _this[l4$][b7d][name];}),_this[l4$][k1p][O4m]);_this[W6f](M3l,[J2x,_this[l4$][P4b]]);},this[l4$][k1p][Q7s]);this[B4I](x1Q,B4$);return this;}function order(setIn){var W7M="_di";var L35="jo";var B9Q="splayReorder";var N39='All fields, and no additional fields, must be provided for ordering.';var I85="sort";var w35=W7M;w35+=B9Q;var T_e=G2G;T_e+=X2M;T_e+=E_j;T_e+=g$A;var s38=L35;s38+=O6E;s38+=r7lc_[616964];var A9f=H3v;A9f+=O6E;A9f+=K0$;var l8V=L35;l8V+=k0f;var p6y=Z6$;p6y+=Q2T;if(!setIn){return this[l4$][X6a];}if(arguments[p6y] && !Array[Z6E](setIn)){var Z7B=Z5H;Z7B+=v4k;Z7B+=v4k;setIn=Array[C36][p6F][Z7B](arguments);}if(this[l4$][X6a][p6F]()[I85]()[l8V](e5I) !== setIn[A9f]()[I85]()[s38](e5I)){throw new Error(N39);}$[b$J](this[l4$][T_e],setIn);this[w35]();return this;}function remove(items,arg1,arg2,arg3,arg4){var R$o='initRemove';var p2g=t4y;p2g+=E_j;var L6c=y_3;L6c+=L6h;L6c+=Y$n;var C8Z=A9N;C8Z+=l4$;C8Z+=J2$;var E$0=B7d;E$0+=E_j;var y$h=F3m;y$h+=E_j;var Y_h=M4$;Y_h+=h9w;Y_h+=S6x;Y_h+=r7lc_[616964];var Q4c=o7b;Q4c+=L1Y;Q4c+=l4$;var g90=x61;g90+=R0T;var k0U=i3B;k0U+=K5f;k0U+=X2M;k0U+=R1v;var _this=this;var that=this;if(this[k0U](function(){that[u3q](items,arg1,arg2,arg3,arg4);})){return this;}if(!items && !this[l4$][s9i]){var p0n=r4Y;p0n+=O0P;p0n+=m0p;items=p0n;}if(items[b_m] === undefined){items=[items];}var argOpts=this[A1F](arg1,arg2,arg3,arg4);var editFields=this[g90](Q4c,items);r7lc_.w49();this[l4$][Y_h]=y$h;this[l4$][p4N]=items;this[l4$][P8d]=editFields;this[H$1][O2E][E$0][C8Z]=X7g;this[i6h]();this[L6c](R$o,[pluck(editFields,p2g),pluck(editFields,y01),items],function(){var s19="event";var N2O='initMultiRemove';var z8O=i3B;r7lc_.w49();z8O+=s19;_this[z8O](N2O,[editFields,items],function(){var Q3z="uttons";var o7a="ybe";var Z2_=r7lc_.q78;Z2_+=B_4;Z2_+=x$G;Z2_+=l4$;var L0U=x0m;L0U+=o7a;L0U+=i9l;L0U+=P6g;var u2h=q0j;u2h+=h7x;_this[b5Q]();_this[u2h](argOpts[k6u]);argOpts[L0U]();var opts=_this[l4$][k1p];if(opts[Z2_] !== v5D){var C4h=r7lc_.q78;C4h+=m9_;var W2L=T69;W2L+=Q3z;var r$F=X2M;r$F+=B_4;r$F+=J8U;var e9V=R$N;e9V+=r7lc_.I0t;e9V+=r7lc_.I0t;e9V+=e40;$(e9V,_this[r$F][W2L])[B3Q](opts[C4h])[o6n]();}});});return this;}function set(setIn,valIn){var s24="ainOb";var s6T="ject";var C2b="isPl";var e25=s9A;e25+=r7lc_[631343];e25+=L8X;var f5d=C2b;f5d+=s24;f5d+=s6T;var that=this;r7lc_.w49();if(!$[f5d](setIn)){var o={};o[setIn]=valIn;setIn=o;}$[e25](setIn,function(n,v){var P8R=l4$;P8R+=E_j;P8R+=r7lc_.I0t;var P42=r7lc_.q78;P42+=O6E;P42+=F6Q;P42+=X2M;that[P42](n)[P8R](v);});return this;}function show(names,animate){var O61="_fiel";var Z97="dNames";var e44=O61;e44+=Z97;var N1g=l_b;N1g+=L8X;r7lc_.y2x();var that=this;$[N1g](this[e44](names),function(i,n){var X1s=l4$;X1s+=L8X;X1s+=B_4;X1s+=R$a;var a4z=o7b;a4z+=E_j;r7lc_.y2x();a4z+=v4k;a4z+=X2M;that[a4z](n)[X1s](animate);});return this;}function submit(successCallback,errorCallback,formatdata,hideIn){var Q_q="sest";var v6B=E_j;v6B+=M4$;v6B+=D5x;var z1p=s9A;z1p+=r7lc_[631343];z1p+=L8X;var e3H=h7_;e3H+=B_4;e3H+=Q_q;var _this=this;var fields=this[l4$][b7d];r7lc_.y2x();var errorFields=[];var errorReady=U3X;var sent=B4$;if(this[l4$][c0j] || !this[l4$][b5A]){return this;}this[V7L](E6A);var send=function(){var Y3k="itSubmit";var X5v=O6E;X5v+=r7lc_[616964];X5v+=Y3k;var y4e=i3B;y4e+=E6d;y4e+=Y$n;if(errorFields[b_m] !== errorReady || sent){return;}_this[y4e](X5v,[_this[l4$][b5A]],function(result){var Y0g=i3B;Y0g+=a4u;Y0g+=O6E;Y0g+=r7lc_.I0t;if(result === B4$){_this[V7L](B4$);return;}sent=E6A;_this[Y0g](successCallback,errorCallback,formatdata,hideIn);});};var active=document[G4T];if($(active)[e3H](j$E)[b_m] !== U3X){active[D6X]();}this[S_q]();$[z1p](fields,function(name,fieldIn){var V2U="nEr";var r5V=O6E;r5V+=V2U;r5V+=Q8O;r7lc_.w49();r5V+=g$A;if(fieldIn[r5V]()){var N3p=D_g;N3p+=P0J;N3p+=L8X;errorFields[N3p](name);}});$[v6B](errorFields,function(i,name){var f18=M1o;f18+=B_4;r7lc_.y2x();f18+=g$A;fields[name][f18](D3I,function(){errorReady++;send();});});send();return this;}function table(setIn){r7lc_.w49();if(setIn === undefined){return this[l4$][s9i];}this[l4$][s9i]=setIn;return this;}function template(setIn){r7lc_.w49();var v5k="templa";var q8l=v5k;q8l+=r7lc_.I0t;q8l+=E_j;if(setIn === undefined){return this[l4$][o94];}this[l4$][q8l]=setIn === v5D?v5D:$(setIn);return this;}function title(titleIn){var P$K="hi";var f5E="ag";var S1i=A7E;S1i+=l4$;S1i+=l4$;var z9I=j87;z9I+=K9b;z9I+=p5r;var u5A=r7lc_.I0t;u5A+=f5E;var B45=r7lc_.I0t;B45+=M4$;B45+=z5X;var n6s=X2j;n6s+=M4$;n6s+=X2M;r7lc_.y2x();n6s+=B2h;var p1Y=r7lc_[631343];p1Y+=z9q;p1Y+=E_j;p1Y+=l4$;var Q_V=r7lc_[631343];Q_V+=P$K;Q_V+=R7b;Q_V+=c8l;var x9F=L8X;x9F+=E_j;x9F+=M4$;x9F+=E_x;var g9I=H$2;g9I+=J8U;var header=$(this[g9I][x9F])[Q_V](q6u + this[p1Y][n6s][C_y]);var titleClass=this[x6a][X53][D$Q];if(titleIn === undefined){var P5C=X2M;P5C+=M4$;P5C+=r7lc_.I0t;P5C+=M4$;return header[P5C](w76);}if(typeof titleIn === K0g){var R6t=r7lc_.I0t;R6t+=h0p;R6t+=E_j;titleIn=titleIn(this,new DataTable$5[s1J](this[l4$][R6t]));}var set=titleClass[B45]?$(K9b + titleClass[u5A] + z9I + titleClass[c8D])[l7F](titleClass[S1i])[I52](titleIn):titleIn;header[I52](set)[E15](w76,titleIn);return this;}function val(fieldIn,value){var g3H="isPlai";var T0f="nObje";var H39=P99;H39+=r7lc_.I0t;var X7l=g3H;X7l+=T0f;X7l+=h9w;if(value !== undefined || $[X7l](fieldIn)){var z6e=Z_p;z6e+=r7lc_.I0t;return this[z6e](fieldIn,value);}return this[H39](fieldIn);;}function error(msg,tn,thro){var D4i=" For more information, please refer to h";var y3s="warn";var R5M="ttps://da";var s3S="tatables.net/tn/";var e4b=D4i;e4b+=R5M;e4b+=s3S;if(thro === void U3X){thro=E6A;}var display=tn?msg + e4b + tn:msg;if(thro){throw display;}else {console[y3s](display);}}function pairs(data,props,fn){var o2w=b$b;o2w+=L4R;var D5o=V7l;D5o+=T69;D5o+=E_j;D5o+=v4k;var E$6=A91;r7lc_.y2x();E$6+=X2M;var i;var ien;var dataPoint;props=$[E$6]({label:D5o,value:o2w},props);if(Array[Z6E](data)){for((i=U3X,ien=data[b_m]);i < ien;i++){var d$R=C$e;d$R+=p$W;dataPoint=data[i];if($[d$R](dataPoint)){var p_3=V7l;p_3+=T69;p_3+=F6Q;var A99=v4k;A99+=M4$;A99+=T69;A99+=F6Q;var j3z=q2O;j3z+=f9c;j3z+=E_j;fn(dataPoint[props[j3z]] === undefined?dataPoint[props[A99]]:dataPoint[props[F7A]],dataPoint[props[p_3]],i,dataPoint[r0r]);}else {fn(dataPoint,dataPoint,i);}}}else {i=U3X;$[n8S](data,function(key,val){r7lc_.w49();fn(val,key,i);i++;});}}function upload$1(editor,conf,files,progressCallback,completeCallback){var K3h=r7lc_;var Y$$="dA";var g_$="_l";var e48="jax";var y8S="mitLeft";var L4o="ors";var M1U="_limitLeft";var n8q="errors";var z1_="rs";var q7O="r occurred while uploading the file";var P8I="sD";var M2c="A server erro";var p9a="ataURL";var A4_="ax";var W7O="ileReadText";var J9K="onloa";var c1q="<i>Uploading";K3h.y2x();var F3y="rea";var v$x=" file</";var b39=F3y;b39+=Y$$;b39+=P8I;b39+=p9a;var R_p=x0m;R_p+=D_g;var N6M=J9K;N6M+=X2M;var Z1J=c1q;Z1J+=v$x;Z1J+=F9i;var m6z=r7lc_.q78;m6z+=W7O;var E8k=r7lc_.q78;E8k+=X3B;E8k+=r7lc_[399342];var Y_B=M4$;Y_B+=r_k;Y_B+=A4_;var Z5p=M2c;Z5p+=q7O;var Y5k=E_j;Y5k+=I_5;Y5k+=L4o;var R0Z=E_j;R0Z+=I_5;R0Z+=B_4;R0Z+=z1_;var reader=new FileReader();var counter=U3X;var ids=[];var generalError=conf[R0Z] && conf[n8q][i3B]?conf[Y5k][i3B]:Z5p;editor[S_q](conf[P8N],D3I);if(typeof conf[Y_B] === E8k){var D3g=M4$;D3g+=e48;conf[D3g](files,function(idsIn){K3h.w49();completeCallback[e27](editor,idsIn);});return;}progressCallback(conf,conf[m6z] || Z1J);reader[N6M]=function(e){var v_Q="Upload feature cannot use `ajax.data` with an object. Ple";var H0T="pload";var q4F="ase use it as a function instead.";var A8v="No A";var Y1w="jax option specifi";var L_g="ring";var n2h="preUpl";var O7W="ajaxData";var S6N="ed for upload plug-in";var V_d="dFie";var I5M='upload';var T38=r7lc_[616964];T38+=M4$;T38+=J8U;T38+=E_j;var y3F=n2h;y3F+=B_4;y3F+=i4r;var G8B=X2M;G8B+=M4$;G8B+=r7lc_.I0t;G8B+=M4$;var h9$=Q5m;h9$+=r7lc_.I0t;h9$+=O6E;h9$+=e40;var F2W=l4$;F2W+=r7lc_.I0t;F2W+=L_g;var A3T=l4$;A3T+=M_A;A3T+=k0f;A3T+=z5X;var B1E=M4$;B1E+=r_k;B1E+=M4$;B1E+=D34;var B3C=Z7U;B3C+=A4_;var F5y=j1j;F5y+=H0T;var U0W=Q0g;U0W+=V_d;U0W+=R7b;var v8K=M4$;v8K+=E3D;v8K+=v1N;var data=new FormData();var ajax;data[v8K](G7h,I5M);data[C__](U0W,conf[P8N]);data[C__](F5y,files[counter]);if(conf[O7W]){conf[O7W](data,files[counter],counter);}if(conf[B3C]){ajax=conf[Y3a];}else if($[M4d](editor[l4$][Y3a])){var o$r=M4$;o$r+=G4b;o$r+=D34;var d0A=Q0g;d0A+=X2M;ajax=editor[l4$][Y3a][G_$]?editor[l4$][Y3a][d0A]:editor[l4$][o$r];}else if(typeof editor[l4$][B1E] === A3T){ajax=editor[l4$][Y3a];}if(!ajax){var v7f=A8v;v7f+=Y1w;v7f+=S6N;throw new Error(v7f);}if(typeof ajax === F2W){ajax={url:ajax};}if(typeof ajax[E15] === h9$){var e20=E_j;e20+=m4P;var I_3=l4$;I_3+=v3p;var d={};var ret=ajax[E15](d);if(ret !== undefined && typeof ret !== I_3){d=ret;}$[e20](d,function(key,value){data[C__](key,value);});}else if($[M4d](ajax[G8B])){var u5H=v_Q;u5H+=q4F;throw new Error(u5H);}editor[M4P](y3F,[conf[T38],files[counter],data],function(preRet){var O6z="E_Upload";var w9B="taURL";var I9M="Submit.DT";var H92="_Upload";var s93="preSub";var V2j="dAs";var d2F=e8F;d2F+=a7V;var h0g=o$u;h0g+=B_4;h0g+=r7lc_[616964];var O0X=S7d;O0X+=I9M;O0X+=L28;O0X+=H92;var Z5F=B_4;Z5F+=r7lc_[616964];if(preRet === B4$){var m4$=q_1;m4$+=r7lc_[616964];m4$+=A8Q;m4$+=L8X;if(counter < files[m4$] - F9J){var w8I=F3y;w8I+=V2j;w8I+=v0G;w8I+=w9B;counter++;reader[w8I](files[counter]);}else {completeCallback[e27](editor,ids);}return;}var submit=B4$;editor[Z5F](O0X,function(){submit=E6A;K3h.y2x();return B4$;});$[Y3a]($[b$J]({},ajax,{contentType:B4$,data:data,dataType:h0g,error:function(xhr){var M0E="oadXhrError";var F$i="mit.D";var N8H="tu";K3h.w49();var N8T=v9o;N8T+=E_j;var p82=x3_;p82+=M0E;var V0F=i3B;V0F+=X1$;V0F+=q0d;var K3_=l4$;K3_+=h1q;K3_+=N8H;K3_+=l4$;var P4G=r7lc_[616964];P4G+=M4$;P4G+=F4j;var H0s=M1o;H0s+=G2G;var w_U=s93;w_U+=F$i;w_U+=z73;w_U+=O6z;var errors=conf[n8q];editor[i2_](w_U);editor[H0s](conf[P4G],errors && errors[xhr[K3_]]?errors[xhr[B_L]]:generalError);editor[V0F](p82,[conf[N8T],xhr]);progressCallback(conf);},processData:B4$,success:function(json){var E_0='uploadXhrSuccess';var Z6t="AsDataURL";var c6n="ldE";var D3K="t.DT";var g0j="rrors";var l_0="ror";var C8Y="pus";var N2g=O6E;N2g+=X2M;var k1f=y8W;k1f+=B$z;var X_w=q_1;X_w+=r7lc_[616964];X_w+=H76;var H9h=K4t;H9h+=c6n;H9h+=t$z;H9h+=z1_;var s$W=o7b;s$W+=E_j;s$W+=c6n;s$W+=g0j;var S5F=s93;S5F+=M2$;S5F+=D3K;S5F+=O6z;var L_W=B_4;L_W+=r7lc_.q78;L_W+=r7lc_.q78;editor[L_W](S5F);editor[M4P](E_0,[conf[P8N],json]);if(json[s$W] && json[H9h][X_w]){var errors=json[V8o];for(var i=U3X,ien=errors[b_m];i < ien;i++){var s9d=l4$;s9d+=r7lc_.I0t;s9d+=p0h;s9d+=P0J;var M98=r7lc_[616964];M98+=M4$;M98+=J8U;M98+=E_j;var S7g=B2h;S7g+=g$A;S7g+=B_4;S7g+=g$A;editor[S7g](errors[i][M98],errors[i][s9d]);}completeCallback[e27](editor,ids,E6A);}else if(json[S_q]){var X07=Z5H;X07+=v4k;X07+=v4k;var p44=E_j;p44+=g$A;p44+=l_0;editor[p44](json[S_q]);completeCallback[X07](editor,ids,E6A);}else if(!json[k1f] || !json[G_$][N2g]){editor[S_q](conf[P8N],generalError);completeCallback[e27](editor,ids,E6A);}else {var z_e=w$F;z_e+=H76;var i2K=Q0g;i2K+=X2M;var x8S=C8Y;x8S+=L8X;var r6i=k$c;r6i+=l4$;if(json[r6i]){$[n8S](json[i9z],function(table,filesIn){var Z8b=r7lc_.q78;Z8b+=O6E;Z8b+=v4k;Z8b+=s4U;var v$m=r7lc_.q78;v$m+=O9b;v$m+=E_j;v$m+=l4$;if(!Editor[v$m][table]){var W0d=r7lc_.q78;W0d+=L$D;Editor[W0d][table]={};}$[b$J](Editor[Z8b][table],filesIn);});}ids[x8S](json[i2K][e4a]);if(counter < files[z_e] - F9J){var B71=h2t;B71+=i4r;B71+=Z6t;counter++;reader[B71](files[counter]);}else {var R8v=Z5H;R8v+=v4k;R8v+=v4k;completeCallback[R8v](editor,ids);if(submit){var k4d=w3q;k4d+=J8U;k4d+=O6E;k4d+=r7lc_.I0t;editor[k4d]();}}}progressCallback(conf);},type:d2F,xhr:function(){var d76="ogre";var u8l="ajaxSettings";var N5n="onloadend";var F8h="xhr";var B_I="onpr";var xhr=$[u8l][F8h]();if(xhr[G_$]){var I4H=B_I;I4H+=d76;I4H+=m0p;xhr[G_$][I4H]=function(e){var o_u=100;var K9N="toFixed";var M81='%';var f$D=':';var Y$W="putable";var z60="ota";var p3O="lengthCom";var p5P="loaded";var h_t=p3O;h_t+=Y$W;if(e[h_t]){var Y1g=q_1;Y1g+=w6p;Y1g+=r7lc_.I0t;Y1g+=L8X;var g9J=r7lc_.I0t;g9J+=z60;g9J+=v4k;var percent=(e[p5P] / e[g9J] * o_u)[K9N](U3X) + M81;progressCallback(conf,files[b_m] === F9J?percent:counter + f$D + files[Y1g] + O3x + percent);}};xhr[G_$][N5n]=function(){var R3x="processingText";var G1B="Proce";var k5T=G1B;k5T+=l4$;k5T+=D2u;progressCallback(conf,conf[R3x] || k5T);};}return xhr;}}));});};files=$[R_p](files,function(val){K3h.y2x();return val;});if(conf[M1U] !== undefined){var Y1p=q_1;Y1p+=q$x;var u1Z=g_$;u1Z+=O6E;u1Z+=y8S;var j3$=l4$;j3$+=D_g;j3$+=r9T;j3$+=K0$;files[j3$](conf[u1Z],files[Y1p]);}reader[b39](files[U3X]);}function factory(root,jq){var Z_4="docume";var h62="uer";var Q5k=r_k;Q5k+=x1k;Q5k+=h62;Q5k+=R1v;var S_B=r7lc_.q78;S_B+=r7lc_[616964];var is=B4$;r7lc_.y2x();if(root && root[r7lc_.g6k]){var v4T=Z_4;v4T+=Y$n;window=root;document=root[v4T];}if(jq && jq[S_B] && jq[T5x][Q5k]){$=jq;is=E6A;}return is;}var DataTable$4=$[T5x][o5o];var _inlineCounter=U3X;function _actionClass(){var A_9="las";var R1Q="dC";var y2_=C_h;y2_+=O6E;y2_+=r7lc_.I0t;var s2V=J5p;r7lc_.w49();s2V+=p0h;s2V+=E_j;var z5x=r_k;z5x+=B_4;z5x+=O6E;z5x+=r7lc_[616964];var p2v=h2t;p2v+=D7o;p2v+=b$b;p2v+=E_j;var g5B=X2M;g5B+=B_4;g5B+=J8U;var V7P=e8A;V7P+=r7lc_.I0t;V7P+=e7D;var m5i=r7lc_[631343];m5i+=A_9;m5i+=Z_p;m5i+=l4$;var classesActions=this[m5i][V7P];var action=this[l4$][b5A];var wrapper=$(this[g5B][V3F]);wrapper[F15]([classesActions[n3q],classesActions[v0L],classesActions[p2v]][z5x](O3x));if(action === s2V){wrapper[l7F](classesActions[n3q]);}else if(action === y2_){var i2B=b2D;i2B+=r7lc_.I0t;wrapper[l7F](classesActions[i2B]);}else if(action === c12){var Q00=i4r;Q00+=R1Q;Q00+=z9q;wrapper[Q00](classesActions[u3q]);}}function _ajax(data,success,error,submitParams){var a6W="P";var x0L="deleteBody";var u6O="hift";var S3U="OST";var u1M="place";var F9b=/{id}/;var P5g='json';var x2q="cements";var u24='idSrc';var g8n='?';var l3A="uns";var U34="url";var E8b=/_id_/;var K7l="replacements";var g1R="ELE";var M7d="param";var L0c="complete";var e8L="pla";var L0h=t6W;L0h+=g1R;L0h+=X58;var Q13=X2M;r7lc_.y2x();Q13+=M4$;Q13+=h1q;var B_V=U7C;B_V+=v4k;B_V+=M4$;B_V+=K0$;var h$z=g$A;h$z+=E_j;h$z+=u1M;var k69=E_Q;k69+=v4k;var E07=g$A;E07+=E_j;E07+=e8L;E07+=x2q;var P$$=a7V;P$$+=g$A;P$$+=k0f;P$$+=z5X;var W2o=C_h;W2o+=c34;var H2T=a6W;H2T+=S3U;var action=this[l4$][b5A];var thrown;var opts={complete:[function(xhr,text){var l6q="onseTe";var F2R="SON";var g4h="resp";var H3D=204;var J4F="seJS";var U9r="tat";var B4r="responseJ";var z4_='null';var N19="responseText";var W3w=400;var U_I="respon";var json=v5D;if(xhr[B_L] === H3D || xhr[N19] === z4_){json={};}else {try{var U8c=g4h;U8c+=l6q;U8c+=D34;U8c+=r7lc_.I0t;var w7u=D_g;w7u+=M4$;w7u+=g$A;w7u+=Z_p;var R1O=B4r;R1O+=F2R;var n$A=U_I;n$A+=J4F;n$A+=i9l;n$A+=f9k;json=xhr[n$A]?xhr[R1O]:JSON[w7u](xhr[U8c]);}catch(e){}}if($[M4d](json) || Array[Z6E](json)){var f1_=l4$;f1_+=U9r;f1_+=j1j;f1_+=l4$;success(json,xhr[f1_] >= W3w,xhr);}else {error(xhr,text,thrown);}}],data:v5D,dataType:P5g,error:[function(xhr,text,err){thrown=err;}],success:[],type:H2T};var a;var ajaxSrc=this[l4$][Y3a];var id=action === W2o || action === c12?pluck(this[l4$][P8d],u24)[R6n](R0a):v5D;if($[M4d](ajaxSrc) && ajaxSrc[action]){ajaxSrc=ajaxSrc[action];}if(typeof ajaxSrc === K0g){var A$J=r7lc_[631343];A$J+=M4$;A$J+=v4k;A$J+=v4k;ajaxSrc[A$J](this,v5D,v5D,data,success,error);return;}else if(typeof ajaxSrc === P$$){if(ajaxSrc[z2k](O3x) !== -F9J){var T$F=j1j;T$F+=g$A;T$F+=v4k;var u0N=g7p;u0N+=E_j;var G1o=l4$;G1o+=D_g;G1o+=r9T;G1o+=r7lc_.I0t;a=ajaxSrc[G1o](O3x);opts[u0N]=a[U3X];opts[T$F]=a[F9J];}else {var u5k=j1j;u5k+=g$A;u5k+=v4k;opts[u5k]=ajaxSrc;}}else {var optsCopy=$[b$J]({},ajaxSrc || ({}));if(optsCopy[L0c]){var Q8e=g9q;Q8e+=J8U;Q8e+=f7$;var x2Y=p9C;x2Y+=M5f;x2Y+=r7lc_.I0t;x2Y+=E_j;opts[L0c][I04](optsCopy[x2Y]);delete optsCopy[Q8e];}if(optsCopy[S_q]){var T_9=E_j;T_9+=t$z;T_9+=g$A;var a3G=l3A;a3G+=u6O;var C6R=M1o;C6R+=G2G;opts[C6R][a3G](optsCopy[T_9]);delete optsCopy[S_q];}opts=$[b$J]({},opts,optsCopy);}if(opts[E07]){$[n8S](opts[K7l],function(key,repl){var I$5='{';var F_i='}';var c6B=j1j;c6B+=g$A;c6B+=v4k;opts[U34]=opts[c6B][q6o](I$5 + key + F_i,repl[e27](this,key,id,action,data));});}opts[U34]=opts[k69][h$z](E8b,id)[B_V](F9b,id);if(opts[Q13]){var T6B=X2M;T6B+=M4$;T6B+=r7lc_.I0t;T6B+=M4$;var Q2s=X2M;Q2s+=Y$P;var a1F=k0r;a1F+=h1q;var isFn=typeof opts[a1F] === K0g;var newData=isFn?opts[Q2s](data):opts[T6B];data=isFn && newData?newData:$[b$J](E6A,data,newData);}opts[E15]=data;if(opts[U5U] === L0h && (opts[x0L] === undefined || opts[x0L] === E6A)){var params=$[M7d](opts[E15]);opts[U34]+=opts[U34][z2k](g8n) === -F9J?g8n + params:d0S + params;delete opts[E15];}$[Y3a](opts);}function _animate(target,style,time,callback){if($[T5x][T1N]){var B6W=a7V;B6W+=M8e;target[B6W]()[T1N](style,time,callback);}else {var S93=Q5m;S93+=K5f;S93+=e40;var J0$=u3g;J0$+=l4$;target[J0$](style);var scope=target[b_m] && target[b_m] > F9J?target[U3X]:target;if(typeof time === S93){time[e27](scope);}else if(callback){callback[e27](scope);}}}function _assembleMain(){var B7W="bodyConten";var o3F=H1k;o3F+=g$A;o3F+=J8U;var F5P=f8o;F5P+=E_j;F5P+=r7lc_[616964];F5P+=X2M;var Z43=O2E;Z43+=R8R;Z43+=G0e;Z43+=B_4;var i3E=B7W;i3E+=r7lc_.I0t;var I5h=R$N;I5h+=r7lc_.I0t;I5h+=S3h;I5h+=h7x;var d3x=D47;d3x+=r7lc_[616964];d3x+=X2M;var g1g=H1k;g1g+=B_4;g1g+=r7lc_.I0t;g1g+=B2h;var U0N=i0T;U0N+=E_x;var U9g=j8y;U9g+=v_a;var t0C=X2M;t0C+=B_4;t0C+=J8U;var dom=this[t0C];r7lc_.y2x();$(dom[V3F])[U9g](dom[U0N]);$(dom[g1g])[C__](dom[O89])[d3x](dom[I5h]);$(dom[i3E])[C__](dom[Z43])[F5P](dom[o3F]);}function _blur(){var T09="nB";var G5$='preBlur';var H95=Q5m;H95+=r7lc_.I0t;H95+=O6E;H95+=e40;var r$2=i3B;r$2+=E_j;r$2+=k5x;var D5D=B_4;D5D+=T09;D5D+=f9c;r7lc_.w49();D5D+=g$A;var opts=this[l4$][k1p];var onBlur=opts[D5D];if(this[r$2](G5$) === B4$){return;}if(typeof onBlur === H95){onBlur(this);}else if(onBlur === Q3I){var G4U=w3q;G4U+=J8U;G4U+=O6E;G4U+=r7lc_.I0t;this[G4U]();}else if(onBlur === M9H){this[g7m]();}}function _clearDynamicInfo(errorsOnly){var T36="iv.";r7lc_.w49();var e1D="erro";var D0e=e1D;D0e+=g$A;var B1z=s9A;B1z+=D5x;var y1s=R$a;y1s+=G8G;y1s+=B2h;var O6_=X2M;O6_+=B_4;O6_+=J8U;var t5Y=X2M;t5Y+=T36;var G5Z=K4t;G5Z+=R7b;var D_y=h7_;D_y+=M4$;D_y+=m0p;D_y+=s4U;if(errorsOnly === void U3X){errorsOnly=B4$;}if(!this[l4$]){return;}var errorClass=this[D_y][G5Z][S_q];var fields=this[l4$][b7d];$(t5Y + errorClass,this[O6_][y1s])[F15](errorClass);$[B1z](fields,function(name,field){var H8$="ssage";field[S_q](D3I);if(!errorsOnly){var f4P=J8U;f4P+=E_j;f4P+=H8$;field[f4P](D3I);}});this[D0e](D3I);if(!errorsOnly){this[J7h](D3I);}}function _close(submitComplete,mode){var K2l="eI";var b9y="Icb";var F99="-focus";var g3s="cb";var X0C='preClose';var n66="closeI";var S4$='closed';var H54="focus.editor";var h2_=r7lc_[631343];h2_+=v4k;h2_+=B_4;h2_+=Z_p;var K$v=N7c;K$v+=Z2R;var p0Y=H54;p0Y+=F99;var q9H=B_4;q9H+=r7lc_.q78;q9H+=r7lc_.q78;var i53=T69;i53+=B_4;i53+=X2M;i53+=R1v;var r7e=R7l;r7e+=Z_p;r7e+=b9y;var r8O=y_3;r8O+=b$b;r8O+=a8w;r8O+=r7lc_.I0t;var closed;if(this[r8O](X0C) === B4$){return;}if(this[l4$][J6M]){closed=this[l4$][J6M](submitComplete,mode);this[l4$][J6M]=v5D;}if(this[l4$][r7e]){var Z9O=R7l;Z9O+=l4$;Z9O+=K2l;Z9O+=g3s;var Y$q=n66;Y$q+=g3s;this[l4$][Y$q]();this[l4$][Z9O]=v5D;}$(i53)[q9H](p0Y);this[l4$][K$v]=B4$;this[M4P](h2_);if(closed){this[M4P](S4$,[closed]);}}function _closeReg(fn){r7lc_.y2x();this[l4$][J6M]=fn;}function _crudArgs(arg1,arg2,arg3,arg4){var n5P="ptions";var V8d="main";var N8k=A4X;N8k+=J8U;r7lc_.w49();N8k+=i9l;N8k+=n5P;var that=this;var title;var buttons;var show;var opts;if($[M4d](arg1)){opts=arg1;}else if(typeof arg1 === i$u){show=arg1;opts=arg2;;}else {title=arg1;buttons=arg2;show=arg3;opts=arg4;;}if(show === undefined){show=E6A;}if(title){that[D$Q](title);}if(buttons){var d1x=T69;d1x+=K1d;d1x+=l4$;that[d1x](buttons);}return {maybeOpen:function(){if(show){var v0u=B_4;v0u+=D_g;v0u+=E_j;v0u+=r7lc_[616964];that[v0u]();}},opts:$[b$J]({},this[l4$][N8k][V8d],opts)};}function _dataSource(name){var f7G="taSources";var z1j="dataSourc";var e2S=z1j;e2S+=s4U;var x8p=X2M;x8p+=p0h;x8p+=r7lc_.z$V;var W$j=X2M;r7lc_.w49();W$j+=M4$;W$j+=f7G;var E3H=q_1;E3H+=s2T;E3H+=L8X;var args=[];for(var _i=F9J;_i < arguments[E3H];_i++){args[_i - F9J]=arguments[_i];}var dataSource=this[l4$][s9i]?Editor[W$j][x8p]:Editor[e2S][I52];var fn=dataSource[name];if(fn){var m5D=H19;m5D+=D_g;m5D+=v4k;m5D+=R1v;return fn[m5D](this,args);}}function _displayReorder(includeFields){var u9X="includeFi";var D58="late";var y0V="formContent";var I3n="hildren";var p0T="playOrde";var q6l=M4$;q6l+=N3g;q6l+=e40;var h$M=X2M;h$M+=r1M;h$M+=p0T;h$M+=g$A;var B5u=E_j;B5u+=m4P;var H6A=A1D;H6A+=L8X;var F4T=r7lc_[631343];F4T+=I3n;var f1b=H_8;f1b+=J8U;f1b+=D_g;f1b+=D58;var _this=this;var formContent=$(this[H$1][y0V]);var fields=this[l4$][b7d];var order=this[l4$][X6a];var template=this[l4$][f1b];var mode=this[l4$][o$P] || J2x;if(includeFields){this[l4$][T0k]=includeFields;}else {var z0u=u9X;z0u+=L1Y;z0u+=l4$;includeFields=this[l4$][z0u];}formContent[F4T]()[H6A]();$[B5u](order,function(i,name){r7lc_.w49();var C6X="_weakInArray";var Q87="editor-fi";var q3A="eld[name=";var J3h='[data-editor-template="';if(_this[C6X](name,includeFields) !== -F9J){if(template && mode === J2x){var r5q=j35;r5q+=X2M;r5q+=E_j;var i5o=f8o;i5o+=E_j;i5o+=r7lc_[616964];i5o+=X2M;var p7q=X2D;p7q+=D31;var Q$2=r7lc_.q78;Q$2+=O6E;Q$2+=r7lc_[616964];Q$2+=X2M;var z3E=r7lc_[616964];z3E+=r6s;var M2n=M4$;M2n+=r7lc_.q78;M2n+=Z7e;var a52=Q87;a52+=q3A;a52+=X2D;var u9v=r7lc_.q78;u9v+=O6E;u9v+=r7lc_[616964];u9v+=X2M;template[u9v](a52 + name + U_X)[M2n](fields[name][z3E]());template[Q$2](J3h + name + p7q)[i5o](fields[name][r5q]());}else {var g0F=M4$;g0F+=E3D;g0F+=E_j;g0F+=k88;formContent[g0F](fields[name][x2p]());}}});if(template && mode === J2x){template[e06](formContent);}this[M4P](h$M,[this[l4$][m1n],this[l4$][q6l],formContent]);}function _edit(items,editFields,type,formOptions,setupDone){var G4I=r7lc_;var t2i="difier";var c3$="_displa";var r8a="_action";var z_E='node';var J7u="Reorder";var M$z="toS";var c6H="tEdi";var K06="lic";var N0D=X2M;N0D+=Y$P;var Z7h=O6E;Z7h+=h1w;Z7h+=c6H;Z7h+=r7lc_.I0t;var X$8=y_3;X$8+=b$b;X$8+=E_j;X$8+=Y$n;var p7o=c3$;p7o+=R1v;p7o+=J7u;var Y7Z=v4k;Y7Z+=a8w;Y7Z+=A8Q;Y7Z+=L8X;var i6Y=E_j;i6Y+=M4$;i6Y+=r7lc_[631343];i6Y+=L8X;var b2$=r8a;b2$+=r2b;var n_R=J8U;n_R+=B_4;n_R+=X2M;n_R+=E_j;var i0s=X2M;i0s+=P4s;i0s+=R1v;var b1l=B7d;b1l+=E_j;var j7P=r7lc_.q78;j7P+=d3j;var z84=E_j;G4I.w49();z84+=A9N;z84+=r7lc_.I0t;var l1s=D7o;l1s+=t2i;var d5D=K4t;d5D+=v4k;d5D+=X2M;d5D+=l4$;var _this=this;var fields=this[l4$][d5D];var usedFields=[];var includeInOrder;var editData={};this[l4$][P8d]=editFields;this[l4$][a1h]=editData;this[l4$][l1s]=items;this[l4$][b5A]=z84;this[H$1][j7P][b1l][i0s]=V9L;this[l4$][n_R]=type;this[b2$]();$[i6Y](fields,function(name,field){var M3R="tiR";G4I.y2x();var s46="ValueChec";var K1g="eset";var E$l="Ids";var t_X=J8U;t_X+=j1j;t_X+=I7n;t_X+=E$l;var X5X=i3B;X5X+=M8p;X5X+=s46;X5X+=O5j;var R$p=E_j;R$p+=M4$;R$p+=r7lc_[631343];R$p+=L8X;var x09=q7Z;x09+=M3R;x09+=K1g;field[x09]();includeInOrder=B4$;editData[name]={};$[R$p](editFields,function(idSrc,edit){var n22="playFields";var V5r="multiS";G4I.y2x();var k7Z="displayFields";var p5l="Se";var N75="llDe";var w97="alFrom";var j5w="Array";if(edit[b7d][name]){var f8r=l4$;f8r+=g9q;f8r+=D_g;f8r+=E_j;var Z8Y=H3v;Z8Y+=O6E;Z8Y+=r7lc_[631343];Z8Y+=E_j;var t0B=r1M;t0B+=j5w;var T1W=r7lc_[616964];T1W+=j1j;T1W+=N75;T1W+=V56;var C57=X2M;C57+=M4$;C57+=h1q;var k2m=b$b;k2m+=w97;k2m+=x_S;k2m+=M4$;var val=field[k2m](edit[C57]);var nullDefault=field[T1W]();editData[name][idSrc]=val === v5D?D3I:Array[t0B](val)?val[Z8Y]():val;if(!formOptions || formOptions[f8r] === J1z){var s$_=j2K;s$_+=E_j;s$_+=l01;var A31=j$Q;A31+=z8Z;var q0i=V5r;q0i+=E_j;q0i+=r7lc_.I0t;field[q0i](idSrc,val === undefined || nullDefault && val === v5D?field[L_X]():val,B4$);if(!edit[A31] || edit[s$_][name]){includeInOrder=E6A;}}else {var P_s=d6a;P_s+=n22;if(!edit[P_s] || edit[k7Z][name]){var a2j=A6N;a2j+=O6E;a2j+=p5l;a2j+=r7lc_.I0t;field[a2j](idSrc,val === undefined || nullDefault && val === v5D?field[L_X]():val,B4$);includeInOrder=E6A;}}}});field[X5X]();if(field[t_X]()[b_m] !== U3X && includeInOrder){usedFields[r4r](name);}});var currOrder=this[X6a]()[p6F]();for(var i=currOrder[Y7Z] - F9J;i >= U3X;i--){var o45=M$z;o45+=c6e;o45+=w6p;if($[U7Z](currOrder[i][o45](),usedFields) === -F9J){var m7t=l4$;m7t+=D_g;m7t+=K06;m7t+=E_j;currOrder[m7t](i,F9J);}}this[p7o](currOrder);this[X$8](Z7h,[pluck(editFields,z_E)[U3X],pluck(editFields,N0D)[U3X],items,type],function(){var K2G="itMu";var S2$="ltiEdit";var U3d=k0f;U3d+=K2G;G4I.y2x();U3d+=S2$;_this[M4P](U3d,[editFields,items,type],function(){setupDone();});});}function _event(trigger,args,promiseComplete){var D2e="triggerHandler";var s9a="ven";var O_0="result";var Q0A="erHandle";var O6Z="Event";var m7s='Cancelled';var E6p="trig";var i9E=O6E;i9E+=f06;i9E+=D7T;if(args === void U3X){args=[];}if(promiseComplete === void U3X){promiseComplete=undefined;}if(Array[i9E](trigger)){for(var i=U3X,ien=trigger[b_m];i < ien;i++){this[M4P](trigger[i],args);}}else {var P7o=D_g;P7o+=g$A;P7o+=E_j;var d1S=E6p;d1S+=z5X;d1S+=Q0A;d1S+=g$A;var v9A=L28;v9A+=s9a;v9A+=r7lc_.I0t;var e=$[v9A](trigger);$(this)[d1S](e,args);var result=e[O_0];if(trigger[z2k](P7o) === U3X && result === B4$){$(this)[D2e]($[O6Z](trigger + m7s),args);}if(promiseComplete){var R52=B_4;R52+=w61;R52+=r7lc_.I0t;if(result && typeof result === R52 && result[y65]){var M9R=r7lc_.I0t;M9R+=L8X;M9R+=a8w;result[M9R](promiseComplete);}else {promiseComplete(result);}}return result;}}function _eventName(input){var y$G="ubstring";var Q8K="toLowerCase";var j_Q=/^on([A-Z])/;var i0V=3;var O9x="matc";var B5j=v4k;r7lc_.w49();B5j+=E_j;B5j+=r7lc_[616964];B5j+=H76;var C_3=l4$;C_3+=Q4Z;C_3+=O6E;C_3+=r7lc_.I0t;var name;var names=input[C_3](O3x);for(var i=U3X,ien=names[B5j];i < ien;i++){var K6z=O9x;K6z+=L8X;name=names[i];var onStyle=name[K6z](j_Q);if(onStyle){var Z6F=l4$;Z6F+=y$G;name=onStyle[F9J][Q8K]() + name[Z6F](i0V);}names[i]=name;}return names[R6n](O3x);}function _fieldFromNode(node){var foundField=v5D;r7lc_.w49();$[n8S](this[l4$][b7d],function(name,field){r7lc_.w49();if($(field[x2p]())[B5B](node)[b_m]){foundField=field;}});return foundField;}function _fieldNames(fieldNames){var Y$y=r1M;Y$y+=o32;r7lc_.y2x();Y$y+=g$A;Y$y+=o6M;if(fieldNames === undefined){return this[b7d]();}else if(!Array[Y$y](fieldNames)){return [fieldNames];}return fieldNames;}function _focus(fieldsIn,focus){var r4k="eElem";var D4e=/^jq:/;var x4U="Focus";var I9H="activ";var t54='div.DTE ';var T$g=V93;T$g+=x4U;var P_L=r7lc_[616964];P_L+=j1j;P_L+=H6l;var z0$=J8U;z0$+=H19;var b$Y=g$A;b$Y+=C5H;b$Y+=E_j;var h$T=e8A;h$T+=r7lc_.I0t;h$T+=O6E;h$T+=e40;var _this=this;r7lc_.y2x();if(this[l4$][h$T] === b$Y){return;}var field;var fields=$[z0$](fieldsIn,function(fieldOrName){r7lc_.y2x();return typeof fieldOrName === X0M?_this[l4$][b7d][fieldOrName]:fieldOrName;});if(typeof focus === P_L){field=fields[focus];}else if(focus){var i4s=r_k;i4s+=x1k;i4s+=P7R;if(focus[z2k](i4s) === U3X){var a47=U7C;a47+=V7l;a47+=K0$;field=$(t54 + focus[a47](D4e,D3I));}else {var D$B=o7b;D$B+=E_j;D$B+=R7b;D$B+=l4$;field=this[l4$][D$B][focus];}}else {var R8w=T69;R8w+=v4k;R8w+=j1j;R8w+=g$A;var y7v=I9H;y7v+=r4k;y7v+=E_j;y7v+=Y$n;document[y7v][R8w]();}this[l4$][T$g]=field;if(field){field[o6n]();}}function _formOptions(opts){var B$7='.dteInline';var C5n="_fieldFromNode";var h46="editCou";var l_f="ey";var J8A="strin";var g3o="eIcb";var Y8E="butt";var H9W=h7_;H9W+=B_4;H9W+=l4$;H9W+=g3o;var X9v=O5j;X9v+=l_f;X9v+=y8W;var Z7I=B_4;Z7I+=r7lc_[616964];var e5l=Y8E;e5l+=B_4;e5l+=h7x;var F0_=J8A;F0_+=z5X;var v1C=r7lc_.I0t;v1C+=O6E;v1C+=j6F;r7lc_.y2x();var b6n=a7V;b6n+=g$A;b6n+=N9T;var z$Q=h46;z$Q+=Y$n;var a23=C_h;a23+=B9k;a23+=D_g;a23+=B8k;var _this=this;var that=this;var inlineCount=_inlineCounter++;var namespace=B$7 + inlineCount;this[l4$][a23]=opts;this[l4$][z$Q]=inlineCount;if(typeof opts[D$Q] === b6n || typeof opts[v1C] === K0g){var U4J=a01;U4J+=v4k;U4J+=E_j;this[U4J](opts[D$Q]);opts[D$Q]=E6A;}if(typeof opts[J7h] === F0_ || typeof opts[J7h] === K0g){this[J7h](opts[J7h]);opts[J7h]=E6A;}if(typeof opts[e5l] !== i$u){var C8_=Y8E;C8_+=e40;C8_+=l4$;this[C8_](opts[Y0_]);opts[Y0_]=E6A;}$(document)[e40](V6J + namespace,function(e){r7lc_.y2x();var O4C="canReturnSubmit";var A1n="nR";var W4v="turnSubmit";if(e[b_C] === F07 && _this[l4$][m1n]){var el=$(document[G4T]);if(el){var b71=t_t;b71+=j12;var K_D=Z5H;K_D+=A1n;K_D+=E_j;K_D+=W4v;var field=_this[C5n](el);if(field && typeof field[K_D] === b71 && field[O4C](el)){e[E8h]();}}}});$(document)[Z7I](X9v + namespace,function(e){var B6Y="Retur";var Q86="DTE_Form";r7lc_.y2x();var p3o="onRetu";var I2Y="onE";var y_9="can";var a$l="eventDefault";var N5q="tDefau";var b_D="Buttons";var D5E="prev";var p0i="nSu";var D6f="nSubmit";var H8y="urn";var n2Z="canRetur";var s2_="nex";var c13="bm";var l78=39;var E_Z="onEsc";var K5s="preven";var t4s="nRet";var Z2x=27;var V_g=37;var q3W='button';var R7C="sc";var p4c="nReturn";var J5T=D3k;J5T+=Q86;J5T+=i3B;J5T+=b_D;var el=$(document[G4T]);if(e[b_C] === F07 && _this[l4$][m1n]){var L6L=y_9;L6L+=B6Y;L6L+=D6f;var W5F=r7lc_.q78;W5F+=X3B;W5F+=r7lc_[399342];var l0f=n2Z;l0f+=p0i;l0f+=T69;l0f+=x0V;var field=_this[C5n](el);if(field && typeof field[l0f] === W5F && field[L6L](el)){var Y8K=t_t;Y8K+=N3g;Y8K+=B_4;Y8K+=r7lc_[616964];var Y6d=B_4;Y6d+=p4c;var D1G=l4$;D1G+=j1j;D1G+=c13;D1G+=c34;var t$x=p3o;t$x+=g$A;t$x+=r7lc_[616964];if(opts[t$x] === D1G){var L7k=j8y;L7k+=a$l;e[L7k]();_this[L9t]();}else if(typeof opts[Y6d] === Y8K){var C_9=B_4;C_9+=t4s;C_9+=H8y;e[E8h]();opts[C_9](_this,e);}}}else if(e[b_C] === Z2x){var f3g=I2Y;f3g+=R7C;var i7P=t_t;i7P+=N3g;i7P+=B_4;i7P+=r7lc_[616964];var f11=K5s;f11+=N5q;f11+=P3D;e[f11]();if(typeof opts[E_Z] === i7P){opts[E_Z](that,e);}else if(opts[E_Z] === k7M){var q8I=T69;q8I+=f9c;q8I+=g$A;that[q8I]();}else if(opts[f3g] === M9H){that[i6F]();}else if(opts[E_Z] === Q3I){var W7U=l4$;W7U+=j1j;W7U+=D0g;that[W7U]();}}else if(el[G_2](J5T)[b_m]){if(e[b_C] === V_g){var j_Z=r7lc_.q78;j_Z+=B_4;j_Z+=x$G;j_Z+=l4$;var C4F=T69;C4F+=F3T;C4F+=r7lc_.I0t;C4F+=e40;el[D5E](C4F)[G$k](j_Z);}else if(e[b_C] === l78){var o9W=s2_;o9W+=r7lc_.I0t;el[o9W](q3W)[G$k](K5m);}}});this[l4$][H9W]=function(){var P_J='keyup';var O3c=B_4;O3c+=r7lc_.q78;O3c+=r7lc_.q78;var z6r=B_4;z6r+=U4_;$(document)[z6r](V6J + namespace);$(document)[O3c](P_J + namespace);};return namespace;}function _inline(editFields,opts,closeCb){var B0w=r7lc_;var D0Y='Edge/';var g7q="nts";var x9C="mErro";var F$w="attachFields";var I06="nline";var R4V='<div class="DTE_Processing_Indicator"><span></span></div>';var C1s="userAgent";var K7w="iv cl";var G6o="utto";var k_f='.';var j2U="_inputTrigger";var H5b="dth";var P9s="eReg";var p4d="_clos";var i_s="e=\"wi";var E8j='px"';var m57="tta";var Q_S=M8G;Q_S+=r7lc_[631343];Q_S+=j1j;Q_S+=l4$;var v2o=p4d;v2o+=P9s;var v29=q_1;v29+=s2T;B0w.y2x();v29+=L8X;var b$B=q0j;b$B+=r7lc_[616964];b$B+=l4$;var j0T=O6E;j0T+=I06;var _this=this;if(closeCb === void U3X){closeCb=v5D;}var closed=B4$;var classes=this[x6a][j0T];var keys=Object[Y0R](editFields);var editRow=editFields[keys[U3X]];var lastAttachPoint;var elements=[];for(var i=U3X;i < editRow[A$l][b_m];i++){var G1d=M4$;G1d+=m57;G1d+=r7lc_[631343];G1d+=L8X;var W9Y=r7lc_.q78;W9Y+=O6E;W9Y+=x5T;var name_1=editRow[F$w][i][U3X];elements[r4r]({field:this[l4$][W9Y][name_1],name:name_1,node:$(editRow[G1d][i])});}var namespace=this[b$B](opts);var ret=this[Q_Y](n0l);if(!ret){return this;}for(var _i=U3X,elements_1=elements;_i < elements_1[v29];_i++){var L11=T69;L11+=G6o;L11+=r7lc_[616964];L11+=l4$;var n$x=j35;n$x+=g_x;var O$Z=o7b;O$Z+=F6Q;O$Z+=X2M;var H$j=r7lc_.q78;H$j+=G2G;H$j+=x9C;H$j+=g$A;var G3P=X2M;G3P+=B_4;G3P+=J8U;var f$X=r7lc_[616964];f$X+=r6s;var V$R=v4k;V$R+=O6E;V$R+=r7lc_[616964];V$R+=B2h;var e8g=X2M;e8g+=O6E;e8g+=b$b;e8g+=D3k;var V46=r7lc_.q78;V46+=O6E;V46+=r7lc_[616964];V46+=X2M;var S3t=K9b;S3t+=p5r;S3t+=X2M;S3t+=k9f;var B74=R$N;B74+=r7lc_.I0t;B74+=S3h;B74+=h7x;var m26=k7W;m26+=K7w;m26+=m$O;var S5e=K9b;S5e+=p5r;S5e+=q01;var a9j=X2D;a9j+=O7Q;var m46=r9T;m46+=v_p;m46+=g$A;var t5R=X2D;t5R+=j87;var C3p=D3P;C3p+=D_g;C3p+=t$M;C3p+=g$A;var u7U=M4$;u7U+=D_g;u7U+=t$M;u7U+=k88;var S$Q=B7d;S$Q+=i_s;S$Q+=H5b;S$Q+=P7R;var e_T=k_V;e_T+=g7q;var Z7$=m3o;Z7$+=g$A;Z7$+=a8w;var el=elements_1[_i];var node=el[x2p];el[Z7$]=node[e_T]()[U8w]();var style=navigator[C1s][z2k](D0Y) !== -F9J?S$Q + node[v6N]() + E8j:D3I;node[u7U]($(u3L + classes[C3p] + t5R + u3L + classes[m46] + a9j + style + V_Z + R4V + S5e + m26 + classes[B74] + t1P + S3t));node[V46](e8g + classes[V$R][q6o](/ /g,k_f))[C__](el[g_V][f$X]())[C__](this[G3P][H$j]);lastAttachPoint=el[O$Z][n$x]();if(opts[L11]){var x7q=X2M;x7q+=L3D;node[B5B](q6u + classes[Y0_][q6o](/ /g,k_f))[C__](this[x7q][Y0_]);}}var submitClose=this[j2U](Q3I,opts,lastAttachPoint);var cancelClose=this[j2U](t7h,opts,lastAttachPoint);this[v2o](function(submitComplete,action){var W$D="Ea";var c63=E_j;c63+=X2M;c63+=O6E;c63+=r7lc_.I0t;closed=E6A;$(document)[i2_](R9$ + namespace);if(!submitComplete || action !== c63){var B3O=H1k;B3O+=g$A;B3O+=W$D;B3O+=D5x;elements[B3O](function(el){var A_X=M4$;A_X+=E3D;A_X+=E_j;A_X+=k88;var N2b=A1D;N2b+=L8X;var j5D=r7lc_[631343];j5D+=B_4;j5D+=Y$n;j5D+=y7j;el[x2p][j5D]()[N2b]();el[x2p][A_X](el[u1K]);});}submitClose();B0w.w49();cancelClose();_this[i7d]();if(closeCb){closeCb();}return n0l;;});setTimeout(function(){B0w.y2x();var Y5_="own";var c83="moused";var w$3="dBac";var H0G=T9O;H0G+=r7lc_[631343];H0G+=O5j;var y7o=B_4;y7o+=r7lc_[616964];var v$R=c83;v$R+=Y5_;var O1s=B_4;O1s+=r7lc_[616964];var n1L=M4$;n1L+=X2M;n1L+=w$3;n1L+=O5j;if(closed){return;}var back=$[T5x][I4F]?n1L:y0O;var target;$(document)[O1s](v$R + namespace,function(e){B0w.w49();target=e[J4A];})[e40](V6J + namespace,function(e){target=e[J4A];})[y7o](H0G + namespace,function(e){B0w.w49();var Z6X="_type";var isIn=B4$;for(var _i=U3X,elements_2=elements;_i < elements_2[b_m];_i++){var s6v=y34;s6v+=r7lc_.I0t;s6v+=l4$;var C54=Y5_;C54+=l4$;var Y31=Z6X;Y31+=V05;var el=elements_2[_i];if(el[g_V][Y31](C54,target) || $[U7Z](el[x2p][U3X],$(target)[s6v]()[back]()) !== -F9J){isIn=E6A;}}if(!isIn){_this[D6X]();}});},U3X);this[Q_S]($[S6L](elements,function(el){var B0J=r7lc_.q78;B0J+=O6E;B0J+=E_j;B0J+=R7b;return el[B0J];}),opts[o6n]);this[B4I](n0l,E6A);}function _inputTrigger(type,opts,insertPoint){var o6E="clos";var n6R="k.";var k1z='Trigger';var x9I="clic";var r3N="chi";var l_2='tr';var j$1="tach";var Y$K=D47;Y$K+=k88;var B$N=B_4;B$N+=r7lc_[616964];var Y0U=g_x;Y0U+=j$1;var J8Z=b5e;J8Z+=r7lc_.I0t;J8Z+=B_4;J8Z+=U5U;var u8G=o6E;u8G+=E_j;u8G+=l4$;u8G+=r7lc_.I0t;var I8q=x9I;I8q+=n6R;I8q+=w56;I8q+=Q_4;var R$K=M$Z;R$K+=r7lc_.I0t;R$K+=J8U;R$K+=v4k;var _this=this;var trigger=opts[type + k1z];var html=opts[type + R$K];var event=I8q + type;var tr=$(insertPoint)[u8G](l_2);if(trigger === undefined){return function(){};}if(typeof trigger === S_J){var v95=r3N;v95+=R7b;v95+=g$A;v95+=a8w;var kids=tr[v95]();trigger=trigger < U3X?kids[kids[b_m] + trigger]:kids[trigger];}var children=$(trigger,tr)[b_m]?Array[J8Z][p6F][e27]($(trigger,tr)[U3X][z4j]):[];$(children)[Y0U]();var triggerEl=$(trigger,tr)[B$N](event,function(e){var a5i="stopImmediatePropagation";e[a5i]();r7lc_.y2x();if(type === t7h){var Q2x=R7l;Q2x+=Z_p;_this[Q2x]();}else {var v$G=l59;v$G+=T69;v$G+=x0V;_this[v$G]();}})[Y$K](html);return function(){var b8r="emp";var b8W="of";var Z79=b8r;Z79+=v8n;var p64=b8W;p64+=r7lc_.q78;triggerEl[p64](event)[Z79]()[C__](children);};}function _optionsUpdate(json){r7lc_.w49();var that=this;if(json && json[W0g]){var F$6=g_V;F$6+=l4$;var A2W=E_j;A2W+=M4$;A2W+=r7lc_[631343];A2W+=L8X;$[A2W](this[l4$][F$6],function(name,field){var L1Q="upd";var d5O=M8e;d5O+=C6N;d5O+=r7lc_[616964];d5O+=l4$;if(json[d5O][name] !== undefined){var o3q=L1Q;o3q+=M4$;o3q+=r7lc_.I0t;o3q+=E_j;var N3B=o7b;N3B+=L1Y;var fieldInst=that[N3B](name);if(fieldInst && fieldInst[o3q]){var s77=y8W;s77+=r7lc_.A9u;s77+=E_j;fieldInst[s77](json[W0g][name]);}}});}}function _message(el,msg,title,fn){var U$j="removeAttr";var x3s="funct";var t1x="nimate";var u1i="fadeOut";var c0S="titl";var Z$b="bloc";var v5V="fadeIn";var m9O=x3s;m9O+=z76;var I_c=M4$;I_c+=t1x;var K7X=r7lc_.q78;K7X+=r7lc_[616964];var canAnimate=$[K7X][I_c]?E6A:B4$;if(title === undefined){title=B4$;}if(!fn){fn=function(){};}if(typeof msg === m9O){var a6Y=h1q;a6Y+=w2$;msg=msg(this,new DataTable$4[s1J](this[l4$][a6Y]));}el=$(el);if(canAnimate){var Q4K=l4$;Q4K+=r7lc_.I0t;Q4K+=B_4;Q4K+=D_g;el[Q4K]();}if(!msg){var V$K=A9N;V$K+=u05;V$K+=E$9;if(this[l4$][V$K] && canAnimate){el[u1i](function(){el[I52](D3I);fn();});}else {var I4C=y3Y;I4C+=E_j;var p7m=A9N;p7m+=u05;p7m+=i$q;var z6l=r7lc_[631343];z6l+=l4$;z6l+=l4$;el[I52](D3I)[z6l](p7m,I4C);fn();}if(title){el[U$j](w76);}}else {var h3Y=X2M;h3Y+=O6E;h3Y+=H6U;h3Y+=Z2R;fn();if(this[l4$][h3Y] && canAnimate){el[I52](msg)[v5V]();}else {var A0o=Z$b;A0o+=O5j;var A2e=L8X;A2e+=W8L;el[A2e](msg)[Q$n](o7C,A0o);}if(title){var G7e=c0S;G7e+=E_j;var a_z=M4$;a_z+=r7lc_.I0t;a_z+=M_A;el[a_z](G7e,msg);}}}function _multiInfo(){var h$Q="ditabl";var P8l="iValue";var y3_="deF";var Z$h="isMu";var U1o="nclu";r7lc_.y2x();var D78="isM";var h9P="InfoShown";var K9C="ultiVal";var H6n=O6E;H6n+=U1o;H6n+=y3_;H6n+=z8Z;var fields=this[l4$][b7d];var include=this[l4$][H6n];var show=E6A;var state;if(!include){return;}for(var i=U3X,ien=include[b_m];i < ien;i++){var C$_=A6N;C$_+=O6E;C$_+=h9P;var x5d=Z$h;x5d+=P3D;x5d+=P8l;var H0v=D78;H0v+=K9C;H0v+=j1j;H0v+=E_j;var x5c=v9q;x5c+=h$Q;x5c+=E_j;var field=fields[include[i]];var multiEditable=field[x5c]();if(field[H0v]() && multiEditable && show){state=E6A;show=B4$;}else if(field[x5d]() && !multiEditable){state=E6A;}else {state=B4$;}fields[include[i]][C$_](state);}}function _nestedClose(cb){var I16="ayCo";var I7T="callback";var O57="how";r7lc_.y2x();var H8z="ntroller";var q1K=q_1;q1K+=r7lc_[616964];q1K+=A8Q;q1K+=L8X;var O5o=i3B;O5o+=l4$;O5o+=O57;var d2X=N7c;d2X+=I16;d2X+=H8z;var disCtrl=this[l4$][d2X];var show=disCtrl[O5o];if(!show || !show[q1K]){if(cb){cb();}}else if(show[b_m] > F9J){var X49=D47;X49+=r7lc_[616964];X49+=X2M;var c1X=e8F;c1X+=D_g;show[c1X]();var last=show[show[b_m] - F9J];if(cb){cb();}this[l4$][K28][i1l](last[w56],last[X49],last[I7T]);}else {this[l4$][K28][i6F](this,cb);show[b_m]=U3X;}}function _nestedOpen(cb,nest){var D_6="yController";var y4D=X2M;y4D+=B_4;y4D+=J8U;var c37=z5G;c37+=D_6;var D_3=N5Z;D_3+=H19;D_3+=o0h;var p9n=v1q;p9n+=m8k;var I0U=i3B;I0U+=N8w;var p2e=z5G;p2e+=D_6;var disCtrl=this[l4$][p2e];if(!disCtrl[W_u]){disCtrl[W_u]=[];}if(!nest){disCtrl[W_u][b_m]=U3X;}disCtrl[I0U][p9n]({append:this[H$1][D_3],callback:cb,dte:this});this[l4$][c37][i1l](this,this[y4D][V3F],cb);}function _postopen(type,immediate){var m4i="submit.edi";var N0Y="captureFocus";var O$3="or-internal";var K$Z="bmi";var b7T="iInfo";var N4$="opene";var J81="t.editor-internal";var x5_="focus.editor-f";var E6O="ubb";var a7o=U7l;a7o+=r7lc_[616964];var f$V=G9c;f$V+=b7T;var A9e=T69;A9e+=E6O;A9e+=v4k;A9e+=E_j;var M0X=m4i;M0X+=r7lc_.I0t;M0X+=O$3;var L3$=l59;L3$+=K$Z;L3$+=J81;var s5d=B_4;s5d+=r7lc_.q78;s5d+=r7lc_.q78;var _this=this;var focusCapture=this[l4$][K28][N0Y];if(focusCapture === undefined){focusCapture=E6A;}$(this[H$1][O2E])[s5d](L3$)[e40](M0X,function(e){var Q4S="tDefault";r7lc_.w49();var H1H=j8y;H1H+=r_P;H1H+=Q4S;e[H1H]();});if(focusCapture && (type === J2x || type === A9e)){var M0C=x5_;M0C+=F6T;M0C+=P0J;$(N$f)[e40](M0C,function(){var Z4W="setFocu";var g4y="activeE";var Y3u="setFocus";var B4K="ment";var B9H='.DTE';var g37="ED";var Q$J=w$F;Q$J+=z5X;Q$J+=r7lc_.I0t;Q$J+=L8X;var T6J=D3k;T6J+=l1n;T6J+=g37;r7lc_.w49();var O31=y34;O31+=B8k;var I2A=g4y;I2A+=q_1;I2A+=B4K;if($(document[G4T])[G_2](B9H)[b_m] === U3X && $(document[I2A])[O31](T6J)[Q$J] === U3X){var b8U=Z4W;b8U+=l4$;if(_this[l4$][b8U]){_this[l4$][Y3u][o6n]();}}});}this[f$V]();this[M4P](a7o,[type,this[l4$][b5A]]);r7lc_.w49();if(immediate){var P6J=M4$;P6J+=N3g;P6J+=B_4;P6J+=r7lc_[616964];var z0M=N4$;z0M+=X2M;this[M4P](z0M,[type,this[l4$][P6J]]);}return E6A;}function _preopen(type){var w8c="earDy";var i7f="oseIcb";var Q9M="namicI";var F_D="closeIcb";var r9k="splayed";var k2f="reOp";var b2g='cancelOpen';var A9T=A9N;A9T+=r9k;var r$h=D_g;r$h+=k2f;r$h+=E_j;r$h+=r7lc_[616964];if(this[M4P](r$h,[type,this[l4$][b5A]]) === B4$){var A2C=h7_;A2C+=i7f;var Y1F=J8U;Y1F+=B_4;Y1F+=X2M;Y1F+=E_j;var a5N=J8U;a5N+=B_4;a5N+=g_x;var d2f=C6C;d2f+=w8c;d2f+=Q9M;d2f+=j2e;this[d2f]();this[M4P](b2g,[type,this[l4$][b5A]]);if((this[l4$][a5N] === n0l || this[l4$][Y1F] === W29) && this[l4$][A2C]){this[l4$][F_D]();}this[l4$][F_D]=v5D;return B4$;}this[i7d](E6A);this[l4$][A9T]=type;return E6A;}function _processing(processing){var H$o="active";var j$8='div.DTE';var I2J="oce";var U90=D_g;U90+=g$A;U90+=I2J;U90+=F88;var E3U=P0D;E3U+=q0d;var k4f=D_g;k4f+=B_s;var x6W=X2M;r7lc_.y2x();x6W+=B_4;x6W+=J8U;var procClass=this[x6a][c0j][H$o];$([j$8,this[x6W][V3F]])[U9h](procClass,processing);this[l4$][k4f]=processing;this[E3U](U90,[processing]);}function _noProcessing(args){var g6X=E_j;r7lc_.y2x();g6X+=M4$;g6X+=r7lc_[631343];g6X+=L8X;var processing=B4$;$[g6X](this[l4$][b7d],function(name,field){r7lc_.y2x();if(field[c0j]()){processing=E6A;}});if(processing){this[I3u](p2_,function(){r7lc_.w49();if(this[S_K](args) === E6A){this[Z4g][m51](this,args);}});}return !processing;}function _submit(successCallback,errorCallback,formatdata,hide){var J4t=r7lc_;var Q6i=16;var f2J="onCompl";var p3W="_processi";var Y_a="llIfCha";var U3K="emo";var d1_="Subm";var l8s="tionN";var z5A="submi";var k2q="editCount";var Y0Y="nct";var Y7Q='Field is still processing';var P56=S7d;P56+=d1_;P56+=O6E;P56+=r7lc_.I0t;var Q$Z=s8D;Q$Z+=r7lc_[616964];Q$Z+=r7lc_.I0t;var W7m=O6h;W7m+=v1N;var m37=g$A;J4t.w49();m37+=U3K;m37+=b$b;m37+=E_j;var g2A=C_h;g2A+=c34;var C6i=e8A;C6i+=l8s;C6i+=B0u;C6i+=E_j;var W9L=e8A;W9L+=K5f;W9L+=e40;var d6R=z5A;d6R+=r7lc_.I0t;var T71=b2D;T71+=E$1;var _this=this;var changed=B4$;var allData={};var changedData={};var setBuilder=dataSet;var fields=this[l4$][b7d];var editCount=this[l4$][k2q];var editFields=this[l4$][T71];var editData=this[l4$][a1h];var opts=this[l4$][k1p];var changedSubmit=opts[d6R];var submitParamsLocal;if(this[S_K](arguments) === B4$){Editor[S_q](Y7Q,Q6i,B4$);return;}var action=this[l4$][W9L];var submitParams={data:{}};submitParams[this[l4$][C6i]]=action;if(action === A9E || action === g2A){var W6K=M4$;W6K+=Y_a;W6K+=w6p;W6K+=C_h;var G9N=M4$;G9N+=v4k;G9N+=v4k;var w2y=E_j;w2y+=M4$;w2y+=r7lc_[631343];w2y+=L8X;$[w2y](editFields,function(idSrc,edit){var E42=E_j;E42+=m4P;var allRowData={};var changedRowData={};$[E42](fields,function(name,field){var J$D=/\[.*$/;var Z58="-many-";var X5t="mittab";var Y3S="[";var n0p=l59;n0p+=T69;n0p+=X5t;J4t.y2x();n0p+=q_1;if(edit[b7d][name] && field[n0p]()){var J7J=g9q;J7J+=J8U;J7J+=D8t;J7J+=h2t;var o8q=Z58;o8q+=f$W;var B$k=Y3S;B$k+=D31;var m65=r1M;m65+=k9N;m65+=o6M;var X5k=s3q;X5k+=P3D;X5k+=n$L;var multiGet=field[X5k]();var builder=setBuilder(name);if(multiGet[idSrc] === undefined){var L4S=X2M;L4S+=M4$;L4S+=r7lc_.I0t;L4S+=M4$;var originalVal=field[k0K](edit[L4S]);builder(allRowData,originalVal);return;}var value=multiGet[idSrc];var manyBuilder=Array[m65](value) && typeof name === X0M && name[z2k](B$k) !== -F9J?setBuilder(name[q6o](J$D,D3I) + o8q):v5D;builder(allRowData,value);if(manyBuilder){manyBuilder(allRowData,value[b_m]);}if(action === X$Q && (!editData[name] || !field[J7J](value,editData[name][idSrc]))){builder(changedRowData,value);changed=E6A;if(manyBuilder){var N1k=q_1;N1k+=s2T;N1k+=L8X;manyBuilder(changedRowData,value[N1k]);}}}});if(!$[U05](allRowData)){allData[idSrc]=allRowData;}if(!$[U05](changedRowData)){changedData[idSrc]=changedRowData;}});if(action === A9E || changedSubmit === G9N || changedSubmit === W6K && changed){var L$9=X2M;L$9+=M4$;L$9+=h1q;submitParams[L$9]=allData;}else if(changedSubmit === i_c && changed){submitParams[E15]=changedData;}else {var C1e=p3W;C1e+=w6p;var B79=r7lc_[269035];B79+=Y0Y;B79+=z76;var G31=f2J;G31+=P1E;var q6N=M4$;q6N+=j12;this[l4$][q6N]=v5D;if(opts[a1B] === M9H && (hide === undefined || hide)){var p86=W8W;p86+=v4k;p86+=B_4;p86+=Z_p;this[p86](B4$);}else if(typeof opts[G31] === B79){opts[a1B](this);}if(successCallback){var r98=r7lc_[631343];r98+=w7Q;r98+=v4k;successCallback[r98](this);}this[C1e](B4$);this[M4P](w1E);return;}}else if(action === m37){var I_t=l_b;I_t+=L8X;$[I_t](editFields,function(idSrc,edit){J4t.y2x();submitParams[E15][idSrc]=edit[E15];});}submitParamsLocal=$[W7m](E6A,{},submitParams);if(formatdata){formatdata(submitParams);}this[Q$Z](P56,[submitParams,action],function(result){var v0I="aja";var I$m="bmitTabl";J4t.w49();if(result === B4$){var A0H=p3W;A0H+=w6p;_this[A0H](B4$);}else {var Y4B=F5w;Y4B+=I$m;Y4B+=E_j;var h_G=G_5;h_G+=D34;var T$O=v0I;T$O+=D34;var submitWire=_this[l4$][T$O]?_this[h_G]:_this[Y4B];submitWire[e27](_this,submitParams,function(json,notGood,xhr){var P$d="tSucces";var r00="_submi";var W4z=O5A;W4z+=r7lc_[616964];var f76=r00;f76+=P$d;f76+=l4$;_this[f76](json,notGood,submitParams,submitParamsLocal,_this[l4$][W4z],editCount,hide,successCallback,errorCallback,xhr);},function(xhr,err,thrown){var i$n="_submitError";var S5T=w9w;S5T+=B_4;S5T+=r7lc_[616964];_this[i$n](xhr,err,thrown,errorCallback,submitParams,_this[l4$][S5T]);},submitParams);}});}function _submitTable(data,success,error,submitParams){var Q6D="mai";var P67="individu";var C2K="act";var g8a="idS";var l7h=g8a;l7h+=v0W;var P9U=g8a;P9U+=g$A;P9U+=r7lc_[631343];var o07=C2K;o07+=S6x;o07+=r7lc_[616964];var action=data[o07];var out={data:[]};var idGet=dataGet(this[l4$][P9U]);var idSet=dataSet(this[l4$][l7h]);if(action !== c12){var H1J=r7lc_.A9u;H1J+=M4$;var Z2r=E_j;Z2r+=e8A;Z2r+=L8X;var l5o=P67;l5o+=w7Q;var K1V=K4t;K1V+=R7b;K1V+=l4$;var a5x=C0r;a5x+=B_4;a5x+=j1j;a5x+=R0T;var p_w=Q6D;p_w+=r7lc_[616964];var originalData_1=this[l4$][o$P] === p_w?this[a5x](K1V,this[p4N]()):this[f3Q](l5o,this[p4N]());$[Z2r](data[H1J],function(key,vals){var f7h="toString";var f2V=D_g;f2V+=j1j;f2V+=l4$;f2V+=L8X;var Z3C=l2f;Z3C+=H_8;var x9H=C_h;x9H+=c34;var toSave;var extender=extend;r7lc_.y2x();if(action === x9H){var y4F=k0r;y4F+=h1q;var rowData=originalData_1[key][y4F];toSave=extender({},rowData,E6A);toSave=extender(toSave,vals,E6A);}else {toSave=extender({},vals,E6A);}var overrideId=idGet(toSave);if(action === Z3C && overrideId === undefined){idSet(toSave,+new Date() + key[f7h]());}else {idSet(toSave,overrideId);}out[E15][f2V](toSave);});}success(out);}function _submitSuccess(json,notGood,submitParams,submitParamsLocal,action,editCount,hide,successCallback,errorCallback,xhr){var S$e='preEdit';var w0q="r>";var x2n="Su";var P6A="stEdit";var j3x="_dataSour";var W4V="ataSou";var L2y="Comple";var M2O="dataSou";var I4e="nComplete";var y93="cess";var K8x="ostCrea";var M_x="los";var g$f="ccess";var j5K="Rem";var x1B="_pro";var H6X="_d";var w3l="ataSource";var p1P='submitUnsuccessful';var m8x='postRemove';var U$A="_data";var j0D='commit';var h97='preCreate';var h43="oin";var r8$='setData';var E_e="Source";var g6Z="ldErro";var B4X=y_3;B4X+=b$b;B4X+=E_j;B4X+=Y$n;var Y7J=x1B;Y7J+=y93;Y7J+=N9T;var u5e=B2h;u5e+=Q8O;u5e+=g$A;var U6_=K4t;U6_+=g6Z;U6_+=g$A;U6_+=l4$;var k_c=E_j;k_c+=g$A;k_c+=Q8O;k_c+=g$A;var z6Y=S4F;z6Y+=O6E;z6Y+=B2h;var g$t=C_h;g$t+=B9k;g$t+=b2c;g$t+=l4$;var B1f=r7lc_.q78;B1f+=O6E;B1f+=F6Q;B1f+=S1y;var _this=this;var that=this;var setData;var fields=this[l4$][B1f];var opts=this[l4$][g$t];var modifier=this[l4$][z6Y];this[M4P](m2X,[json,submitParams,action,xhr]);r7lc_.w49();if(!json[k_c]){var E8G=M1o;E8G+=G2G;json[E8G]=D3I;}if(!json[U6_]){json[V8o]=[];}if(notGood || json[u5e] || json[V8o][b_m]){var R95=i3B;R95+=E_j;R95+=L6h;R95+=Y$n;var q5U=K9b;q5U+=T69;q5U+=w0q;var l76=r_k;l76+=h43;var r7t=B2h;r7t+=Q8O;r7t+=g$A;var A7y=l_b;A7y+=L8X;var I0T=E_j;I0T+=t$z;I0T+=g$A;var globalError_1=[];if(json[I0T]){var o8C=D_g;o8C+=j1j;o8C+=l4$;o8C+=L8X;globalError_1[o8C](json[S_q]);}$[A7y](json[V8o],function(i,err){var Q1M="Error";var b9o="yCont";var e9R="_animat";var u7u="onField";r7lc_.w49();var t2e="onF";var c8x="ieldError";var k4y="bod";var C53="onFieldError";var D2Y=" fiel";var Z_2="known";var b6q="d: ";var m8G='Error';var O_Q=r7lc_[616964];O_Q+=M4$;O_Q+=F4j;var field=fields[err[O_Q]];if(!field){var L3i=n9O;L3i+=Z_2;L3i+=D2Y;L3i+=b6q;throw new Error(L3i + err[P8N]);}else if(field[m1n]()){field[S_q](err[B_L] || m8G);if(i === U3X){var t9S=t_t;t9S+=j12;var f4L=t2e;f4L+=c8x;var z1f=u7u;z1f+=Q1M;if(opts[z1f] === K5m){var p_S=k4y;p_S+=b9o;p_S+=q0d;var e0P=H$2;e0P+=J8U;var c__=e9R;c__+=E_j;_this[c__]($(_this[e0P][p_S]),{scrollTop:$(field[x2p]())[P1s]()[b8N]},o8r);field[o6n]();}else if(typeof opts[f4L] === t9S){opts[C53](_this,err);}}}else {var y_K=P7R;y_K+=O7Q;globalError_1[r4r](field[P8N]() + y_K + (err[B_L] || m8G));}});this[r7t](globalError_1[l76](q5U));this[R95](p1P,[json]);if(errorCallback){var G1q=r7lc_[631343];G1q+=w7Q;G1q+=v4k;errorCallback[G1q](that,json);}}else {var n6H=L9t;n6H+=x2n;n6H+=g$f;var J4p=v0L;J4p+=E6J;J4p+=Q4h;J4p+=Y$n;var m8g=l2f;m8g+=H_8;var M_N=X2M;M_N+=M4$;M_N+=r7lc_.I0t;M_N+=M4$;var store={};if(json[M_N] && (action === m8g || action === X$Q)){var R2H=X2M;R2H+=M4$;R2H+=h1q;var O7w=i3B;O7w+=X2M;O7w+=W4V;O7w+=R0T;var O9i=X2M;O9i+=M4$;O9i+=r7lc_.I0t;O9i+=M4$;var W0X=D_g;W0X+=g$A;W0X+=E_j;W0X+=D_g;var G$L=U$A;G$L+=E_e;this[G$L](W0X,action,modifier,submitParamsLocal,json,store);for(var _i=U3X,_a=json[O9i];_i < _a[b_m];_i++){var z5p=C_h;z5p+=c34;var v7T=O6E;v7T+=X2M;var R4_=C0r;R4_+=W_T;var data=_a[_i];setData=data;var id=this[R4_](v7T,data);this[M4P](r8$,[json,data,action]);if(action === A9E){var s2z=D_g;s2z+=K8x;s2z+=r7lc_.I0t;s2z+=E_j;var c1K=l2f;c1K+=r7lc_.I0t;c1K+=E_j;var S2a=f0G;S2a+=s_N;var j1q=i3B;j1q+=k0r;j1q+=h1q;j1q+=E_e;this[M4P](h97,[json,data,id]);this[j1q](S2a,fields,data,store);this[M4P]([c1K,s2z],[json,data,id]);}else if(action === z5p){var l_q=e8F;l_q+=P6A;var C7_=E_j;C7_+=A9N;C7_+=r7lc_.I0t;var A3H=i3B;A3H+=M2O;A3H+=R0T;var g1W=i3B;g1W+=E6d;g1W+=r7lc_[616964];g1W+=r7lc_.I0t;this[g1W](S$e,[json,data,id]);this[A3H](C7_,modifier,fields,data,store);this[M4P]([X$Q,l_q],[json,data,id]);}}this[O7w](j0D,action,modifier,json[R2H],store);}else if(action === c12){var A$i=j3x;A$i+=K0$;var L3o=b3W;L3o+=R8u;var s9C=H6X;s9C+=w3l;var W4k=O6E;W4k+=X2M;W4k+=l4$;var D5w=j8y;D5w+=E_j;D5w+=j5K;D5w+=R8u;var A5A=i3B;A5A+=E_j;A5A+=k5x;var m$H=D_g;m$H+=g$A;m$H+=E_j;m$H+=D_g;this[f3Q](m$H,action,modifier,submitParamsLocal,json,store);this[A5A](D5w,[json,this[W4k]()]);this[s9C](c12,modifier,fields,store);this[M4P]([L3o,m8x],[json,this[U_G]()]);this[A$i](j0D,action,modifier,json[E15],store);}if(editCount === this[l4$][J4p]){var h_6=e40;h_6+=L2y;h_6+=r7lc_.I0t;h_6+=E_j;var sAction=this[l4$][b5A];this[l4$][b5A]=v5D;if(opts[h_6] === M9H && (hide === undefined || hide)){var E3Q=W8W;E3Q+=M_x;E3Q+=E_j;this[E3Q](json[E15]?E6A:B4$,sAction);}else if(typeof opts[a1B] === K0g){var V0y=B_4;V0y+=I4e;opts[V0y](this);}}if(successCallback){successCallback[e27](that,json);}this[M4P](n6H,[json,setData,action]);}this[Y7J](B4$);this[B4X](w1E,[json,setData,action]);}function _submitError(xhr,err,thrown,errorCallback,submitParams,action){var G3p="itC";var f4D="itErr";var v6Q="ompl";var r5i="sys";var F$a=a4u;F$a+=G3p;F$a+=v6Q;F$a+=P1E;var n_Y=a4u;n_Y+=f4D;n_Y+=G2G;var y8K=i3B;y8K+=X1$;y8K+=q0d;var O3A=r5i;O3A+=v3_;var F5J=i3B;F5J+=r_P;r7lc_.y2x();F5J+=r7lc_.I0t;this[F5J](m2X,[v5D,submitParams,action,xhr]);this[S_q](this[N9v][S_q][O3A]);this[V7L](B4$);if(errorCallback){errorCallback[e27](this,xhr,err,thrown);}this[y8K]([n_Y,F$a],[xhr,err,thrown,submitParams]);}function _tidy(fn){var O1K=r7lc_;var p5h="oFeatu";var l2O="res";var p5m="bServerSide";var e7$="aTa";var S8i="nli";var d2l=X2M;d2l+=r1M;d2l+=Q4Z;d2l+=v7E;var i96=O6E;i96+=S8i;O1K.w49();i96+=r7lc_[616964];i96+=E_j;var V7a=r7lc_.I0t;V7a+=U6p;V7a+=v4k;V7a+=E_j;var M5O=T1$;M5O+=O6E;var R8$=r7lc_.A9u;R8$+=e7$;R8$+=w2$;var _this=this;var dt=this[l4$][s9i]?new $[T5x][R8$][M5O](this[l4$][V7a]):v5D;var ssp=B4$;if(dt){var V79=p5h;V79+=l2O;var c3F=b0g;c3F+=P08;ssp=dt[c3F]()[U3X][V79][p5m];}if(this[l4$][c0j]){this[I3u](w1E,function(){O1K.w49();if(ssp){var D6b=X2M;D6b+=t18;var l1G=B_4;l1G+=v_p;dt[l1G](D6b,fn);}else {setTimeout(function(){O1K.y2x();fn();},F8x);}});return E6A;}else if(this[u_G]() === i96 || this[d2l]() === W29){this[I3u](M9H,function(){var G4y=b5e;G4y+=e15;if(!_this[l4$][G4y]){setTimeout(function(){O1K.y2x();if(_this[l4$]){fn();}},F8x);}else {var L3u=e40;L3u+=E_j;_this[L3u](w1E,function(e,json){O1K.y2x();if(ssp && json){var A1b=B_4;A1b+=r7lc_[616964];A1b+=E_j;dt[A1b](c$x,fn);}else {setTimeout(function(){O1K.y2x();if(_this[l4$]){fn();}},F8x);}});}})[D6X]();return E6A;}return B4$;}function _weakInArray(name,arr){for(var i=U3X,ien=arr[b_m];i < ien;i++){if(name == arr[i]){return i;}}r7lc_.y2x();return -F9J;}var fieldType={create:function(){},disable:function(){},enable:function(){},get:function(){},set:function(){}};var DataTable$3=$[T5x][o5o];function _buttonText(conf,textIn){var r5d='div.upload button';r7lc_.w49();var e6q='Choose file...';var P1l="uploadText";var M5z=r7lc_.q78;M5z+=O6E;M5z+=r7lc_[616964];M5z+=X2M;var g8B=i3B;g8B+=Y0M;g8B+=r7lc_.I0t;if(textIn === v5D || textIn === undefined){textIn=conf[P1l] || e6q;}conf[g8B][M5z](r5d)[I52](textIn);}function _commonUpload(editor,conf,dropCallback,multiple){var B9q=" class=\"rendered\"></div>";var v3H='id';var J3B="div.rende";var W2O="Drag and drop a ";var g$M="file]";var P6q="<div class=\"editor_";var u8x="drag";var m3n="t[ty";var i57="<div cla";var U7x="exit";var r3I='drop';var E1B="file here to";var G$d="ave drag";var l92="tton";var p8q='div.drop span';var y6o="<div class=\"drop\"><span></span></di";var F0w="ut[type=file]";var f9W="buttonInterna";var E4i="_enabled";var y1t='<div class="row second">';var S5t="Cl";var k1D="dragDro";var k4G="v class=\"row";var t7k="></";var q2E="<di";var x1Z='"></button>';var m$G="utton class=";var i5D="t>";var G1I="afeI";var L8P="<div class=\"eu_table";var v8y='input[type=file]';var M71='noDrop';var c0r="tHide\">";var d9d="pe=";var l9S="<b";var O28="iv class=\"cell\">";var R02="oad";var D8a='<button class="';var e8l="div.dr";var H7s="multipl";var E88="=\"cell limi";var Z0S="/div>";var U8s=" upload";var x_0="asse";var O5y=".clearValue bu";var A66="FileReade";var W8G="load limitHide\">";var M$k="rValue\">";var P$s='<input type="file" ';var R8L="<div class=\"cell up";var d6M="dragDrop";var c9p="<div class=\"cell clea";var b_I=k0f;b_I+=D_g;b_I+=j1j;b_I+=r7lc_.I0t;var P9u=r7lc_[631343];P9u+=v4k;P9u+=B6q;P9u+=O5j;var B4v=B_4;B4v+=r7lc_[616964];var a26=u$7;a26+=O5y;a26+=l92;var U7G=o7b;U7G+=r7lc_[616964];U7G+=X2M;var o_L=A66;o_L+=g$A;var W7_=O6E;W7_+=X2M;var i1G=I95;i1G+=T69;i1G+=x4W;var I70=K9b;I70+=K44;I70+=j87;var J3b=q2E;J3b+=b$b;J3b+=B9q;var w50=k7W;w50+=O28;var d9U=K9b;d9U+=Z0S;var l28=y6o;l28+=w5K;var A$4=i57;A$4+=m0p;A$4+=E88;A$4+=c0r;var a5F=K9b;a5F+=v8t;a5F+=k9f;var D_w=y7x;D_w+=X2M;D_w+=O6E;D_w+=w5K;var W0Y=q$p;W0Y+=R$N;W0Y+=l92;W0Y+=j87;var X4f=c9p;X4f+=M$k;var g99=t7k;g99+=k0f;g99+=v1q;g99+=i5D;var x$H=H7s;x$H+=E_j;var V7o=l9S;V7o+=m$G;V7o+=X2D;var y4s=R8L;y4s+=W8G;var T5B=q2E;T5B+=k4G;T5B+=n3B;var F4M=L8P;F4M+=n3B;var v7y=P6q;v7y+=x3_;v7y+=R02;v7y+=n3B;var X5z=f9W;X5z+=v4k;var s4t=r7lc_[631343];s4t+=v4k;s4t+=x_0;s4t+=l4$;if(multiple === void U3X){multiple=B4$;}var btnClass=editor[s4t][O2E][X5z];var container=$(v7y + F4M + T5B + y4s + V7o + btnClass + x1Z + P$s + (multiple?x$H:D3I) + g99 + a$h + X4f + D8a + btnClass + W0Y + D_w + a5F + y1t + A$4 + l28 + d9U + w50 + J3b + I70 + a$h + a$h + a$h);conf[G8n]=container;conf[i1G]=E6A;if(conf[W7_]){var u$1=O6E;u$1+=X2M;var W4r=l4$;W4r+=G1I;W4r+=X2M;var j$s=Y0M;j$s+=m3n;j$s+=d9d;j$s+=g$M;var C_2=o7b;C_2+=k88;container[C_2](j$s)[r0r](v3H,Editor[W4r](conf[u$1]));}if(conf[r0r]){var v4c=p0h;v4c+=r7lc_.I0t;v4c+=g$A;var k4L=M4$;k4L+=r7lc_.I0t;k4L+=r7lc_.I0t;k4L+=g$A;var R72=F2c;R72+=F0w;var r3A=r7lc_.q78;r3A+=O6E;r3A+=r7lc_[616964];r3A+=X2M;container[r3A](R72)[k4L](conf[v4c]);}_buttonText(conf);if(window[o_L] && conf[d6M] !== B4$){var o0y=R7l;o0y+=Z_p;var c9F=B_4;c9F+=r7lc_[616964];var H9_=B_4;H9_+=r7lc_[616964];var A_B=u8x;A_B+=R8u;A_B+=g$A;var w5Q=B_4;w5Q+=r7lc_[616964];var D3f=u8x;D3f+=q_1;D3f+=G$d;D3f+=U7x;var W1k=e8l;W1k+=B_4;W1k+=D_g;var M6f=W2O;M6f+=E1B;M6f+=U8s;var r1q=k1D;r1q+=D_g;r1q+=X3y;container[B5B](p8q)[L9$](conf[r1q] || M6f);var dragDrop_1=container[B5B](W1k);dragDrop_1[e40](r3I,function(e){var z3J="aTransfe";var O6t="gin";var J$e="lEvent";var E9g='over';var w_A="removeCla";var M4W="ori";if(conf[E4i]){var U1O=w_A;U1O+=l4$;U1O+=l4$;var D4$=r7lc_.q78;D4$+=O6E;D4$+=m4H;var h3F=X2M;h3F+=p0h;h3F+=z3J;h3F+=g$A;var S0K=M4W;S0K+=O6t;S0K+=M4$;S0K+=J$e;Editor[G_$](editor,conf,e[S0K][h3F][D4$],_buttonText,dropCallback);dragDrop_1[U1O](E9g);}return B4$;})[e40](D3f,function(e){var k1Y="ov";r7lc_.y2x();var w5q=I95;w5q+=T69;w5q+=q_1;w5q+=X2M;if(conf[w5q]){var z2H=k1Y;z2H+=E_j;z2H+=g$A;var g6q=b3W;g6q+=R8u;g6q+=S5t;g6q+=k$S;dragDrop_1[g6q](z2H);}return B4$;})[w5Q](A_B,function(e){if(conf[E4i]){var u5x=B_4;u5x+=b$b;u5x+=E_j;u5x+=g$A;var c1O=n7F;c1O+=S5t;c1O+=k$S;dragDrop_1[c1O](u5x);}return B4$;});editor[H9_](o_e,function(){var X$W='dragover.DTE_Upload drop.DTE_Upload';var G3h=B_4;r7lc_.y2x();G3h+=r7lc_[616964];$(N$f)[G3h](X$W,function(e){return B4$;});})[c9F](o0y,function(){var x5S="dragover.DTE_Upload dro";var k8H="p.DTE_Upl";var Q4k=x5S;Q4k+=k8H;Q4k+=B_4;Q4k+=i4r;var M7p=T69;M7p+=B_4;M7p+=a_Y;$(M7p)[i2_](Q4k);});}else {var i1L=J3B;i1L+=g$A;i1L+=C_h;container[l7F](M71);container[C__](container[B5B](i1L));}container[U7G](a26)[B4v](P9u,function(e){var y59="preventDe";var b2T=i3B;b2T+=P7N;var V5M=y59;V5M+=V56;e[V5M]();if(conf[b2T]){var I7Z=r7lc_[631343];I7Z+=I0x;upload[V93][I7Z](editor,conf,D3I);}});container[B5B](v8y)[e40](b_I,function(){Editor[G_$](editor,conf,this[i9z],_buttonText,function(ids,error){var y$o=o7b;y$o+=k88;if(!error){var I6s=r7lc_[631343];I6s+=M4$;I6s+=h8z;dropCallback[I6s](editor,ids);}container[y$o](v8y)[U3X][F7A]=D3I;});});return container;}function _triggerChange(input){r7lc_.y2x();setTimeout(function(){var d6p='change';r7lc_.y2x();var h8m="igge";var q4k=M_A;q4k+=h8m;q4k+=g$A;input[q4k](d6p,{editor:E6A,editorSet:E6A});;},U3X);}var baseFieldType=$[b$J](E6A,{},fieldType,{canReturnSubmit:function(conf,node){return E6A;},disable:function(conf){var o4X=A9N;o4X+=l4$;o4X+=u6f;var T9z=j8y;T9z+=B_4;r7lc_.y2x();T9z+=D_g;conf[G8n][T9z](o4X,E6A);},enable:function(conf){var X3R=r7h;X3R+=d7M;var i07=D_g;i07+=g$A;i07+=M8e;var L$6=i3B;L$6+=O6E;L$6+=c03;L$6+=F3T;conf[L$6][i07](X3R,B4$);},get:function(conf){r7lc_.y2x();return conf[G8n][w81]();},set:function(conf,val){var J_q=B7h;J_q+=v1q;J_q+=r7lc_.I0t;conf[J_q][w81](val);_triggerChange(conf[G8n]);}});var hidden={create:function(conf){var d0D=q2O;d0D+=v4k;d0D+=x5w;conf[G8n]=$(p4v);conf[a3h]=conf[d0D];r7lc_.w49();return v5D;},get:function(conf){var Z$v=Z71;Z$v+=M4$;Z$v+=v4k;return conf[Z$v];},set:function(conf,val){var W_q=b$b;W_q+=M4$;W_q+=v4k;var T46=i3B;T46+=b$b;T46+=w7Q;var B26=i3B;B26+=b$b;r7lc_.y2x();B26+=w7Q;var oldVal=conf[B26];conf[T46]=val;conf[G8n][W_q](val);if(oldVal !== val){var S5g=o8Q;S5g+=j1j;S5g+=r7lc_.I0t;_triggerChange(conf[S5g]);}}};var readonly=$[I_a](E6A,{},baseFieldType,{create:function(conf){var w9k=o8Q;w9k+=j1j;w9k+=r7lc_.I0t;var h3o=r7lc_.I0t;h3o+=j7C;h3o+=r7lc_.I0t;var x8w=O6E;x8w+=X2M;var K2X=l4$;K2X+=M4$;K2X+=k1l;K2X+=X2M;var L_n=E_j;L_n+=q40;L_n+=E_j;L_n+=k88;var x$R=p0h;x$R+=r7lc_.I0t;x$R+=g$A;var Y$b=K9b;Y$b+=k0f;Y$b+=P5m;Y$b+=r2v;conf[G8n]=$(Y$b)[x$R]($[L_n]({id:Editor[K2X](conf[x8w]),readonly:D69,type:h3o},conf[r0r] || ({})));return conf[w9k][U3X];}});var text=$[b$J](E6A,{},baseFieldType,{create:function(conf){var t57=p0h;t57+=r7lc_.I0t;t57+=g$A;var W1D=r7lc_.I0t;r7lc_.w49();W1D+=O6h;var O5H=O6E;O5H+=X2M;var c8v=j7C;c8v+=H_8;c8v+=k88;var C5b=p0h;C5b+=r7lc_.I0t;C5b+=g$A;conf[G8n]=$(p4v)[C5b]($[c8v]({id:Editor[M$Y](conf[O5H]),type:W1D},conf[t57] || ({})));return conf[G8n][U3X];}});var password=$[b$J](E6A,{},baseFieldType,{create:function(conf){var E7K="<input";var R2d="pas";var G$Y="sw";var H7P=B7h;H7P+=v1q;H7P+=r7lc_.I0t;var N7u=R2d;N7u+=G$Y;N7u+=B_4;N7u+=Z5A;var h7p=O6E;h7p+=X2M;var k93=w0U;k93+=k1l;k93+=X2M;var g3x=S5R;g3x+=k88;var m$d=M4$;m$d+=r7lc_.I0t;m$d+=r7lc_.I0t;m$d+=g$A;var f86=E7K;f86+=r2v;var X0U=x0H;X0U+=L2t;X0U+=r7lc_.I0t;conf[X0U]=$(f86)[m$d]($[g3x]({id:Editor[k93](conf[h7p]),type:N7u},conf[r0r] || ({})));return conf[H7P][U3X];}});var textarea=$[b$J](E6A,{},baseFieldType,{canReturnSubmit:function(conf,node){r7lc_.w49();return B4$;},create:function(conf){var o$Z="eId";var W_G='<textarea></textarea>';var g0w=o8Q;g0w+=F3T;var q0F=l4$;q0F+=M4$;q0F+=r7lc_.q78;q0F+=o$Z;var n4z=E_j;n4z+=q40;n4z+=v1N;var m_g=i3B;m_g+=k0f;m_g+=D_g;m_g+=F3T;conf[m_g]=$(W_G)[r0r]($[n4z]({id:Editor[q0F](conf[e4a])},conf[r0r] || ({})));return conf[g0w][U3X];}});var select=$[h5d](E6A,{},baseFieldType,{_addOptions:function(conf,opts,append){var b5S="placehol";var L6H="hidden";var h7c="irs";var E_p="placeholderValue";var e_1="sPair";var J1X="placeh";var H6t="lderDisabled";var k2v="isabled";var X3s="derD";var c7b="placeho";if(append === void U3X){append=B4$;}var elOpts=conf[G8n][U3X][W0g];var countOffset=U3X;if(!append){var A0N=q_1;A0N+=r7lc_[616964];A0N+=H76;elOpts[A0N]=U3X;if(conf[W20] !== undefined){var F3S=b5S;F3S+=X3s;F3S+=k2v;var X5s=c7b;X5s+=H6t;var K2J=J1X;K2J+=Z7b;K2J+=E_x;var placeholderValue=conf[E_p] !== undefined?conf[E_p]:D3I;countOffset+=F9J;elOpts[U3X]=new Option(conf[K2J],placeholderValue);var disabled=conf[X5s] !== undefined?conf[F3S]:E6A;elOpts[U3X][L6H]=disabled;elOpts[U3X][t1N]=disabled;elOpts[U3X][l1e]=placeholderValue;}}else {countOffset=elOpts[b_m];}if(opts){var N7i=B_4;N7i+=R9U;N7i+=e_1;var s9h=D8t;s9h+=h7c;Editor[s9h](opts,conf[N7i],function(val,label,i,attr){var option=new Option(label,val);option[l1e]=val;if(attr){var o6J=X5E;o6J+=g$A;$(option)[o6J](attr);}elOpts[i + countOffset]=option;});}},create:function(conf){var O2I="ip";var n7G="Opts";var e5S='<select></select>';var I0l=O2I;I0l+=n7G;var t3w=X5E;t3w+=g$A;var V$W=p0h;V$W+=M_A;var J2w=x0H;J2w+=G8$;conf[J2w]=$(e5S)[V$W]($[b$J]({id:Editor[M$Y](conf[e4a]),multiple:conf[t4X] === E6A},conf[t3w] || ({})))[e40](F1q,function(e,d){var w4H="_last";var b3U="Set";r7lc_.y2x();if(!d || !d[g0f]){var p8I=z5X;p8I+=E_j;p8I+=r7lc_.I0t;var g8R=w4H;g8R+=b3U;conf[g8R]=select[p8I](conf);}});select[f5e](conf,conf[W0g] || conf[I0l]);return conf[G8n][U3X];},destroy:function(conf){var z63=B_4;z63+=r7lc_.q78;z63+=r7lc_.q78;var x9Y=i3B;x9Y+=O6E;x9Y+=c03;x9Y+=F3T;r7lc_.y2x();conf[x9Y][z63](F1q);},get:function(conf){var Z$$="separat";var C4W='option:selected';var f1t="_inpu";var c0Y=s3q;c0Y+=x$U;c0Y+=v4k;c0Y+=E_j;var n0o=r7lc_.I0t;n0o+=B_4;n0o+=o32;n0o+=D7T;var q2U=J8U;q2U+=H19;var Q6j=f1t;Q6j+=r7lc_.I0t;var val=conf[Q6j][B5B](C4W)[q2U](function(){return this[l1e];})[n0o]();if(conf[c0Y]){var i8_=Z$$;i8_+=G2G;var V1r=m9k;V1r+=p0h;V1r+=B_4;V1r+=g$A;return conf[V1r]?val[R6n](conf[i8_]):val;}return val[b_m]?val[U3X]:v5D;},set:function(conf,val,localUpdate){var t6J="_la";var v9x="ted";var A8l="ator";var D2R="epar";var s3s="ec";var j8q="sel";var v9m="stS";var R8z='option';var e$E="lit";var r2q=s3q;r2q+=I7n;r2q+=M5f;var m_8=B_4;m_8+=R9U;var z3a=r7lc_.q78;z3a+=O6E;z3a+=r7lc_[616964];z3a+=X2M;var v$8=r7lc_.q78;v$8+=O6E;v$8+=r7lc_[616964];v$8+=X2M;var w2P=B7h;w2P+=D_g;w2P+=j1j;w2P+=r7lc_.I0t;var P3P=q_1;P3P+=s2T;P3P+=L8X;var j6W=O_r;j6W+=g$T;if(!localUpdate){var w6Y=t6J;w6Y+=v9m;w6Y+=E_j;w6Y+=r7lc_.I0t;conf[w6Y]=val;}if(conf[t4X] && conf[j6W] && !Array[Z6E](val)){var n$r=l4$;n$r+=D2R;n$r+=A8l;var x5V=u05;x5V+=e$E;val=typeof val === X0M?val[x5V](conf[n$r]):[];}else if(!Array[Z6E](val)){val=[val];}var i;var len=val[P3P];var found;var allFound=B4$;var options=conf[w2P][v$8](R8z);conf[G8n][z3a](m_8)[n8S](function(){var S9l="lec";var y6r="_edi";var i_4="tor_val";var Y81=l4$;Y81+=E_j;Y81+=S9l;Y81+=v9x;r7lc_.w49();found=B4$;for(i=U3X;i < len;i++){var R4y=y6r;R4y+=i_4;if(this[R4y] == val[i]){found=E6A;allFound=E6A;break;}}this[Y81]=found;});if(conf[W20] && !allFound && !conf[r2q] && options[b_m]){var I7w=j8q;I7w+=s3s;I7w+=v9x;options[U3X][I7w]=E6A;}if(!localUpdate){var w9p=x0H;w9p+=L2t;w9p+=r7lc_.I0t;_triggerChange(conf[w9p]);}return allFound;},update:function(conf,options,append){var E_3="ddOpti";var r1C="_a";var A5c=r1C;A5c+=E_3;A5c+=U9P;select[A5c](conf,options,append);var lastSet=conf[w__];if(lastSet !== undefined){var G0J=l4$;G0J+=E_j;G0J+=r7lc_.I0t;select[G0J](conf,lastSet,E6A);}_triggerChange(conf[G8n]);}});var checkbox=$[b$J](E6A,{},baseFieldType,{_addOptions:function(conf,opts,append){var c6Q=i3B;c6Q+=Y0M;c6Q+=r7lc_.I0t;if(append === void U3X){append=B4$;}var jqInput=conf[c6Q];var offset=U3X;if(!append){jqInput[K2o]();}else {var L2C=k0f;L2C+=P5m;offset=$(L2C,jqInput)[b_m];}if(opts){Editor[J7L](opts,conf[R2m],function(val,label,i,attr){var I7F="</labe";var y6$="saf";var l4C='" type="checkbox" />';var M5_="l>";var H0Q=i3B;H0Q+=g0f;H0Q+=a3h;var L6P=X5E;L6P+=g$A;var Z2D=I7F;Z2D+=M5_;var A5r=X2D;r7lc_.y2x();A5r+=j87;var T4l=y6$;T4l+=E_j;T4l+=a0d;jqInput[C__](O6B + M78 + Editor[M$Y](conf[e4a]) + B_F + (i + offset) + l4C + Y4P + Editor[T4l](conf[e4a]) + B_F + (i + offset) + A5r + label + Z2D + a$h);$(O$H,jqInput)[L6P](j7H,val)[U3X][H0Q]=val;if(attr){var m7C=M4$;m7C+=r7lc_.I0t;m7C+=r7lc_.I0t;m7C+=g$A;$(O$H,jqInput)[m7C](attr);}});}},create:function(conf){var Q$c="<div></di";var p5K=Q$c;p5K+=w5K;conf[G8n]=$(p5K);checkbox[f5e](conf,conf[W0g] || conf[g2U]);return conf[G8n][U3X];},disable:function(conf){var W06=D_g;W06+=g$A;W06+=M8e;var Q4_=Y0M;Q4_+=r7lc_.I0t;var O3g=x0H;O3g+=G8$;conf[O3g][B5B](Q4_)[W06](d2K,E6A);},enable:function(conf){var p4i=D_g;p4i+=g$A;p4i+=M8e;var k4i=O6E;k4i+=c03;k4i+=F3T;var m91=x0H;m91+=c03;m91+=F3T;conf[m91][B5B](k4i)[p4i](d2K,B4$);},get:function(conf){var u9s="ara";var w$u="Valu";var q9A="oi";var Q_z="Value";var Z15="ato";var D4_="unsele";var a7d="unselected";var C82=m9k;C82+=Z15;C82+=g$A;var q5L=r_k;q5L+=q9A;q5L+=r7lc_[616964];var a5H=l4$;a5H+=M$w;a5H+=g$T;var f8B=O_r;f8B+=u9s;f8B+=w2q;var g$4=a7d;g$4+=w$u;g$4+=E_j;var M5Y=v4k;M5Y+=p9c;M5Y+=L8X;r7lc_.y2x();var k5I=o8Q;k5I+=F3T;var out=[];var selected=conf[k5I][B5B](h9C);if(selected[M5Y]){var s_m=s9A;s_m+=D5x;selected[s_m](function(){r7lc_.y2x();out[r4r](this[l1e]);});}else if(conf[g$4] !== undefined){var k0$=D4_;k0$+=h9w;k0$+=C_h;k0$+=Q_z;var S6z=D_g;S6z+=j1j;S6z+=m8k;out[S6z](conf[k0$]);}return conf[f8B] === undefined || conf[a5H] === v5D?out:out[q5L](conf[C82]);},set:function(conf,val){var R8j='|';var j_U="sepa";var L6R="rator";var Y0s="split";var P71=r1M;P71+=o32;P71+=N7x;P71+=R1v;var G$x=O6E;G$x+=r7lc_[616964];G$x+=v1q;G$x+=r7lc_.I0t;var V2y=r7lc_.q78;V2y+=O6E;V2y+=r7lc_[616964];V2y+=X2M;var jqInputs=conf[G8n][V2y](G$x);if(!Array[Z6E](val) && typeof val === X0M){var K76=j_U;K76+=L6R;val=val[Y0s](conf[K76] || R8j);}else if(!Array[P71](val)){val=[val];}var i;var len=val[b_m];var found;jqInputs[n8S](function(){var S37="che";var j2r=S37;j2r+=e3Y;j2r+=E_j;j2r+=X2M;found=B4$;for(i=U3X;i < len;i++){var s6i=y_3;s6i+=A9N;s6i+=w2q;s6i+=a3h;if(this[s6i] == val[i]){found=E6A;break;}}this[j2r]=found;});_triggerChange(jqInputs);},update:function(conf,options,append){var P0d=l4$;P0d+=E_j;P0d+=r7lc_.I0t;var J5O=z5X;J5O+=E_j;J5O+=r7lc_.I0t;var currVal=checkbox[J5O](conf);checkbox[f5e](conf,options,append);checkbox[P0d](conf,currVal);}});var radio=$[b$J](E6A,{},baseFieldType,{_addOptions:function(conf,opts,append){var y3n="air";var b7l="sP";if(append === void U3X){append=B4$;}var jqInput=conf[G8n];var offset=U3X;if(!append){jqInput[K2o]();}else {var y1G=F2c;y1G+=F3T;offset=$(y1G,jqInput)[b_m];}if(opts){var V$d=A6W;V$d+=z76;V$d+=b7l;V$d+=y3n;Editor[J7L](opts,conf[V$d],function(val,label,i,attr){var C$m="\" ";var Q8F="ttr";var c$G="dio\" name=\"";var y5W='" />';var L_J="=\"ra";var z$G='</label>';var h71=X5E;h71+=g$A;var J_D=K9b;J_D+=v8t;J_D+=O6E;J_D+=w5K;var i_d=C$m;i_d+=U5U;i_d+=L_J;i_d+=c$G;var F5U=O6E;F5U+=X2M;jqInput[C__](O6B + M78 + Editor[M$Y](conf[F5U]) + B_F + (i + offset) + i_d + conf[P8N] + y5W + Y4P + Editor[M$Y](conf[e4a]) + B_F + (i + offset) + T3G + label + z$G + J_D);r7lc_.w49();$(O$H,jqInput)[h71](j7H,val)[U3X][l1e]=val;if(attr){var B6j=M4$;B6j+=Q8F;$(O$H,jqInput)[B6j](attr);}});}},create:function(conf){var P6s="<div /";var x7V="_addOpt";var P70=i3B;P70+=k0f;P70+=v1q;P70+=r7lc_.I0t;r7lc_.w49();var h$a=M8e;h$a+=E_j;h$a+=r7lc_[616964];var c$h=B_4;c$h+=r7lc_[616964];var H24=x7V;H24+=e7D;var Z57=P6s;Z57+=j87;conf[G8n]=$(Z57);radio[H24](conf,conf[W0g] || conf[g2U]);this[c$h](h$a,function(){var K5G=E_j;K5G+=e8A;K5G+=L8X;var p25=k0f;p25+=D_g;p25+=j1j;p25+=r7lc_.I0t;var n4w=i3B;n4w+=F2c;n4w+=j1j;n4w+=r7lc_.I0t;conf[n4w][B5B](p25)[K5G](function(){var n3T="cke";if(this[I5P]){var o0U=D5x;o0U+=E_j;o0U+=n3T;o0U+=X2M;this[o0U]=E6A;}});});return conf[P70][U3X];},disable:function(conf){var u3S="fin";var e$b=x3H;e$b+=v4k;r7lc_.y2x();e$b+=C_h;var J50=u3S;J50+=X2M;conf[G8n][J50](Z8k)[N83](e$b,E6A);},enable:function(conf){var k1n=r7h;k1n+=d7M;var g7h=D_g;g7h+=g$A;g7h+=B_4;g7h+=D_g;var q7$=Y0M;q7$+=r7lc_.I0t;var E95=x0H;E95+=G8$;r7lc_.w49();conf[E95][B5B](q7$)[g7h](k1n,B4$);},get:function(conf){r7lc_.w49();var J8k="lectedV";var G8z="unselectedValue";var A$a=u74;A$a+=Z_p;A$a+=J8k;A$a+=L4R;var p68=r7lc_.q78;p68+=O6E;p68+=k88;var el=conf[G8n][p68](h9C);if(el[b_m]){return el[U3X][l1e];}return conf[A$a] !== undefined?conf[G8z]:undefined;},set:function(conf,val){var Y4L=r7lc_.q78;Y4L+=k0f;Y4L+=X2M;var w3y=l_b;w3y+=L8X;var x7c=r7lc_.q78;x7c+=k0f;x7c+=X2M;var v4e=x0H;v4e+=r7lc_[616964];v4e+=D_g;v4e+=F3T;conf[v4e][x7c](Z8k)[w3y](function(){var q$y="Checke";var n1n="eChe";var B_N="cked";var c8h="ecke";var k4n="_pr";var v$N="checked";this[I5P]=B4$;if(this[l1e] == val){var x1q=k4n;x1q+=n1n;x1q+=B_N;var p$F=r7lc_[631343];p$F+=L8X;p$F+=c8h;p$F+=X2M;this[p$F]=E6A;this[x1q]=E6A;}else {var B49=i3B;B49+=S7d;B49+=q$y;B49+=X2M;this[v$N]=B4$;this[B49]=B4$;}});_triggerChange(conf[G8n][Y4L](h9C));},update:function(conf,options,append){var g2$='[value="';var z7r="filter";var g5t=p0h;g5t+=M_A;var G2A=X2D;G2A+=D31;var a4h=l4$;a4h+=E_j;a4h+=r7lc_.I0t;var N$M=i3B;N$M+=O6E;N$M+=r7lc_[616964];N$M+=P5m;r7lc_.w49();var U5I=P99;U5I+=r7lc_.I0t;var currVal=radio[U5I](conf);radio[f5e](conf,options,append);var inputs=conf[N$M][B5B](Z8k);radio[a4h](conf,inputs[z7r](g2$ + currVal + G2A)[b_m]?currVal:inputs[B3Q](U3X)[g5t](j7H));}});var datetime=$[b$J](E6A,{},baseFieldType,{create:function(conf){var V4Y="loseFn";var z8u='<input />';var q$G="safeI";var B0N="entLocal";var I9P="locale";var g6t="eTime";var g3q="_closeFn";var b4q='DateTime library is required';var F4H="format";var L2I="momentStrict";var y4V="omentLocale";var r8p="strict";var t8E="mom";var T3W="loc";var T_z="ime";var k3d="yForma";var S3b=X2t;S3b+=R8R;S3b+=G8$;var s7t=W8W;s7t+=V4Y;var y$n=k0r;y$n+=H_8;y$n+=r7lc_.I0t;y$n+=T_z;var a7P=w2n;a7P+=V7l;a7P+=k3d;a7P+=r7lc_.I0t;var G11=O6h;G11+=E_j;G11+=r7lc_[616964];G11+=X2M;var G5o=i3B;G5o+=O6E;G5o+=c03;G5o+=F3T;var x8A=B_4;x8A+=D_g;x8A+=r7lc_.I0t;x8A+=l4$;var e_x=T3W;e_x+=M4$;e_x+=q_1;var y8Q=M8e;y8Q+=r7lc_.I0t;y8Q+=l4$;var u6q=t8E;u6q+=B0N;u6q+=E_j;var N6G=v0G;N6G+=r7lc_.I0t;N6G+=g6t;var S_2=r7lc_.I0t;S_2+=E_j;S_2+=D34;S_2+=r7lc_.I0t;var r2t=O6E;r2t+=X2M;var m3t=q$G;m3t+=X2M;var q53=E_j;r7lc_.y2x();q53+=D34;q53+=H_8;q53+=k88;conf[G8n]=$(z8u)[r0r]($[q53](E6A,{id:Editor[m3t](conf[r2t]),type:S_2},conf[r0r]));if(!DataTable$3[N6G]){Editor[S_q](b4q,E7S);}if(conf[u6q] && !conf[y8Q][e_x]){var e1m=J8U;e1m+=y4V;var a4a=B_4;a4a+=D_g;a4a+=B8k;conf[a4a][I9P]=conf[e1m];}if(conf[L2I] && !conf[x8A][r8p]){var V43=t_U;V43+=h9w;var Z7_=B_4;Z7_+=D_g;Z7_+=r7lc_.I0t;Z7_+=l4$;conf[Z7_][V43]=conf[L2I];}conf[D6l]=new DataTable$3[W_v](conf[G5o],$[G11]({format:conf[a7P] || conf[F4H],i18n:this[N9v][y$n]},conf[k6u]));conf[s7t]=function(){var Q15=f$T;Q15+=e3Y;Q15+=E_j;Q15+=g$A;conf[Q15][k5O]();};if(conf[S3b] === B4$){var x54=B_4;x54+=r7lc_[616964];conf[G8n][x54](V6J,function(e){r7lc_.y2x();e[E8h]();});}this[e40](M9H,conf[g3q]);return conf[G8n][U3X];},destroy:function(conf){var Q5N="oseFn";var G3K="dest";var J$K="yd";var Z01=G3K;Z01+=g$A;Z01+=B_4;Z01+=R1v;var K0d=r4Y;K0d+=J$K;K0d+=B_4;K0d+=x0D;var B6A=B_4;B6A+=r7lc_.q78;B6A+=r7lc_.q78;var q5v=C6C;q5v+=Q5N;var E2V=r7lc_[631343];E2V+=v4k;E2V+=B_4;E2V+=Z_p;var a50=B_4;a50+=r7lc_.q78;a50+=r7lc_.q78;this[a50](E2V,conf[q5v]);conf[G8n][B6A](K0d);conf[D6l][Z01]();},errorMessage:function(conf,msg){var P9N="errorMsg";r7lc_.y2x();conf[D6l][P9N](msg);},get:function(conf){var c0p="wireFormat";var v7D="valFormat";var G3Y="wire";var p6R=q2O;p6R+=v4k;var W2M=B7h;W2M+=P5m;var j6H=G3Y;j6H+=A1W;j6H+=d3j;j6H+=p0h;var o1k=f$T;o1k+=e3Y;o1k+=B2h;return conf[c0p]?conf[o1k][v7D](conf[j6H]):conf[W2M][p6R]();},maxDate:function(conf,max){r7lc_.w49();var O71=i3B;O71+=d0Q;conf[O71][Q_x](max);},minDate:function(conf,min){var W$x="min";var q7v="_pic";var d65=q7v;r7lc_.w49();d65+=r4Y;d65+=g$A;conf[d65][W$x](min);},owns:function(conf,node){var Q_r="wns";var x_v="_picke";var j$6=B_4;j$6+=Q_r;var T0N=x_v;T0N+=g$A;r7lc_.y2x();return conf[T0N][j$6](node);},set:function(conf,val){var a4_="valFo";var Z_m="rma";var m95="wireF";var L9Q="_pick";var P1R="ndexOf";var J$P="wireForma";var L5v=m95;L5v+=d3j;L5v+=p0h;var D9y=Q_4;D9y+=Q_4;var D0w=O6E;D0w+=P1R;if(typeof val === X0M && val && val[D0w](D9y) !== U3X && conf[L5v]){var E$w=J$P;E$w+=r7lc_.I0t;var X3e=a4_;X3e+=Z_m;X3e+=r7lc_.I0t;var r61=L9Q;r61+=B2h;conf[r61][X3e](conf[E$w],val);}else {var i0G=b$b;i0G+=M4$;i0G+=v4k;var g$O=i3B;g$O+=d0Q;conf[g$O][i0G](val);}r7lc_.w49();_triggerChange(conf[G8n]);}});var upload=$[b$J](E6A,{},baseFieldType,{canReturnSubmit:function(conf,node){return B4$;},create:function(conf){var editor=this;r7lc_.y2x();var container=_commonUpload(editor,conf,function(val){var f56="Up";var j3D="pos";var j7K=j3D;j7K+=r7lc_.I0t;j7K+=f56;j7K+=B$z;var H98=l4$;H98+=s7X;upload[H98][e27](editor,conf,val[U3X]);editor[M4P](j7K,[conf[P8N],val[U3X]]);});return container;},disable:function(conf){var i5w=i3B;i5w+=P7N;conf[G8n][B5B](Z8k)[N83](d2K,E6A);conf[i5w]=B4$;},enable:function(conf){r7lc_.y2x();var j51="_enab";var X0X=j51;X0X+=q_1;X0X+=X2M;var z_2=O6E;z_2+=c03;z_2+=j1j;z_2+=r7lc_.I0t;conf[G8n][B5B](z_2)[N83](d2K,B4$);conf[X0X]=E6A;},get:function(conf){var n82=Z71;r7lc_.w49();n82+=w7Q;return conf[n82];},set:function(conf,val){var e$z="gge";var O0z="ler";var q1H="an>";var H2p='noClear';var r0U="<sp";var R8I="rHand";var P5u="learText";var S_D='div.clearValue button';var n49="</spa";var I9m="eClass";var m8o="lear";var y0P="ndered";var f53="No f";var q18=c6e;q18+=e$z;q18+=R8I;q18+=O0z;var X_d=k0f;X_d+=v1q;X_d+=r7lc_.I0t;var K04=r7lc_.q78;K04+=O6E;K04+=r7lc_[616964];K04+=X2M;var v1Q=r7lc_[631343];v1Q+=P5u;var B9R=r7lc_.q78;B9R+=O6E;B9R+=r7lc_[616964];B9R+=X2M;var v_D=i3B;v_D+=O6E;v_D+=c03;v_D+=F3T;var S28=Z71;S28+=M4$;S28+=v4k;conf[S28]=val;conf[v_D][w81](D3I);var container=conf[G8n];if(conf[u_G]){var z9H=i3B;z9H+=q2O;z9H+=v4k;var T4i=y7h;T4i+=g$A;T4i+=E_j;T4i+=y0P;var rendered=container[B5B](T4i);if(conf[z9H]){var V9W=i3B;V9W+=w81;rendered[I52](conf[u_G](conf[V9W]));}else {var J5D=n49;J5D+=r7lc_[616964];J5D+=j87;var m0F=f53;m0F+=O9b;m0F+=E_j;var D5I=r0U;D5I+=q1H;rendered[K2o]()[C__](D5I + (conf[X7i] || m0F) + J5D);}}var button=container[B9R](S_D);if(val && conf[v1Q]){var g5$=F3m;g5$+=I9m;var X2i=r7lc_[631343];X2i+=m8o;X2i+=X3y;button[I52](conf[X2i]);container[g5$](H2p);}else {var C3J=M4$;C3J+=p_L;container[C3J](H2p);}conf[G8n][K04](X_d)[q18](f1$,[conf[a3h]]);}});var uploadMany=$[i_0](E6A,{},baseFieldType,{_showHide:function(conf){var k85="imit";var y2q="lim";var U7c="limit";var L0l='div.limitHide';var j5J="_container";var P2h="im";var j$Y="itLeft";r7lc_.w49();var F1G=v4k;F1G+=f1i;var g4o=i3B;g4o+=v4k;g4o+=P2h;g4o+=j$Y;var v8b=V88;v8b+=B_4;v8b+=r7lc_[631343];v8b+=O5j;var C97=r7lc_[616964];C97+=e40;C97+=E_j;var l72=v4k;l72+=k85;var Z0H=i3B;Z0H+=q2O;Z0H+=v4k;var F96=w2n;F96+=v4k;F96+=v7E;var f4M=r7lc_[631343];f4M+=l4$;f4M+=l4$;var v9u=y2q;v9u+=c34;if(!conf[v9u]){return;}conf[j5J][B5B](L0l)[f4M](F96,conf[Z0H][b_m] >= conf[l72]?C97:v8b);conf[g4o]=conf[U7c] - conf[a3h][F1G];},canReturnSubmit:function(conf,node){r7lc_.w49();return B4$;},create:function(conf){var O6J="_co";var y$A="nta";var S2g='button.remove';var z9R='multi';var u7L=O6J;u7L+=y$A;u7L+=k0f;u7L+=B2h;var editor=this;var container=_commonUpload(editor,conf,function(val){var q1T='postUpload';var Y_H="concat";var H69=i3B;H69+=w81;var g2g=Z71;g2g+=w7Q;var B2q=Z5H;B2q+=v4k;B2q+=v4k;var s0U=i3B;s0U+=w81;r7lc_.w49();var p2Z=i3B;p2Z+=w81;conf[p2Z]=conf[s0U][Y_H](val);uploadMany[V93][B2q](editor,conf,conf[g2g]);editor[M4P](q1T,[conf[P8N],conf[H69]]);},E6A);container[l7F](z9R)[e40](R9$,S2g,function(e){var P50="stopPro";r7lc_.y2x();var C$J="pagation";var t7I='idx';var U46=i3B;U46+=P7N;var w9C=P50;w9C+=C$J;e[w9C]();if(conf[U46]){var x2K=Z71;x2K+=M4$;x2K+=v4k;var N6n=X2M;N6n+=p0h;N6n+=M4$;var idx=$(this)[N6n](t7I);conf[a3h][S8Q](idx,F9J);uploadMany[V93][e27](editor,conf,conf[x2K]);}});conf[u7L]=container;return container;},disable:function(conf){var q3I=I95;q3I+=T69;q3I+=x4W;var g$I=D_g;g$I+=Q8O;g$I+=D_g;var U5Y=r7lc_.q78;U5Y+=j3l;r7lc_.y2x();conf[G8n][U5Y](Z8k)[g$I](d2K,E6A);conf[q3I]=B4$;},enable:function(conf){var c7H="nabl";var w8q=y_3;w8q+=c7H;w8q+=C_h;var S87=x3H;S87+=x4W;var z6g=j8y;z6g+=M8e;var i68=o7b;i68+=k88;var W9x=B7h;r7lc_.y2x();W9x+=P5m;conf[W9x][i68](Z8k)[z6g](S87,B4$);conf[w8q]=E6A;},get:function(conf){var T4o=Z71;r7lc_.y2x();T4o+=M4$;T4o+=v4k;return conf[T4o];},set:function(conf,val){var Z$I="empt";var y_D="ay as a value";var p0E="<s";var i5J='No files';var Z2L='div.rendered';var X_h="Upload collectio";var Q4P="Hid";var E8I="ns must have an arr";var a_y="rHandler";var t8y="pan>";var a4b='<ul></ul>';var u7h="trigge";var n5n=u7h;n5n+=a_y;var D2m=F2c;D2m+=j1j;D2m+=r7lc_.I0t;var D8I=o7b;D8I+=r7lc_[616964];D8I+=X2M;var H0Z=i3B;H0Z+=O6E;H0Z+=r7lc_[616964];H0Z+=P5m;var m2h=W_u;m2h+=Q4P;m2h+=E_j;var Q9g=b$b;Q9g+=M4$;Q9g+=v4k;var M34=r1M;M34+=o32;M34+=D7T;if(!val){val=[];}if(!Array[M34](val)){var q8M=X_h;q8M+=E8I;q8M+=y_D;throw new Error(q8M);}conf[a3h]=val;conf[G8n][Q9g](D3I);var that=this;var container=conf[G8n];if(conf[u_G]){var y0a=v4k;y0a+=f1i;var r3X=Z$I;r3X+=R1v;var rendered=container[B5B](Z2L)[r3X]();if(val[y0a]){var M7B=l_b;M7B+=L8X;var list_1=$(a4b)[e06](rendered);$[M7B](val,function(i,file){var D8b=" remove\" d";var F3F="tton cl";var y2K="&tim";var c7a=";</button>";var o6a='<li>';var U9d="</l";var V3J=" <b";var i3F="ta-idx=\"";var n$n=X2M;n$n+=m_d;n$n+=v4k;n$n+=v7E;var display=conf[n$n](file,i);if(display !== v5D){var y$O=U9d;y$O+=F9i;var I8Q=n3B;I8Q+=y2K;I8Q+=s4U;I8Q+=c7a;var l22=D8b;l22+=M4$;l22+=i3F;var P3m=T69;P3m+=F3T;P3m+=r7lc_.I0t;P3m+=e40;var r2d=r7lc_.q78;r2d+=G2G;r2d+=J8U;var S0A=V3J;S0A+=j1j;S0A+=F3F;S0A+=m$O;list_1[C__](o6a + display + S0A + that[x6a][r2d][P3m] + l22 + i + I8Q + y$O);}});}else {var N8I=p0E;N8I+=t8y;var m3k=Z8y;m3k+=X2M;rendered[m3k](N8I + (conf[X7i] || i5J) + n0A);}}uploadMany[m2h](conf);conf[H0Z][D8I](D2m)[n5n](f1$,[conf[a3h]]);}});var datatable=$[b$J](E6A,{},baseFieldType,{_addOptions:function(conf,options,append){var V1V="lea";if(append === void U3X){append=B4$;}var dt=conf[V9F];if(!append){var G59=r7lc_[631343];G59+=V1V;G59+=g$A;dt[G59]();}dt[y5t][n7F](options)[D9M]();},_jumpToFirst:function(conf,editor){var r3f="xes";var h2Z="es_scrollB";var t0o="Of";var A8a="lie";var l2F="oor";var Q_O="fl";var x7P="ody";var E8e="numb";var j7S="div.dataTabl";var e7d=q_1;e7d+=w6p;e7d+=Q2T;var y6D=r7lc_.I0t;y6D+=U6p;y6D+=v4k;y6D+=E_j;var L$N=j7S;L$N+=h2Z;L$N+=x7P;var m7a=X2M;m7a+=g$A;m7a+=M4$;m7a+=R$a;var u_A=E8e;u_A+=E_j;u_A+=g$A;var h_E=H19;h_E+=Q4Z;h_E+=O6E;h_E+=C_h;var w18=g$A;w18+=B_4;w18+=R$a;var F0i=X2M;F0i+=r7lc_.I0t;var dt=conf[F0i];var idx=dt[w18]({order:h_E,selected:E6A})[s2i]();var page=U3X;if(typeof idx === u_A){var s13=Q_O;s13+=l2F;var q5$=j3l;q5$+=j7C;q5$+=t0o;var N3h=j3l;N3h+=E_j;N3h+=r3f;var b5y=f8o;b5y+=A8a;b5y+=X2M;var G$D=g$A;G$D+=B_4;G$D+=R$a;G$D+=l4$;var N_w=Z6$;N_w+=Q2T;var W3u=k0f;W3u+=H1k;var x5X=D_g;x5X+=M4$;x5X+=z5X;x5X+=E_j;var pageLen=dt[x5X][W3u]()[N_w];var pos=dt[G$D]({order:b5y})[N3h]()[q5$](idx);page=pageLen > U3X?Math[s13](pos / pageLen):U3X;}dt[A1e](page)[m7a](B4$);var container=$(L$N,dt[y6D]()[H4F]());var scrollTo=function(){var t7i="osi";r7lc_.y2x();var b6Z="scrollTop";var t$0='applied';var u6M=r7lc_.I0t;u6M+=B_4;u6M+=D_g;var T$6=D_g;T$6+=t7i;T$6+=r7lc_[399342];var Q$X=r7lc_[616964];Q$X+=B_4;Q$X+=X2M;Q$X+=E_j;var M1y=Q8O;M1y+=R$a;var node=dt[M1y]({order:t$0,selected:E6A})[Q$X]();var height=container[t2R]();var top=$(node)[T$6]()[u6M];if(top > height - F8x){container[b6Z](top);}};if(container[e7d]){var C$S=v4k;C$S+=a8P;C$S+=Q2T;var J2U=D_g;J2U+=M4$;J2U+=g$A;J2U+=y7j;if(container[J2U](N$f)[C$S]){scrollTo();}else {var p15=e40;p15+=E_j;editor[p15](o_e,function(){scrollTo();});}}},create:function(conf){var C_G=r7lc_;var u9J="oter";var W66="tableClass";var i_7='Label';var j4z="nsPair";var C9O="ser";var r4H="itor";var f4h="Btp";var y86="-select";var M_C="<tab";var N5T="Pair";var H2C="footer";var P6F="oo";var q5m="config";var g2d="le>";var v5F="pendTo";var p8h='<tr>';var r14='100%';var A_1='Search';C_G.w49();var r5z="it.dt";var v6g=" class=\"DTE_Field_Type_datatable_info\">";var X18="Tabl";var I9o="bmitComp";var k_g="foot>";var X2J="<t";var M14=A6W;M14+=O6E;M14+=e40;M14+=l4$;var A6z=v0L;A6z+=G2G;var N$u=j1j;N$u+=C9O;N$u+=y86;var X1n=B_4;X1n+=r7lc_[616964];var t$m=B_4;t$m+=r7lc_[616964];var A_2=R3w;A_2+=w6p;A_2+=q_1;var C0F=B_4;C0F+=l4$;var T3h=J8U;T3h+=j1j;T3h+=x$U;T3h+=q_1;var t9H=r7lc_.q78;t9H+=O6E;t9H+=f4h;var A_K=v4k;A_K+=U6p;A_K+=E_j;A_K+=v4k;var e8Q=B_4;e8Q+=K36;e8Q+=j4z;var h4E=t6W;h4E+=Y$P;h4E+=X18;h4E+=E_j;var S7X=O6E;S7X+=r7lc_[616964];S7X+=r5z;var Q28=B_4;Q28+=r7lc_[616964];var H3e=R$a;H3e+=O6E;H3e+=X2M;H3e+=Q2T;var P0u=M4$;P0u+=p_L;var L3z=r7lc_.q78;L3z+=P6F;L3z+=Z7e;var G0N=K9b;G0N+=A9N;G0N+=b$b;G0N+=v6g;var H4i=k7W;H4i+=k9f;var x20=M_C;x20+=g2d;var b2Z=B_4;b2Z+=D_g;b2Z+=a_M;b2Z+=N5T;var J4I=V7l;J4I+=T69;J4I+=F6Q;var x9V=A91;x9V+=X2M;var _this=this;conf[R2m]=$[x9V]({label:J4I,value:j7H},conf[b2Z]);var table=$(x20);var container=$(H4i)[C__](table);var side=$(G0N);if(conf[L3z]){var l9k=H19;l9k+=v5F;var K_a=H1k;K_a+=u9J;var I7J=H1k;I7J+=B_4;I7J+=r7lc_.I0t;I7J+=B2h;var y5J=s08;y5J+=o6M;var a4U=f8o;a4U+=a8w;a4U+=X2M;var U0d=X2J;U0d+=k_g;$(U0d)[a4U](Array[y5J](conf[I7J])?$(p8h)[C__]($[S6L](conf[H2C],function(str){C_G.w49();var e7W='<th>';var D_e=L8X;D_e+=W8L;return $(e7W)[D_e](str);})):conf[K_a])[l9k](table);}var dt=table[P0u](datatable[W66])[H3e](r14)[Q28](S7X,function(e,settings){var V4z='div.dt-buttons';var N2T='div.dataTables_info';var A4D="ables_filter";var X5h="init";var n_2=r7lc_.q78;n_2+=O6E;n_2+=r7lc_[616964];n_2+=X2M;var N69=H19;N69+=P6g;N69+=X2M;var K4O=y7h;K4O+=S_Z;K4O+=A4D;var w2X=r7lc_.q78;w2X+=O6E;w2X+=r7lc_[616964];w2X+=X2M;var S1k=h1q;S1k+=V88;S1k+=E_j;var c65=T1$;c65+=O6E;if(settings[h7P] !== table[U3X]){return;}var api=new DataTable$3[c65](settings);var containerNode=$(api[S1k](undefined)[H4F]());DataTable$3[T_8][X5h](api);side[C__](containerNode[w2X](K4O))[C__](containerNode[B5B](V4z))[N69](containerNode[n_2](N2T));})[h4E]($[b$J]({buttons:[],columns:[{data:conf[e8Q][A_K],title:i_7}],deferRender:E6A,dom:t9H,language:{paginate:{next:V_Z,previous:e4F},search:D3I,searchPlaceholder:A_1},lengthChange:B4$,select:{style:conf[T3h]?C0F:A_2}},conf[q5m]));this[t$m](o_e,function(){var f$G="umns";var F1o="dr";var t4Q="adjust";var i97="sea";var m2y="aw";var m9p="earch";var n6p=X9r;n6p+=f$G;var p$9=l4$;p$9+=m9p;if(dt[p$9]()){var f4x=F1o;f4x+=m2y;var T_7=i97;T_7+=v0W;T_7+=L8X;dt[T_7](D3I)[f4x]();}dt[n6p][t4Q]();});dt[X1n](N$u,function(){C_G.y2x();_triggerChange($(conf[V9F][s9i]()[H4F]()));});if(conf[A6z]){var M$B=l59;M$B+=I9o;M$B+=v4k;M$B+=P1E;var U63=C_h;U63+=r4H;var M8Y=C_h;M8Y+=O6E;M8Y+=r7lc_.I0t;M8Y+=G2G;conf[M8Y][s9i](dt);conf[U63][e40](M$B,function(e,json,data,action){var B0E="_jumpToFirst";var d3Y='refresh';var H3h=h2t;H3h+=J8U;H3h+=R8u;if(action === A9E){var l2B=q_1;l2B+=r7lc_[616964];l2B+=z5X;l2B+=Q2T;var _loop_1=function(dp){var u3w="elect";var o3W=l4$;C_G.y2x();o3W+=u3w;dt[y5t](function(idx,d){C_G.y2x();return d === dp;})[o3W]();};for(var _i=U3X,_a=json[E15];_i < _a[l2B];_i++){var dp=_a[_i];_loop_1(dp);}}else if(action === X$Q || action === H3h){_this[f3Q](d3Y);}datatable[B0E](conf,_this);});}conf[V9F]=dt;datatable[f5e](conf,conf[M14] || []);return {input:container,side:side};},disable:function(conf){var A71=d6a;A71+=J2$;var A3z=r7lc_[631343];A3z+=m0p;var i4I=c2V;i4I+=l4$;var X1U=X2M;X1U+=r7lc_.I0t;var B0z=M4$;B0z+=D_g;B0z+=O6E;var T29=a7V;T29+=R1v;T29+=q_1;var X0e=W_g;X0e+=h9w;conf[V9F][X0e][T29](B0z);conf[X1U][i4I]()[H4F]()[A3z](A71,X7g);},dt:function(conf){r7lc_.w49();return conf[V9F];},enable:function(conf){var u_S="tainer";var A0u="gle";var g50=T69;g50+=v4k;g50+=F6T;g50+=O5j;var P_A=r7lc_[631343];P_A+=l4$;P_A+=l4$;var O5V=r7lc_[631343];O5V+=e40;O5V+=u_S;var Y$Y=X2M;Y$Y+=r7lc_.I0t;var A5T=R3w;A5T+=r7lc_[616964];A5T+=A0u;var A4T=B_4;A4T+=l4$;var B2C=q7Z;B2C+=u3m;var N93=B7d;N93+=E_j;conf[V9F][T_8][N93](conf[B2C]?A4T:A5T);conf[Y$Y][Y0_]()[O5V]()[P_A](o7C,g50);},get:function(conf){var i9X="parato";var n_g="nsPa";var N79=l4$;N79+=E_j;N79+=i9X;N79+=g$A;var w_h=s3q;w_h+=I7n;w_h+=M5f;var e89=r7lc_.I0t;e89+=B_4;e89+=x1m;e89+=R1v;var u45=b$b;u45+=w7Q;u45+=j1j;u45+=E_j;var b7A=B_4;b7A+=K36;b7A+=n_g;b7A+=v$s;var I5s=Q4Z;I5s+=j1j;I5s+=e3Y;var f8W=r7lc_.A9u;f8W+=M4$;var a0e=X2M;a0e+=r7lc_.I0t;var rows=conf[a0e][y5t]({selected:E6A})[f8W]()[I5s](conf[b7A][u45])[e89]();return conf[M0f] || !conf[w_h]?rows[R6n](conf[N79] || R0a):rows;},set:function(conf,val,localUpdate){var U_7="ionsPa";var Z_S="jumpT";var r8o="esel";var o_U="oF";var k7E=i3B;k7E+=Z_S;k7E+=o_U;k7E+=r1z;var F46=g$A;F46+=B_4;F46+=v9c;var a5E=X2M;a5E+=r7lc_.I0t;var p5O=X2M;p5O+=r8o;p5O+=p$W;var P$e=T8j;P$e+=l4$;var a0q=B_4;a0q+=b2c;a0q+=U_7;a0q+=v$s;var E8A=O6E;E8A+=l4$;E8A+=k9N;E8A+=o6M;var S9c=q7Z;S9c+=u3m;if(conf[S9c] && conf[M0f] && !Array[Z6E](val)){var o7t=H6U;o7t+=O6E;o7t+=r7lc_.I0t;var u$h=l4$;u$h+=v3p;val=typeof val === u$h?val[o7t](conf[M0f]):[];}else if(!Array[E8A](val)){val=[val];}var valueFn=dataGet(conf[a0q][F7A]);conf[V9F][P$e]({selected:E6A})[p5O]();conf[a5E][F46](function(idx,data,node){return val[z2k](valueFn(data)) !== -F9J;})[T_8]();datatable[k7E](conf,this);if(!localUpdate){var Q$D=r7lc_.I0t;Q$D+=U6p;Q$D+=v4k;Q$D+=E_j;_triggerChange($(conf[V9F][Q$D]()[H4F]()));}},tableClass:D3I,update:function(conf,options,append){var Q72="containe";var C5A=Q72;C5A+=g$A;datatable[f5e](conf,options,append);var lastSet=conf[w__];if(lastSet !== undefined){datatable[V93](conf,lastSet,E6A);}_triggerChange($(conf[V9F][s9i]()[C5A]()));}});var defaults={className:D3I,compare:v5D,data:D3I,def:D3I,entityDecode:E6A,fieldInfo:D3I,getFormatter:v5D,id:D3I,label:D3I,labelInfo:D3I,message:D3I,multiEditable:E6A,name:v5D,nullDefault:B4$,setFormatter:v5D,submit:E6A,type:L3K};var DataTable$2=$[T5x][t8p];var Field=(function(){var D_C="update";var E0y="_mul";var M$F="oty";var j9B="protot";var L4u="toty";var Q2r="multiEditable";var Z0P="totyp";var R9A="ault";var v37="multiValues";var r43="multiValue";var W6R="_typ";var W2j="submittable";var V4B="nullD";var c6K="slideUp";var i4K="ototype";var X4D="ainer";var W5d="multiIds";var j8L="compare";var R_i="labelInfo";var k01="proto";var x6o="class";var C6y="totype";var F9h="tiIds";var U7T="heck";var n1P="ena";var R7H="isMultiValue";var M6w="sg";var f4d="internalI18n";var u5_='input, select, textarea';var f6I="_typeFn";var M$x="inputControl";var B2R="input";var Q5i="Mul";var x81="multiGet";var l5N="host";var h30="eF";var R$Y="ValueC";var f6A="_ms";var q6_="otot";var A6S="iInfoShown";var j8E="Erro";var A10="_format";var R77="Info";var X7L="matt";var z9s="Restore";var m83="ot";var E4_="_errorNode";var v6q="_t";var x6Q="ditab";var n_J="conta";var b$A="tiVal";var Q0w="prot";var N3y="ms";var v1h="rototype";var L$v=A4X;L$v+=X7L;L$v+=B2h;L$v+=l4$;var C$y=j8y;C$y+=B_4;C$y+=S3h;C$y+=U5U;var j7m=E0y;j7m+=K5f;j7m+=R$Y;j7m+=U7T;var w$v=Q0w;w$v+=M$F;w$v+=t$M;var q9V=f6A;q9V+=z5X;var B_U=f1A;B_U+=t$M;var H08=A6N;H08+=A6S;var O_R=D_g;O_R+=g$A;O_R+=q6_;O_R+=q5i;var k7U=v9q;k7U+=x6Q;k7U+=q_1;var r1Y=j8y;r1Y+=i4K;var G9l=D_g;G9l+=Q8O;G9l+=C6y;var Z3m=b$b;Z3m+=M4$;Z3m+=v4k;var I73=Z_p;I73+=r7lc_.I0t;var u1m=j8y;u1m+=m83;u1m+=B_4;u1m+=U5U;var q5z=V4B;q5z+=Q9l;q5z+=R9A;var e3E=t4y;e3E+=E_j;var K6k=b5e;K6k+=S3h;K6k+=U5U;var M5U=k01;M5U+=r7lc_.I0t;M5U+=R1v;M5U+=t$M;var w3g=q7Z;w3g+=K5f;w3g+=z9s;var G1i=j9B;G1i+=R1v;G1i+=D_g;G1i+=E_j;var C19=b5e;C19+=Z0P;C19+=E_j;var x$e=J8U;x$e+=E_j;x$e+=m0p;x$e+=b0k;var V6i=D_g;V6i+=v1h;var Z28=z5X;Z28+=s7X;var r3p=b5e;r3p+=L4u;r3p+=t$M;var Q_D=r7lc_.q78;Q_D+=F6T;Q_D+=j1j;Q_D+=l4$;var Y0Q=O6E;Y0Q+=r7lc_[616964];Y0Q+=j8E;Y0Q+=g$A;var t05=r1M;t05+=Q5i;t05+=b$A;t05+=x5w;var E4B=b5e;E4B+=S3h;E4B+=r7lc_.I0t;E4B+=q5i;var H6J=g_V;H6J+=R77;var y1T=k01;y1T+=U5U;var O2D=n1P;O2D+=d7M;var S85=r7h;S85+=V88;S85+=E_j;var J9P=j9B;J9P+=q5i;var W0c=g_x;W0c+=r7lc_.q78;var Z3x=b5e;Z3x+=S3h;Z3x+=U5U;function Field(options,classes,host){var d$X="reat";var J9D="bel";var j6i="Error adding field - unknown";var I1p="ut-";var i$0='input-control';var o7Z="typePrefix";var u4_="afeId";var N53='" for="';var S05="<div data-dte-e=\"multi-value\"";var m5_="multiReturn";var l9A="namePr";var C0J="ut\" clas";var E72=" field type ";var o3k="<span data-dte-e=\"multi-info\" class=";var z1l="<div data-dte-e=\"inp";var J55="ntrol\" class=\"";var v1a="restore";var O7G="</di";var B3f="<div data-dte-e=\"input-co";var h0K="fieldInf";var W6z="d-p";var b1E='msg-label';var N$s="s=\"";var d$a="</lab";var L3j="g-mu";var P3H="multiI";var i4A="valTo";var O3I='<div data-dte-e="msg-error" class="';var e4L="_ty";var D8e="ultiRestore";var l1l="msg";var s_j="sg-info";var N_A="fieldTyp";var H8C="-inf";var m7p='<div data-dte-e="msg-multi" class="';var K1o="prepe";var l07="sg-m";var r0T='msg-message';var z7u='<label data-dte-e="label" class="';var K9w='<div data-dte-e="msg-info" class="';var L5U="yp";var x10="ulti-value";var C5J="efix";var z67="sg-e";var l8l='<div data-dte-e="msg-label" class="';var o7D="control";var r2z="className";var x2_='label';var s54="E_Field_";var D2h='<div data-dte-e="field-processing" class="';var w$S='msg-error';var Z59='<div data-dte-e="msg-message" class="';var A6K=E_j;A6K+=M4$;A6K+=D5x;var C30=r7lc_[631343];C30+=v4k;C30+=B6q;C30+=O5j;var Q_I=X2M;Q_I+=B_4;Q_I+=J8U;var K8A=r7lc_[631343];K8A+=r9T;K8A+=r7lc_[631343];K8A+=O5j;var n4f=X2M;n4f+=B_4;n4f+=J8U;var E5T=r7lc_.q78;E5T+=s7Z;E5T+=W6z;E5T+=B_s;var e_H=N3y;e_H+=L3j;e_H+=v4k;e_H+=K5f;var l7L=J8U;l7L+=x10;var V5p=M4$;V5p+=Z30;V5p+=r7lc_[616964];V5p+=X2M;var j2H=k0f;j2H+=D_g;j2H+=I1p;j2H+=o7D;var x2P=J8U;x2P+=l07;x2P+=m5B;x2P+=b0k;var e7T=l1l;e7T+=H8C;e7T+=B_4;var S_f=J8U;S_f+=z67;S_f+=t$z;S_f+=g$A;var M$J=l4$;M$J+=z8c;var B3Z=r7lc_[631343];B3Z+=d$X;B3Z+=E_j;var x78=e4L;x78+=D_g;x78+=E_j;x78+=V05;var R0v=O7G;R0v+=b$b;R0v+=j87;var k9E=h0K;k9E+=B_4;var q04=J8U;q04+=s_j;var y5E=y7x;y5E+=X2M;y5E+=k9f;var k6P=q$p;k6P+=X2M;k6P+=O6E;k6P+=w5K;var T6z=K9b;T6z+=K44;T6z+=j87;var k0O=J8U;k0O+=D8e;var Y3U=O6E;Y3U+=r7lc_[616964];Y3U+=r7lc_.q78;Y3U+=B_4;var r6A=X2D;r6A+=j87;var Q4q=P3H;Q4q+=j2e;var R61=o3k;R61+=X2D;var Q9x=X2D;Q9x+=j87;var V4U=S05;V4U+=B0W;var r6z=n3B;r6z+=y7x;r6z+=q01;var z$e=B3f;z$e+=J55;var E22=X2D;E22+=j87;var Z2W=O6E;Z2W+=r7lc_[616964];Z2W+=v1q;Z2W+=r7lc_.I0t;var W9W=z1l;W9W+=C0J;W9W+=N$s;var e9F=d$a;e9F+=F6Q;e9F+=j87;var O_d=O7G;O_d+=b$b;O_d+=j87;var t_b=X2D;t_b+=j87;var V7_=V7l;V7_+=J9D;var g5W=X2D;g5W+=j87;var h7O=O6E;h7O+=X2M;var z0i=l4$;z0i+=u4_;var H00=v4k;H00+=U6p;H00+=F6Q;var m0B=X2D;m0B+=j87;var T1v=r7lc_[616964];T1v+=B0u;T1v+=E_j;var B$G=l9A;B$G+=C5J;var w_v=N5Z;w_v+=H19;w_v+=t$M;w_v+=g$A;var q9u=E2Z;q9u+=m$O;var C3c=i4A;C3c+=v0G;C3c+=h1q;var o2d=r7lc_.I0t;o2d+=q5i;var l2w=N_A;l2w+=s4U;var s_x=A91;s_x+=X2M;var M8O=s3q;M8O+=P3D;M8O+=O6E;var that=this;var multiI18n=host[f4d]()[M8O];var opts=$[s_x](E6A,{},Field[r2L],options);if(!Editor[l2w][opts[o2d]]){var o1K=r7lc_.I0t;o1K+=L5U;o1K+=E_j;var z9F=j6i;z9F+=E72;throw new Error(z9F + opts[o1K]);}this[l4$]={classes:classes,host:host,multiIds:[],multiValue:B4$,multiValues:{},name:opts[P8N],opts:opts,processing:B4$,type:Editor[J2K][opts[U5U]]};if(!opts[e4a]){var x3f=v9o;x3f+=E_j;var C1c=l1n;C1c+=s54;opts[e4a]=C1c + opts[x3f];}if(opts[E15] === D3I){var e4k=X2M;e4k+=M4$;e4k+=r7lc_.I0t;e4k+=M4$;opts[e4k]=opts[P8N];}this[k0K]=function(d){var m08='editor';return dataGet(opts[E15])(d,m08);};this[C3c]=dataSet(opts[E15]);var template=$(q9u + classes[w_v] + O3x + classes[o7Z] + opts[U5U] + O3x + classes[B$G] + opts[T1v] + O3x + opts[r2z] + m0B + z7u + classes[H00] + N53 + Editor[z0i](opts[h7O]) + g5W + opts[V7_] + l8l + classes[b1E] + t_b + opts[R_i] + O_d + e9F + W9W + classes[Z2W] + E22 + z$e + classes[M$x] + r6z + V4U + classes[r43] + Q9x + multiI18n[D$Q] + R61 + classes[Q4q] + r6A + multiI18n[Y3U] + n0A + a$h + m7p + classes[k0O] + T3G + multiI18n[v1a] + T6z + O3I + classes[w$S] + k6P + Z59 + classes[r0T] + T3G + opts[J7h] + y5E + K9w + classes[q04] + T3G + opts[k9E] + R0v + a$h + D2h + classes[c0j] + a$f + a$h);var input=this[x78](B3Z,opts);var side=v5D;if(input && input[M$J]){var D5d=O6E;D5d+=c03;D5d+=F3T;var E8n=l4$;E8n+=O6E;E8n+=X2M;E8n+=E_j;side=input[E8n];input=input[D5d];}if(input !== v5D){var s22=K1o;s22+=r7lc_[616964];s22+=X2M;el(i$0,template)[s22](input);}else {var l7P=r7lc_[616964];l7P+=B_4;l7P+=r7lc_[616964];l7P+=E_j;var D8o=A9N;D8o+=u05;D8o+=V7l;D8o+=R1v;template[Q$n](D8o,l7P);}this[H$1]={container:template,fieldError:el(S_f,template),fieldInfo:el(e7T,template),fieldMessage:el(x2P,template),inputControl:el(j2H,template),label:el(x2_,template)[V5p](side),labelInfo:el(b1E,template),multi:el(l7L,template),multiInfo:el(V8u,template),multiReturn:el(e_H,template),processing:el(E5T,template)};this[n4f][M8p][e40](K8A,function(){var j41="focu";r7lc_.w49();var L03="hasC";var k7O=X2M;k7O+=r1M;k7O+=u6f;var s4r=L03;s4r+=v4k;s4r+=k$S;if(that[l4$][k6u][Q2r] && !template[s4r](classes[k7O]) && opts[U5U] !== D69){var D9Q=j41;D9Q+=l4$;that[w81](D3I);that[D9Q]();}});this[Q_I][m5_][e40](C30,function(){var c6O="sto";var X3O=A6N;X3O+=g3i;r7lc_.y2x();X3O+=c6O;X3O+=h2t;that[X3O]();});$[A6K](this[l4$][U5U],function(name,fn){r7lc_.y2x();var I0H=t_t;I0H+=r7lc_[631343];I0H+=r7lc_[399342];if(typeof fn === I0H && that[name] === undefined){that[name]=function(){var j_0="peFn";r7lc_.w49();var w$s=v6q;w$s+=R1v;w$s+=j_0;var B9p=K0E;B9p+=v4k;var args=Array[C36][p6F][B9p](arguments);args[I04](name);var ret=that[w$s][m51](that,args);return ret === undefined?that:ret;};}});}Field[Z3x][W0c]=function(set){var T$L='default';var f7i="ult";var v$K="fa";var Z5k=X2M;Z5k+=Q9l;var opts=this[l4$][k6u];if(set === undefined){var N$1=r7lc_[269035];N$1+=s18;N$1+=K5f;N$1+=e40;var c9h=X2M;c9h+=E_j;c9h+=r7lc_.q78;var d5K=X2M;d5K+=E_j;d5K+=v$K;d5K+=f7i;var def=opts[d5K] !== undefined?opts[T$L]:opts[c9h];return typeof def === N$1?def():def;}opts[Z5k]=set;return this;};Field[J9P][S85]=function(){var Y$s=b3j;Y$s+=l4$;var d4y=r7lc_[631343];d4y+=e40;r7lc_.w49();d4y+=r7lc_.I0t;d4y+=X4D;this[H$1][d4y][l7F](this[l4$][Y$s][t1N]);this[f6I](Z07);return this;};Field[C36][m1n]=function(){var X_G="aren";var E7P=r7lc_[616964];E7P+=B_4;E7P+=r7lc_[616964];E7P+=E_j;var z9Y=X2M;z9Y+=m_d;z9Y+=v4k;z9Y+=v7E;var q$T=D_g;q$T+=X_G;q$T+=B8k;var X6A=r7lc_[631343];X6A+=B_4;X6A+=Y$n;X6A+=X4D;var container=this[H$1][X6A];return container[q$T](N$f)[b_m] && container[Q$n](z9Y) !== E7P?E6A:B4$;};Field[C36][u_V]=function(toggle){r7lc_.w49();var g9p='enable';var Y5o=A7E;Y5o+=l4$;Y5o+=l4$;Y5o+=s4U;if(toggle === void U3X){toggle=E6A;}if(toggle === B4$){var P4C=d6a;P4C+=c3v;return this[P4C]();}this[H$1][H4F][F15](this[l4$][Y5o][t1N]);this[f6I](g9p);return this;};Field[C36][O2D]=function(){var r2J="ine";var t3d="sCla";var u95=X2M;u95+=O6E;u95+=l4$;u95+=u6f;var g7n=x6o;g7n+=s4U;var F03=g7t;F03+=t3d;F03+=m0p;var u1d=n_J;u1d+=r2J;u1d+=g$A;return this[H$1][u1d][F03](this[l4$][g7n][u95]) === B4$;};Field[C36][S_q]=function(msg,fn){var d7p="rorMessage";var C1o="removeCl";var n6Y="dErr";var Z6n="addCl";var I4u="_msg";var e1L=r7lc_.q78;e1L+=s7Z;e1L+=n6Y;r7lc_.w49();e1L+=G2G;var U9R=X2M;U9R+=B_4;U9R+=J8U;var V8S=B2h;V8S+=d7p;var T86=x6o;T86+=s4U;var classes=this[l4$][T86];if(msg){var G28=Z6n;G28+=k$S;var r6E=n_J;r6E+=O6E;r6E+=r7lc_[616964];r6E+=B2h;var l56=X2M;l56+=L3D;this[l56][r6E][G28](classes[S_q]);}else {var Q4W=M1o;Q4W+=G2G;var R85=C1o;R85+=k$S;var J_L=X2M;J_L+=L3D;this[J_L][H4F][R85](classes[Q4W]);}this[f6I](V8S,msg);return this[I4u](this[U9R][e1L],msg,fn);};Field[y1T][H6J]=function(msg){var A9t="fieldInfo";var j1w=i3B;j1w+=N3y;j1w+=z5X;return this[j1w](this[H$1][A9t],msg);};Field[E4B][t05]=function(){var s5A="ltiId";var f92=v4k;f92+=a8w;f92+=H76;var u0Y=s3q;u0Y+=s5A;u0Y+=l4$;return this[l4$][r43] && this[l4$][u0Y][f92] !== F9J;};Field[C36][Y0Q]=function(){var I3L="has";var T9U=M1o;T9U+=B_4;T9U+=g$A;var E4$=A7E;E4$+=l4$;E4$+=B5z;var I3z=I3L;I3z+=r2b;r7lc_.y2x();var T6h=H$2;T6h+=J8U;return this[T6h][H4F][I3z](this[l4$][E4$][T9U]);};Field[C36][B2R]=function(){var B1_=H$2;B1_+=J8U;var t2E=F2c;t2E+=F3T;var f3e=W6R;f3e+=h30;f3e+=r7lc_[616964];r7lc_.w49();var k1M=r7lc_.I0t;k1M+=R1v;k1M+=D_g;k1M+=E_j;return this[l4$][k1M][B2R]?this[f3e](t2E):$(u5_,this[B1_][H4F]);};Field[C36][Q_D]=function(){var v0P="eFn";var Z$A=r7lc_.I0t;Z$A+=R1v;Z$A+=D_g;Z$A+=E_j;if(this[l4$][Z$A][o6n]){var Q76=W6R;Q76+=v0P;this[Q76](K5m);}else {var s$0=X2M;s$0+=B_4;s$0+=J8U;$(u5_,this[s$0][H4F])[o6n]();}r7lc_.w49();return this;};Field[r3p][Z28]=function(){var a5O="getFormatter";var v6D=z5X;v6D+=E_j;v6D+=r7lc_.I0t;var p8g=i3B;p8g+=g7p;p8g+=h30;p8g+=r7lc_[616964];if(this[R7H]()){return undefined;}return this[A10](this[p8g](v6D),this[l4$][k6u][a5O]);};Field[C36][k5O]=function(animate){var V2v="ideU";var p_I="contain";var X74=r7lc_.q78;X74+=r7lc_[616964];var I6S=X2M;I6S+=O6E;I6S+=H6U;I6S+=v7E;var X_p=p_I;X_p+=B2h;var el=this[H$1][X_p];if(animate === undefined){animate=E6A;}if(this[l4$][l5N][I6S]() && animate && $[X74][c6K]){var e6$=l4$;e6$+=v4k;e6$+=V2v;e6$+=D_g;el[e6$]();}else {var U9K=r7lc_[631343];U9K+=l4$;U9K+=l4$;el[U9K](o7C,X7g);}return this;};Field[V6i][o38]=function(str){r7lc_.y2x();var u4q="labelI";var z1B=M4$;z1B+=E3D;z1B+=E_j;z1B+=k88;var U8E=g_x;U8E+=h1q;U8E+=r7lc_[631343];U8E+=L8X;var z7p=u4q;z7p+=r7lc_[616964];z7p+=r7lc_.q78;z7p+=B_4;var G0$=v4k;G0$+=M4$;G0$+=T69;G0$+=F6Q;var o$I=X2M;o$I+=L3D;var label=this[o$I][G0$];var labelInfo=this[H$1][z7p][U8E]();if(str === undefined){var e3n=L8X;e3n+=r7lc_.I0t;e3n+=J8U;e3n+=v4k;return label[e3n]();}label[I52](str);label[z1B](labelInfo);return this;};Field[C36][R_i]=function(msg){var p_g=i3B;p_g+=J8U;p_g+=M6w;return this[p_g](this[H$1][R_i],msg);};Field[C36][x$e]=function(msg,fn){var E65="ieldMes";var c2z=r7lc_.q78;c2z+=E65;c2z+=s6n;var L99=X2M;L99+=B_4;L99+=J8U;var V_D=i3B;V_D+=J8U;V_D+=M6w;return this[V_D](this[L99][c2z],msg,fn);};Field[C19][x81]=function(id){var M2I="iIds";var O_a="isMultiVal";var T4L=O_a;T4L+=j1j;T4L+=E_j;var o8S=A6N;r7lc_.w49();o8S+=M2I;var value;var multiValues=this[l4$][v37];var multiIds=this[l4$][o8S];var isMultiValue=this[T4L]();if(id === undefined){var G9s=b$b;G9s+=w7Q;var fieldVal=this[G9s]();value={};for(var _i=U3X,multiIds_1=multiIds;_i < multiIds_1[b_m];_i++){var multiId=multiIds_1[_i];value[multiId]=isMultiValue?multiValues[multiId]:fieldVal;}}else if(isMultiValue){value=multiValues[id];}else {value=this[w81]();}return value;};Field[G1i][w3g]=function(){var Q1V="iValueCheck";var y94=G9c;y94+=Q1V;this[l4$][r43]=E6A;this[y94]();};Field[C36][D1h]=function(id,val,recalc){var r3M="ues";var z90="Che";var f3K="_mu";var o59="lainObject";var V$3="isP";var M$G="tiValu";var z6p="ltiVal";var L4h="ltiValue";var l5T=q7Z;l5T+=M$G;l5T+=E_j;var w5h=V$3;w5h+=o59;var F$W=J8U;F$W+=j1j;F$W+=z6p;F$W+=r3M;if(recalc === void U3X){recalc=E6A;}var that=this;var multiValues=this[l4$][F$W];var multiIds=this[l4$][W5d];if(val === undefined){val=id;id=undefined;}var set=function(idSrc,valIn){var w7w="Arr";var I0k="setFormatter";var W5S=M8G;W5S+=g$A;W5S+=x0m;W5S+=r7lc_.I0t;var J6G=k0f;r7lc_.w49();J6G+=w7w;J6G+=v7E;if($[J6G](idSrc,multiIds) === -F9J){var G2s=D_g;G2s+=j1j;G2s+=l4$;G2s+=L8X;multiIds[G2s](idSrc);}multiValues[idSrc]=that[W5S](valIn,that[l4$][k6u][I0k]);};if($[w5h](val) && id === undefined){$[n8S](val,function(idSrc,innerVal){r7lc_.w49();set(idSrc,innerVal);});}else if(id === undefined){var G9Z=E_j;G9Z+=e8A;G9Z+=L8X;$[G9Z](multiIds,function(i,idSrc){r7lc_.y2x();set(idSrc,val);});}else {set(id,val);}this[l4$][l5T]=E6A;if(recalc){var O4L=f3K;O4L+=L4h;O4L+=z90;O4L+=e3Y;this[O4L]();}return this;};Field[M5U][P8N]=function(){r7lc_.w49();return this[l4$][k6u][P8N];};Field[K6k][e3E]=function(){var w8m="ntainer";r7lc_.y2x();var b5J=g9q;b5J+=w8m;return this[H$1][b5J][U3X];};Field[C36][q5z]=function(){var c7o="nullDefault";r7lc_.w49();var D9F=B_4;D9F+=b2c;D9F+=l4$;return this[l4$][D9F][c7o];};Field[u1m][c0j]=function(set){var R$t="internalE";var J_9="hos";var c91="ocessing";var k0m=R$t;r7lc_.w49();k0m+=b$b;k0m+=a8w;k0m+=r7lc_.I0t;var D0q=J_9;D0q+=r7lc_.I0t;var m92=j8y;m92+=F6T;m92+=s4U;m92+=D2u;var p9V=y3Y;p9V+=E_j;var P65=T69;P65+=j5F;P65+=e3Y;var O1t=A9N;O1t+=u05;O1t+=v4k;O1t+=v7E;var x2I=j8y;x2I+=c91;if(set === undefined){return this[l4$][c0j];}this[H$1][x2I][Q$n](O1t,set?P65:p9V);this[l4$][m92]=set;this[l4$][D0q][k0m](p2_,[set]);return this;};Field[C36][I73]=function(val,multiCheck){var e9A="_multiValueCheck";var g9r="tityDecode";var D0t="tFo";var W$M="rmatter";var z34='set';var E0x=a8w;E0x+=g9r;if(multiCheck === void U3X){multiCheck=E6A;}var decodeFn=function(d){var b_B='\'';var m1q="replac";var z$d="repla";var r7d='"';var y24='£';var I7e='\n';var i78="repl";var o14=m1q;o14+=E_j;var l4N=h2t;l4N+=Q4Z;l4N+=d9J;var o3j=i78;o3j+=d9J;var y_0=z$d;y_0+=K0$;return typeof d !== X0M?d:d[y_0](/&gt;/g,V_Z)[o3j](/&lt;/g,e4F)[q6o](/&amp;/g,d0S)[l4N](/&quot;/g,r7d)[o14](/&#163;/g,y24)[q6o](/&#0?39;/g,b_B)[q6o](/&#0?10;/g,I7e);};this[l4$][r43]=B4$;var decode=this[l4$][k6u][E0x];r7lc_.y2x();if(decode === undefined || decode === E6A){var P0X=s08;P0X+=o6M;if(Array[P0X](val)){var y7N=v4k;y7N+=a8P;y7N+=Q2T;for(var i=U3X,ien=val[y7N];i < ien;i++){val[i]=decodeFn(val[i]);}}else {val=decodeFn(val);}}if(multiCheck === E6A){var G9C=Z_p;G9C+=D0t;G9C+=W$M;var D9W=A6W;D9W+=l4$;val=this[A10](val,this[l4$][D9W][G9C]);this[f6I](z34,val);this[e9A]();}else {var e6d=v6q;e6d+=q5i;e6d+=A1W;e6d+=r7lc_[616964];this[e6d](z34,val);}return this;};Field[C36][N8w]=function(animate,toggle){var o96="ner";var O3S="ontai";var l2y="slideDown";var L5W="slid";var r6U="eDown";var m07=L5W;m07+=r6U;var Z$2=L8X;Z$2+=B_4;r7lc_.w49();Z$2+=a7V;var C6$=r7lc_[631343];C6$+=O3S;C6$+=o96;if(animate === void U3X){animate=E6A;}if(toggle === void U3X){toggle=E6A;}if(toggle === B4$){var l9p=L8X;l9p+=O6E;l9p+=X2M;l9p+=E_j;return this[l9p](animate);}var el=this[H$1][C6$];if(this[l4$][Z$2][u_G]() && animate && $[T5x][m07]){el[l2y]();}else {var d_M=r7lc_[631343];d_M+=l4$;d_M+=l4$;el[d_M](o7C,D3I);;}return this;};Field[C36][D_C]=function(options,append){var p1N="upda";var C9I='update';var a84=p1N;a84+=H_8;r7lc_.w49();if(append === void U3X){append=B4$;}if(this[l4$][U5U][a84]){this[f6I](C9I,options,append);}return this;};Field[C36][Z3m]=function(val){r7lc_.y2x();return val === undefined?this[m8j]():this[V93](val);};Field[G9l][j8L]=function(value,original){var s9q="par";var O_H=p9C;O_H+=s9q;O_H+=E_j;var compare=this[l4$][k6u][O_H] || deepCompare;return compare(value,original);};Field[r1Y][b_d]=function(){r7lc_.y2x();return this[l4$][k6u][E15];};Field[C36][q0S]=function(){var l9h="typeF";var j69="tro";var Z9N="des";var U2r="contai";var e0W=Z9N;e0W+=j69;e0W+=R1v;var u$4=i3B;u$4+=l9h;u$4+=r7lc_[616964];var N6e=b3W;N6e+=R8u;var q_W=U2r;q_W+=r7lc_[616964];q_W+=B2h;r7lc_.w49();this[H$1][q_W][N6e]();this[u$4](e0W);return this;};Field[C36][k7U]=function(){var S21=B_4;S21+=b2c;S21+=l4$;return this[l4$][S21][Q2r];};Field[O_R][W5d]=function(){var r2c=s3q;r2c+=v4k;r2c+=F9h;return this[l4$][r2c];};Field[C36][H08]=function(show){var X1u="multiInfo";this[H$1][X1u][Q$n]({display:show?V9L:X7g});};Field[B_U][k$m]=function(){var u_i="Values";var Z3Q=M8p;Z3Q+=u_i;this[l4$][W5d]=[];r7lc_.w49();this[l4$][Z3Q]={};};Field[C36][W2j]=function(){var O8D=l59;r7lc_.y2x();O8D+=D0g;return this[l4$][k6u][O8D];};Field[C36][q9V]=function(el,msg,fn){var B7j="ncti";var U9I="slideDo";var k5L="htm";var F1B="visibl";var l3t=P7R;l3t+=F1B;l3t+=E_j;var P5y=D8t;P5y+=g$A;P5y+=q0d;var g_2=r7lc_[269035];g_2+=B7j;g_2+=e40;if(msg === undefined){var B3l=k5L;B3l+=v4k;return el[B3l]();}if(typeof msg === g_2){var t4n=r7lc_.I0t;t4n+=U6p;t4n+=v4k;t4n+=E_j;var g7W=o32;g7W+=D_g;g7W+=O6E;var editor=this[l4$][l5N];msg=msg(editor,new DataTable$2[g7W](editor[U_D]()[t4n]));}if(el[P5y]()[r1M](l3t) && $[T5x][T1N]){var u9D=L8X;u9D+=r7lc_.I0t;u9D+=e_Z;el[u9D](msg);if(msg){var r3q=U9I;r3q+=x0D;el[r3q](fn);;}else {el[c6K](fn);}}else {var f6i=r7lc_[616964];f6i+=B_4;f6i+=r7lc_[616964];f6i+=E_j;var l2H=u3g;l2H+=l4$;el[I52](msg || D3I)[l2H](o7C,msg?V9L:f6i);if(fn){fn();}}return this;};Field[w$v][j7m]=function(){var w_V="oggleCl";var e$3="multiNoEdit";var N7f="eturn";var H78="ock";var b$g="info";var V01="multiVa";var d$6="ost";var L63="noMult";var s2L="tContr";var Q3J="multiR";var z__=r7lc_.I0t;z__+=w_V;z__+=k$S;var D3q=J8U;D3q+=j1j;D3q+=v4k;D3q+=K5f;var O4a=L63;O4a+=O6E;var V34=L8X;V34+=r7lc_.I0t;V34+=e_Z;var y3d=M8p;y3d+=U5b;y3d+=H1k;var q_f=H$2;q_f+=J8U;var B82=L8X;B82+=d$6;var R5J=r7lc_[616964];R5J+=B_4;R5J+=r7lc_[616964];R5J+=E_j;var b1i=T69;b1i+=j5F;b1i+=e3Y;var d0l=q_1;d0l+=w6p;d0l+=Q2T;var k7j=r7lc_[631343];k7j+=l4$;k7j+=l4$;var P_E=Q3J;P_E+=N7f;var v_S=X2M;v_S+=B_4;v_S+=J8U;var j2D=V01;j2D+=v4k;j2D+=x5w;var f$Z=q7Z;f$Z+=F9h;var last;var ids=this[l4$][f$Z];var values=this[l4$][v37];var isMultiValue=this[l4$][j2D];var isMultiEditable=this[l4$][k6u][Q2r];var val;var different=B4$;if(ids){for(var i=U3X;i < ids[b_m];i++){val=values[ids[i]];if(i > U3X && !deepCompare(val,last)){different=E6A;break;}last=val;}}if(different && isMultiValue || !isMultiEditable && this[R7H]()){var M9v=v7d;M9v+=e3Y;var m0v=u3g;m0v+=l4$;var M42=J8U;M42+=j1j;M42+=v4k;M42+=K5f;this[H$1][M$x][Q$n]({display:X7g});this[H$1][M42][m0v]({display:M9v});}else {var B0j=u3g;B0j+=l4$;var G9t=X2M;G9t+=B_4;G9t+=J8U;var x5$=V88;x5$+=H78;var X_7=F2c;X_7+=j1j;X_7+=s2L;X_7+=Z7b;this[H$1][X_7][Q$n]({display:x5$});this[G9t][M8p][B0j]({display:X7g});if(isMultiValue && !different){this[V93](last,B4$);}}this[v_S][P_E][k7j]({display:ids && ids[d0l] > F9J && different && !isMultiValue?b1i:R5J});var i18n=this[l4$][B82][f4d]()[M8p];this[q_f][y3d][V34](isMultiEditable?i18n[b$g]:i18n[O4a]);this[H$1][D3q][z__](this[l4$][x6a][e$3],!isMultiEditable);this[l4$][l5N][W8Q]();return E6A;};Field[C36][f6I]=function(name){var M7k="nshif";var R0W=j1j;R0W+=M7k;R0W+=r7lc_.I0t;var args=[];for(var _i=F9J;_i < arguments[b_m];_i++){args[_i - F9J]=arguments[_i];}args[R0W](this[l4$][k6u]);var fn=this[l4$][U5U][name];if(fn){var M4_=L8X;M4_+=B_4;M4_+=l4$;M4_+=r7lc_.I0t;return fn[m51](this[l4$][M4_],args);}};Field[C$y][E4_]=function(){var B3w="fieldError";var j3a=H$2;j3a+=J8U;return this[j3a][B3w];};Field[C36][A10]=function(val,formatter){var T5p="shift";r7lc_.y2x();var w68="formatters";if(formatter){var t7U=g7g;t7U+=I_5;t7U+=v7E;if(Array[t7U](formatter)){var A2r=l4$;A2r+=r9T;A2r+=K0$;var args=formatter[A2r]();var name_1=args[T5p]();formatter=Field[w68][name_1][m51](this,args);}return formatter[e27](this[l4$][l5N],val,this);}return val;};Field[r2L]=defaults;Field[L$v]={};return Field;})();var button={action:v5D,className:v5D,tabIndex:U3X,text:v5D};var displayController={close:function(){},init:function(){},node:function(){},open:function(){}};var DataTable$1=$[R6D][R9W];var apiRegister=DataTable$1[s1J][y7H];function _getInst(api){var N6$="_editor";var G1L="oIn";var O1h="context";var M$C=G1L;M$C+=O6E;M$C+=r7lc_.I0t;var ctx=api[O1h][U3X];return ctx[M$C][g0f] || ctx[N6$];}function _setBasic(inst,opts,type,plural){var r9H=/%d/;var w6w="nfirm";if(!opts){opts={};}if(opts[Y0_] === undefined){opts[Y0_]=j_D;}if(opts[D$Q] === undefined){var g3j=K5f;g3j+=C6Z;g3j+=E_j;opts[D$Q]=inst[N9v][type][g3j];}if(opts[J7h] === undefined){var M1i=b3W;M1i+=R8u;if(type === M1i){var D0C=h2t;D0C+=Q4Z;D0C+=d9J;var b1k=r7lc_[631343];b1k+=B_4;b1k+=w6w;var confirm_1=inst[N9v][type][b1k];opts[J7h]=plural !== F9J?confirm_1[i3B][D0C](r9H,plural):confirm_1[w_e];}else {var w_i=F4j;w_i+=l4$;w_i+=l4$;w_i+=b0k;opts[w_i]=D3I;}}return opts;}apiRegister(N1S,function(){return _getInst(this);});apiRegister(s8v,function(opts){var c4v=l2f;c4v+=H_8;r7lc_.w49();var inst=_getInst(this);inst[n3q](_setBasic(inst,opts,c4v));return this;});apiRegister(B3$,function(opts){r7lc_.w49();var inst=_getInst(this);inst[v0L](this[U3X][U3X],_setBasic(inst,opts,X$Q));return this;});apiRegister(Y_w,function(opts){var U3A=E_j;U3A+=X2M;U3A+=O6E;U3A+=r7lc_.I0t;var v8g=b2D;v8g+=r7lc_.I0t;var inst=_getInst(this);inst[v8g](this[U3X],_setBasic(inst,opts,U3A));return this;});apiRegister(t1d,function(opts){r7lc_.y2x();var z5K=h2t;z5K+=J8U;z5K+=R8u;var inst=_getInst(this);inst[z5K](this[U3X][U3X],_setBasic(inst,opts,c12,F9J));return this;});apiRegister(T_p,function(opts){var m8t=q_1;m8t+=w6p;m8t+=Q2T;var F7V=h2t;F7V+=D7o;F7V+=b$b;F7V+=E_j;var inst=_getInst(this);inst[u3q](this[U3X],_setBasic(inst,opts,F7V,this[U3X][m8t]));r7lc_.y2x();return this;});apiRegister(A2R,function(type,opts){var i2S=C$e;i2S+=p$W;if(!type){type=n0l;}else if($[i2S](type)){opts=type;type=n0l;}_getInst(this)[type](this[U3X][U3X],opts);return this;});apiRegister(N0e,function(opts){_getInst(this)[v1X](this[U3X],opts);return this;});apiRegister(Q69,file);apiRegister(O$0,files);$(document)[e40](z7h,function(e,ctx,json){var b7V='dt';var D$1=P8N;D$1+=u05;D$1+=e8A;D$1+=E_j;if(e[D$1] !== b7V){return;}if(json && json[i9z]){var n5J=k$c;n5J+=l4$;$[n8S](json[n5J],function(name,filesIn){var I_C=j7C;I_C+=k8D;var t5c=r7lc_.q78;t5c+=L$D;r7lc_.w49();if(!Editor[t5c][name]){var i0U=r7lc_.q78;i0U+=L$D;Editor[i0U][name]={};}$[I_C](Editor[i9z][name],filesIn);});}});var _buttons=$[w5Y][r_z][O6h][S6b];$[u8e](_buttons,{create:{action:function(e,dt,node,config){var F8y="Tit";var Q4O=r7lc_.I0t;Q4O+=O6E;Q4O+=C6Z;Q4O+=E_j;var y9C=r7lc_.q78;y9C+=d3j;y9C+=F8y;y9C+=q_1;var w2u=W6Z;w2u+=M4$;w2u+=z5X;w2u+=E_j;var B9y=U_K;B9y+=r7lc_.S_p;B9y+=r7lc_[616964];var e_8=f0G;e_8+=E_j;e_8+=M4$;e_8+=H_8;var D67=S7d;D67+=s6g;D67+=E_j;D67+=r7lc_[616964];var z1G=B_4;z1G+=r7lc_[616964];z1G+=E_j;var Y7d=b5e;Y7d+=K0$;Y7d+=F88;var that=this;var editor=config[g0f];this[Y7d](E6A);editor[z1G](D67,function(){var G6C="process";var X8L=G6C;X8L+=N9T;that[X8L](B4$);})[e_8]($[b$J]({buttons:config[n9T],message:config[x6I] || editor[B9y][n3q][w2u],nest:E6A,title:config[y9C] || editor[N9v][n3q][Q4O]},config[P2i]));},className:O7Y,editor:v5D,formButtons:{action:function(e){this[L9t]();},text:function(editor){r7lc_.y2x();var W5t=l4$;W5t+=G30;return editor[N9v][n3q][W5t];}},formMessage:v5D,formOptions:{},formTitle:v5D,text:function(dt,node,config){r7lc_.y2x();var e_n='buttons.create';return dt[N9v](e_n,config[g0f][N9v][n3q][c2V]);}},createInline:{action:function(e,dt,node,config){var T$9=O2E;T$9+=s6g;T$9+=r7lc_[399342];T$9+=l4$;config[g0f][C8u](config[P1s],config[T$9]);},className:H6f,editor:v5D,formButtons:{action:function(e){r7lc_.w49();this[L9t]();},text:function(editor){var F_2=f0G;F_2+=s_N;return editor[N9v][F_2][L9t];}},formOptions:{},position:F_N,text:function(dt,node,config){var P3U="s.";var Z4Z=R$N;Z4Z+=r7lc_.I0t;Z4Z+=S3h;Z4Z+=r7lc_[616964];var Y6V=O6E;Y6V+=r7lc_[357471];Y6V+=r7lc_.S_p;Y6V+=r7lc_[616964];var A$g=c2V;A$g+=P3U;r7lc_.y2x();A$g+=n3q;return dt[N9v](A$g,config[g0f][Y6V][n3q][Z4Z]);}},edit:{action:function(e,dt,node,config){var T7Q="inde";var v3h="formOp";var h1d="xe";var W_c="ssi";var I4U="ells";var K1c="mes";var J9f="formMe";var S7h="ormT";var e5m=v3h;e5m+=K5f;e5m+=U9P;var U2k=r7lc_.q78;U2k+=S7h;U2k+=O6E;U2k+=j6F;var K4z=K1c;K4z+=s6n;var Z6s=E_j;Z6s+=X2M;Z6s+=O6E;Z6s+=r7lc_.I0t;var l88=J9f;l88+=l4$;l88+=s6n;var i75=j7C;i75+=k8D;var T3v=E_j;T3v+=X2M;T3v+=O6E;T3v+=r7lc_.I0t;var g1Q=S7d;g1Q+=i9l;g1Q+=D_g;g1Q+=a8w;var e5T=B_4;e5T+=r7lc_[616964];e5T+=E_j;var i36=H4N;i36+=E_j;i36+=W_c;i36+=w6p;var P6C=w$F;P6C+=z5X;P6C+=r7lc_.I0t;P6C+=L8X;var Z46=k0f;Z46+=g_x;Z46+=h1d;Z46+=l4$;var l2T=r7lc_[631343];l2T+=I4U;var o8G=T7Q;o8G+=D34;o8G+=s4U;var z2Y=g$A;z2Y+=B_4;z2Y+=R$a;z2Y+=l4$;var that=this;var editor=config[g0f];var rows=dt[z2Y]({selected:E6A})[o8G]();var columns=dt[q6O]({selected:E6A})[M1m]();var cells=dt[l2T]({selected:E6A})[Z46]();var items=columns[b_m] || cells[P6C]?{cells:cells,columns:columns,rows:rows}:rows;this[i36](E6A);editor[e5T](g1Q,function(){that[c0j](B4$);})[T3v](items,$[i75]({buttons:config[n9T],message:config[l88] || editor[N9v][Z6s][K4z],nest:E6A,title:config[U2k] || editor[N9v][v0L][D$Q]},config[e5m]));},className:N9k,editor:v5D,extend:L7C,formButtons:{action:function(e){this[L9t]();},text:function(editor){var q_C=E_j;q_C+=X2M;q_C+=O6E;q_C+=r7lc_.I0t;var G0Y=s7R;G0Y+=r7lc_[616964];return editor[G0Y][q_C][L9t];}},formMessage:v5D,formOptions:{},formTitle:v5D,text:function(dt,node,config){var R2p='buttons.edit';var f0R=s7R;f0R+=r7lc_[616964];var f$e=C_h;f$e+=c34;f$e+=B_4;f$e+=g$A;return dt[N9v](R2p,config[f$e][f0R][v0L][c2V]);}},remove:{action:function(e,dt,node,config){var O2g="eO";var J51="formTitle";var i5_=K7Z;i5_+=L6h;r7lc_.y2x();var L8k=O6h;L8k+=a8w;L8k+=X2M;var V7Y=j8y;V7Y+=O2g;V7Y+=P6g;var l2C=B_4;l2C+=r7lc_[616964];l2C+=E_j;var t1s=b5e;t1s+=e15;var that=this;var editor=config[g0f];this[t1s](E6A);editor[l2C](V7Y,function(){var H4C="processin";var A62=H4C;A62+=z5X;that[A62](B4$);})[u3q](dt[y5t]({selected:E6A})[M1m](),$[L8k]({buttons:config[n9T],message:config[x6I],nest:E6A,title:config[J51] || editor[N9v][i5_][D$Q]},config[P2i]));},className:U0I,editor:v5D,extend:k5e,formButtons:{action:function(e){var h8U="ubmi";var o67=l4$;o67+=h8U;o67+=r7lc_.I0t;this[o67]();},text:function(editor){var m4m=K7Z;r7lc_.y2x();m4m+=b$b;m4m+=E_j;var q_4=O6E;q_4+=o1i;q_4+=r7lc_[616964];return editor[q_4][m4m][L9t];}},formMessage:function(editor,dt){var x13="lengt";var V86="fir";var B58="confirm";var m90="rm";var Q4E="confi";r7lc_.w49();var Y5R="nfi";var K$O=x13;K$O+=L8X;var l5P=g9q;l5P+=r7lc_[616964];l5P+=V86;l5P+=J8U;var K$q=v4k;K$q+=a8P;K$q+=Q2T;var U7B=r7lc_[631343];U7B+=B_4;U7B+=Y5R;U7B+=m90;var z52=Q4E;z52+=m90;var Z6r=l4$;Z6r+=v3p;var p_A=g$A;p_A+=k$2;var t8U=s7R;t8U+=r7lc_[616964];var rows=dt[y5t]({selected:E6A})[M1m]();var i18n=editor[t8U][p_A];var question=typeof i18n[B58] === Z6r?i18n[z52]:i18n[U7B][rows[b_m]]?i18n[B58][rows[K$q]]:i18n[l5P][i3B];return question[q6o](/%d/g,rows[K$O]);},formOptions:{},formTitle:v5D,limitTo:[g8l],text:function(dt,node,config){r7lc_.y2x();var Y$L="s.remove";var H7n=I7o;H7n+=r7lc_[616964];var H29=g$A;H29+=W1U;H29+=B_4;H29+=L6h;var B2L=v0L;B2L+=G2G;var N48=T69;N48+=K1d;N48+=Y$L;var r$z=U_K;r$z+=r7lc_.S_p;r$z+=r7lc_[616964];return dt[r$z](N48,config[B2L][N9v][H29][H7n]);}}});_buttons[e3U]=$[b$J]({},_buttons[v0L]);_buttons[S1r][V7K]=C2G;_buttons[G39]=$[H6b]({},_buttons[u3q]);_buttons[G39][b$J]=I$7;if(!DataTable || !DataTable[Z8X] || !DataTable[q3E](Y4v)){throw new Error(P6x);}var Editor=(function(){var R7e=r7lc_;var R64="prototyp";var B_A="dataSources";var T_J="alI18n";var B_G="version";var l1u="factory";var B4S="Time";var j7v='2.1.2';var h3S="Type";var a$q="intern";R7e.w49();var L73="internalEven";var k7K=d6a;k7K+=J2$;var n9f=D_b;n9f+=E_j;n9f+=v4k;n9f+=l4$;var E0D=Q0g;E0D+=X2M;var w4E=x_S;w4E+=E_j;w4E+=B4S;var a7i=h7_;a7i+=z_Y;a7i+=l4$;a7i+=s4U;var u$f=r7lc_.q78;u$f+=O6E;u$f+=q_1;u$f+=l4$;var M60=r7lc_.q78;M60+=H$7;M60+=h3S;M60+=l4$;var w$o=R64;w$o+=E_j;var d0f=a$q;d0f+=T_J;var L1H=L73;L1H+=r7lc_.I0t;var H$G=f1A;H$G+=t$M;function Editor(init,cjsJq){var h6N="_displayReorde";var M9b="_as";var e1p="n.";var D04="nit";var P91="rm_";var u$x="\"form";var c92='initEditor';var S5n="nitCo";var C0s="_neste";var t8K="_m";var N78="xten";var I1M="fil";var m3B="<div data-dte-e";var u4b='<div data-dte-e="form_info" class="';var c_R="></d";var a2c="ltiInfo";var u5i="DataTables Editor mu";var v4M="unique";var o1p="_submitSuccess";var c3U="rud";var p3F="dt.dt";var W7B='"></div></div>';var x46="sse";var M9N="_nes";var H0N="m>";var l6v='foot';var A7c="div ";var O95="nArr";var t9a='<div data-dte-e="head" class="';var f2A="ar";var J9a="Trigger";var S1g="_wea";var E8M="kI";var o5r='init.dt.dte';var G1E="indicator";var m0D="models";var f9d="r.dt.dte";var C$8="_field";var f2s="ultiSet";var n2O="ss=\"";var D3x="<div data-dte-e=";var i3l="st be initialised as a \'new\' ";var m1d="_optionsUpdate";var t1q="entName";var W1C='<div data-dte-e="body_content" class="';var X4b="sembleMain";var a7a="essing";var V02="_submitTable";var f8D="\"body\" class=\"";var u7l="nlineCreate";var c2J="=";var x$3="Opti";var Z0U="<div";var R0i="domTable";var Y54="instance";var n3v="_mess";var h8X="_f";var e3z="ependen";var g8S='<form data-dte-e="form" class="';var T1P="_content\" class=\"";var L6v='<div data-dte-e="processing" class="';var N8Z="dClose";var h9n="xh";var l81='<div data-dte-e="form_error" class="';var w0m="ionName";var r5c="dOpe";var s8C="nten";var E1s="_for";var h1C="ooter";var K2U='<div data-dte-e="foot" class="';var y3z="Na";var a25=" data-dte-e=\"form_buttons\" cla";var M$K='body_content';var Y3F="tError";var B1X="Args";var E0A="ote";var u6L='Cannot find display controller ';var C$a="yNod";var Y4i="\"><";var z05="nique";var o4G="dFromNode";var g5C=O6E;g5C+=S5n;g5C+=J8U;g5C+=f7$;var q91=O6E;q91+=D04;var k7d=A9N;k7d+=l4$;k7d+=J2$;var U1W=j1j;U1W+=z05;var L9J=h9n;L9J+=f9d;var P$R=B_4;P$R+=r7lc_[616964];var I4S=s7R;I4S+=e1p;I4S+=p3F;I4S+=E_j;var r7b=B_4;r7b+=r7lc_[616964];var f2W=X1$;f2W+=a8w;f2W+=B8k;var v3N=H4N;v3N+=a7a;var t0h=L8X;t0h+=E_j;t0h+=V7G;t0h+=g$A;var l_9=w9A;l_9+=v9_;l_9+=B0W;var y_m=k0f;y_m+=r7lc_.q78;y_m+=B_4;var X_O=B2h;X_O+=g$A;X_O+=G2G;var V6c=r7lc_.q78;V6c+=G2G;V6c+=J8U;var o43=H1k;o43+=P91;o43+=k_V;o43+=Y$n;var E8B=X2D;E8B+=c_R;E8B+=k9f;var U24=I7o;U24+=h7x;var e7L=Z0U;e7L+=a25;e7L+=n2O;var t5$=O40;t5$+=a_Y;var m3p=K9b;m3p+=p5r;m3p+=A4X;m3p+=H0N;var W6u=m3B;W6u+=c2J;W6u+=u$x;W6u+=T1P;var R56=X2D;R56+=j87;var h02=Y4i;h02+=v8t;h02+=O6E;h02+=w5K;var N9a=g9q;N9a+=s8C;N9a+=r7lc_.I0t;var q_T=r7lc_.q78;q_T+=h1C;var b4D=R$a;b4D+=g$A;b4D+=D47;b4D+=g$A;var u8N=r7lc_.q78;u8N+=B_4;u8N+=E0A;u8N+=g$A;var j1U=T69;j1U+=y6K;j1U+=R1v;var F9r=D3x;F9r+=f8D;var b97=b5e;b97+=e15;var N5J=N5Z;N5J+=H19;N5J+=o0h;var l0K=K9b;l0K+=A7c;l0K+=W$P;var H$l=U_K;H$l+=T2s;var v4O=r7lc_[631343];v4O+=V7l;v4O+=x46;v4O+=l4$;var x97=E_j;x97+=N78;x97+=X2M;var n3y=r7lc_.I0t;n3y+=W1U;n3y+=Q4Z;n3y+=j80;var S8u=A7L;S8u+=v4k;S8u+=E_j;var S_1=e8A;S_1+=r7lc_.I0t;S_1+=w0m;var K4E=j7C;K4E+=r7lc_.I0t;K4E+=a8w;K4E+=X2M;var t9$=E_j;t9$+=D4G;t9$+=k88;var F2t=S1g;F2t+=E8M;F2t+=O95;F2t+=v7E;var N0n=F5w;N0n+=T69;N0n+=M2$;N0n+=Y3F;var x2H=k83;x2H+=r7lc_[616964];var O$s=C0s;O$s+=r5c;O$s+=r7lc_[616964];var v7s=M9N;v7s+=r7lc_.I0t;v7s+=E_j;v7s+=N8Z;var b0n=t8K;b0n+=j1j;b0n+=a2c;var l1r=n3v;l1r+=b0k;var Q89=G8n;Q89+=J9a;var r2U=E1s;r2U+=J8U;r2U+=x$3;r2U+=U9P;var k4p=C$8;k4p+=y3z;k4p+=F4j;k4p+=l4$;var B1O=h8X;B1O+=s7Z;B1O+=o4G;var q$F=P0D;q$F+=t1q;var n8T=i3B;n8T+=E_j;n8T+=A9N;n8T+=r7lc_.I0t;var k0i=h6N;k0i+=g$A;var l1h=C0r;l1h+=W_T;var e$Q=i3B;e$Q+=r7lc_[631343];e$Q+=c3U;e$Q+=B1X;var E1o=i3B;E1o+=h7_;E1o+=B_4;E1o+=Z_p;var O8C=i3B;O8C+=T69;O8C+=f9c;O8C+=g$A;var d1r=M9b;d1r+=X4b;var E7u=G_5;E7u+=D34;var t_I=h1q;t_I+=w2$;var d3$=l4$;d3$+=G30;var H5X=l4$;H5X+=L8X;H5X+=B_4;H5X+=R$a;var L_A=b3W;L_A+=R8u;var A1d=B_4;A1d+=Z5A;A1d+=B2h;var A2p=B_4;A2p+=D_g;A2p+=a8w;var e1H=B_4;e1H+=r7lc_[616964];e1H+=E_j;var B$A=B_4;B$A+=r7lc_[616964];var F9G=B_4;F9G+=U4_;var W$t=J8U;W$t+=f2s;var w2W=A6N;w2W+=n$L;var g6u=S4F;g6u+=J8F;var u7X=O6E;u7X+=u7l;var y1n=L8X;y1n+=z8c;var v6h=I1M;v6h+=E_j;v6h+=l4$;var b00=B2h;b00+=g$A;b00+=B_4;b00+=g$A;var Q23=E_j;Q23+=X2M;Q23+=O6E;Q23+=r7lc_.I0t;var O_C=X2M;O_C+=P4s;O_C+=C$a;O_C+=E_j;var k8E=X2M;k8E+=m_d;k8E+=v4k;k8E+=Z2R;var u5a=X2M;u5a+=r1M;u5a+=J2$;var l3d=J41;l3d+=e3z;l3d+=r7lc_.I0t;var B9D=r7lc_[631343];B9D+=q_1;B9D+=f2A;var C$E=T69;C$E+=j1j;C$E+=Y_p;var _this=this;this[n7F]=add;this[Y3a]=ajax;this[J2d]=background;this[D6X]=blur;this[v1X]=bubble;this[C$E]=bubblePosition;this[Y0_]=buttons;this[B9D]=clear;this[i6F]=close;this[n3q]=create;this[l3d]=undependent;this[Z3a]=dependent;this[q0S]=destroy;this[x0T]=disable;this[u5a]=display;this[k8E]=displayed;this[O_C]=displayNode;this[Q23]=edit;this[u_V]=enable;this[b00]=error$1;this[g_V]=field;this[b7d]=fields;this[k$c]=file;this[v6h]=files;this[m8j]=get;this[y1n]=hide;this[U_G]=ids;this[d3v]=inError;this[T6X]=inline;this[u7X]=inlineCreate;this[J7h]=message;this[o$P]=mode;this[g6u]=modifier;this[w2W]=multiGet;this[W$t]=multiSet;this[x2p]=node;this[F9G]=off;this[B$A]=on;this[e1H]=one;this[A2p]=open;this[A1d]=order;this[L_A]=remove;this[V93]=set;this[H5X]=show;this[d3$]=submit;this[t_I]=table;this[o94]=template;this[D$Q]=title;this[w81]=val;this[i6h]=_actionClass;this[E7u]=_ajax;this[G0D]=_animate;this[d1r]=_assembleMain;this[O8C]=_blur;this[i7d]=_clearDynamicInfo;this[E1o]=_close;this[a0E]=_closeReg;this[e$Q]=_crudArgs;this[l1h]=_dataSource;this[k0i]=_displayReorder;this[n8T]=_edit;this[M4P]=_event;this[q$F]=_eventName;this[B1O]=_fieldFromNode;this[k4p]=_fieldNames;this[s2p]=_focus;this[r2U]=_formOptions;this[B6p]=_inline;this[Q89]=_inputTrigger;this[m1d]=_optionsUpdate;this[l1r]=_message;this[b0n]=_multiInfo;this[v7s]=_nestedClose;this[O$s]=_nestedOpen;this[B4I]=_postopen;this[x2H]=_preopen;this[V7L]=_processing;this[S_K]=_noProcessing;this[Z4g]=_submit;this[V02]=_submitTable;this[o1p]=_submitSuccess;this[N0n]=_submitError;this[y0k]=_tidy;this[F2t]=_weakInArray;if(Editor[l1u](init,cjsJq)){return Editor;}if(!(this instanceof Editor)){var G7n=u5i;G7n+=i3l;G7n+=Y54;alert(G7n);}init=$[t9$](E6A,{},Editor[r2L],init);this[r7lc_[631343]]=init;this[l4$]=$[K4E](E6A,{},Editor[m0D][Y9x],{actionName:init[S_1],ajax:init[Y3a],formOptions:init[P2i],idSrc:init[m5b],table:init[R0i] || init[S8u],template:init[n3y]?$(init[o94])[U8w]():v5D});this[x6a]=$[x97](E6A,{},Editor[v4O]);this[H$l]=init[N9v];Editor[m0D][Y9x][v4M]++;var that=this;var classes=this[x6a];var wrapper=$(l0K + classes[N5J] + T3G + L6v + classes[b97][G1E] + a$f + F9r + classes[j1U][V3F] + T3G + W1C + classes[S$u][C_y] + t1P + a$h + K2U + classes[u8N][b4D] + T3G + u3L + classes[q_T][N9a] + h02 + a$h + a$h);var form=$(g8S + classes[O2E][c8D] + R56 + W6u + classes[O2E][C_y] + t1P + m3p);this[H$1]={body:el(t5$,wrapper)[U3X],bodyContent:el(M$K,wrapper)[U3X],buttons:$(e7L + classes[O2E][U24] + E8B)[U3X],footer:el(l6v,wrapper)[U3X],form:form[U3X],formContent:el(o43,form)[U3X],formError:$(l81 + classes[V6c][X_O] + t1P)[U3X],formInfo:$(u4b + classes[O2E][y_m] + t1P)[U3X],header:$(t9a + classes[X53][V3F] + l_9 + classes[t0h][C_y] + W7B)[U3X],processing:el(v3N,wrapper)[U3X],wrapper:wrapper[U3X]};$[n8S](init[f2W],function(evt,fn){R7e.w49();that[e40](evt,function(){var M5a="ply";var i03=H19;i03+=M5a;var B8K=q_1;B8K+=r7lc_[616964];R7e.y2x();B8K+=H76;var argsIn=[];for(var _i=U3X;_i < arguments[B8K];_i++){argsIn[_i]=arguments[_i];}fn[i03](that,argsIn);});});this[H$1];if(init[b7d]){var I3R=r7lc_.q78;I3R+=O6E;I3R+=L1Y;I3R+=l4$;this[n7F](init[I3R]);}$(document)[e40](o5r + this[l4$][v4M],function(e,settings,json){var u2T="nT";var table=_this[l4$][s9i];if(table){var o1X=r7lc_[616964];o1X+=B_4;o1X+=X2M;o1X+=E_j;var O4Y=r7lc_.I0t;O4Y+=U6p;O4Y+=v4k;O4Y+=E_j;var S$4=u2T;S$4+=M4$;S$4+=V88;S$4+=E_j;var dtApi=new DataTable[s1J](table);if(settings[S$4] === dtApi[O4Y]()[o1X]()){var y9P=y_3;y9P+=A9N;y9P+=w2q;settings[y9P]=_this;}}})[r7b](I4S + this[l4$][v4M],function(e,settings){var H$Y="nTab";var T3c="nguag";var f$H="oLanguage";var w6H="oLa";var table=_this[l4$][s9i];R7e.w49();if(table){var D00=r7lc_.I0t;D00+=U6p;D00+=v4k;D00+=E_j;var B0Y=H$Y;B0Y+=v4k;B0Y+=E_j;var dtApi=new DataTable[s1J](table);if(settings[B0Y] === dtApi[D00]()[x2p]()){var p96=w6H;p96+=T3c;p96+=E_j;if(settings[p96][g0f]){var j7e=v0L;j7e+=B_4;j7e+=g$A;var p41=E_j;p41+=q40;p41+=E_j;p41+=k88;$[p41](E6A,_this[N9v],settings[f$H][j7e]);}}}})[P$R](L9J + this[l4$][U1W],function(e,settings,json){var a1i="pi";R7e.y2x();var table=_this[l4$][s9i];if(table){var I0u=r7lc_[616964];I0u+=B_4;I0u+=g_x;var Y7F=o32;Y7F+=a1i;var dtApi=new DataTable[Y7F](table);if(settings[h7P] === dtApi[s9i]()[I0u]()){_this[m1d](json);}}});if(!Editor[u_G][init[k7d]]){var H4p=w2n;H4p+=v4k;H4p+=v7E;throw new Error(u6L + init[H4p]);}this[l4$][K28]=Editor[u_G][init[u_G]][q91](this);this[M4P](g5C,[]);$(document)[G$k](c92,[this]);}Editor[H$G][L1H]=function(name,args){R7e.w49();this[M4P](name,args);};Editor[C36][d0f]=function(){var W14=O6E;W14+=o1i;W14+=r7lc_[616964];R7e.w49();return this[W14];};Editor[w$o][W8Q]=function(){var G4g="_multiInfo";return this[G4g]();};Editor[C36][U_D]=function(){return this[l4$];};Editor[M60]={checkbox:checkbox,datatable:datatable,datetime:datetime,hidden:hidden,password:password,radio:radio,readonly:readonly,select:select,text:text,textarea:textarea,upload:upload,uploadMany:uploadMany};Editor[u$f]={};Editor[B_G]=j7v;Editor[a7i]=classNames;Editor[m0Y]=Field;Editor[w4E]=v5D;Editor[S_q]=error;Editor[J7L]=pairs;Editor[l1u]=factory;Editor[E0D]=upload$1;Editor[r2L]=defaults$1;Editor[n9f]={button:button,displayController:displayController,fieldType:fieldType,formOptions:formOptions,settings:settings};Editor[B_A]={dataTable:dataSource$1,html:dataSource};Editor[k7K]={envelope:envelope,lightbox:self};Editor[M$Y]=function(id){return safeDomId(id,D3I);};return Editor;})();DataTable[u0x]=Editor;$[T5x][l4z][W6a]=Editor;if(DataTable[W_v]){Editor[W_v]=DataTable[W_v];}if(DataTable[z0a][J4l]){var T3a=E_j;T3a+=D4G;T3a+=r7lc_[616964];T3a+=X2M;$[T3a](Editor[J2K],DataTable[O6h][K85]);}DataTable[O6h][C$b]=Editor[v9d];return Editor;});})();

/*! Bootstrap integration for DataTables' Editor
 * © SpryMedia Ltd - datatables.net/license
 */

(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net-bs5', 'datatables.net-editor'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		var jq = require('jquery');
		var cjsRequires = function (root, $) {
			if ( ! $.fn.dataTable ) {
				require('datatables.net-bs5')(root, $);
			}

			if ( ! $.fn.dataTable.Editor ) {
				require('datatables.net-editor')(root, $);
			}
		};

		if (typeof window !== 'undefined') {
			module.exports = function (root, $) {
				if ( ! root ) {
					// CommonJS environments without a window global must pass a
					// root. This will give an error otherwise
					root = window;
				}

				if ( ! $ ) {
					$ = jq( root );
				}

				cjsRequires( root, $ );
				return factory( $, root, root.document );
			};
		}
		else {
			cjsRequires( window, jq );
			module.exports = factory( jq, window, window.document );
		}
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


var Editor = DataTable.Editor;

/*
 * Set the default display controller to be our bootstrap control 
 */
DataTable.Editor.defaults.display = "bootstrap";


/*
 * Change the default classes from Editor to be classes for Bootstrap
 */
$.extend( true, $.fn.dataTable.Editor.classes, {
	"header": {
		"wrapper": "DTE_Header",
		title: {
			tag: 'h5',
			class: 'modal-title'
		}
	},
	"body": {
		"wrapper": "DTE_Body"
	},
	"footer": {
		"wrapper": "DTE_Footer"
	},
	"form": {
		"tag": "form-horizontal",
		"button": "btn",
		"buttonInternal": "btn btn-outline-secondary"
	},
	"field": {
		"wrapper": "DTE_Field form-group row",
		"label":   "col-lg-4 col-form-label",
		"input":   "col-lg-8",
		"error":   "error is-invalid",
		"msg-labelInfo": "form-text text-secondary small",
		"msg-info":      "form-text text-secondary small",
		"msg-message":   "form-text text-secondary small",
		"msg-error":     "form-text text-danger small",
		"multiValue":    "card multi-value",
		"multiInfo":     "small",
		"multiRestore":  "multi-restore"
	}
} );

$.extend( true, DataTable.ext.buttons, {
	create: {
		formButtons: {
			className: 'btn-primary'
		}
	},
	edit: {
		formButtons: {
			className: 'btn-primary'
		}
	},
	remove: {
		formButtons: {
			className: 'btn-danger'
		}
	}
} );

DataTable.Editor.fieldTypes.datatable.tableClass = 'table';

/*
 * Bootstrap display controller - this is effectively a proxy to the Bootstrap
 * modal control.
 */
let shown = false;
let fullyShown = false;

const dom = {
	content: $(
		'<div class="modal fade DTED">'+
			'<div class="modal-dialog modal-dialog-scrollable modal-dialog-centered"></div>'+
		'</div>'
	),
	close: $('<button class="btn-close"></div>')
};
let modal;
let _bs = window.bootstrap;

DataTable.Editor.bootstrap = function (bs) {
	_bs = bs;
}

DataTable.Editor.display.bootstrap = $.extend( true, {}, DataTable.Editor.models.displayController, {
	/*
	 * API methods
	 */
	init: function ( dte ) {
		// Add `form-control` to required elements
		dte.on( 'displayOrder.dtebs open.dtebs', function ( e, display, action, form ) {
			$.each( dte.s.fields, function ( key, field ) {
				$('input:not([type=checkbox]):not([type=radio]), select, textarea', field.node() )
					.addClass( 'form-control' );

				$('input[type=checkbox], input[type=radio]', field.node() )
					.addClass( 'form-check-input' );

				$('select', field.node() )
					.addClass( 'form-select' );
			} );
		} );

		return DataTable.Editor.display.bootstrap;
	},

	open: function ( dte, append, callback ) {
		if (! modal) {
			modal = new _bs.Modal(dom.content[0], {
				backdrop: "static",
				keyboard: false
			});
		}

		$(append).addClass('modal-content');
		$('.DTE_Header', append).addClass('modal-header');
		$('.DTE_Body', append).addClass('modal-body');
		$('.DTE_Footer', append).addClass('modal-footer');

		// Special class for DataTable buttons in the form
		$(append).find('div.DTE_Field_Type_datatable div.dt-buttons')
			.removeClass('btn-group')
			.addClass('btn-group-vertical');

		// Setup events on each show
		dom.close
			.attr('title', dte.i18n.close)
			.off('click.dte-bs5')
			.on('click.dte-bs5', function () {
				dte.close('icon');
			})
			.appendTo($('div.modal-header', append));

		// This is a bit horrible, but if you mousedown and then drag out of the modal container, we don't
		// want to trigger a background action.
		let allowBackgroundClick = false;
		$(document)
			.off('mousedown.dte-bs5')
			.on('mousedown.dte-bs5', 'div.modal', function (e) {
				allowBackgroundClick = $(e.target).hasClass('modal') && shown
					? true
					: false;
			} );

		$(document)
			.off('click.dte-bs5')
			.on('click.dte-bs5', 'div.modal', function (e) {
				if ( $(e.target).hasClass('modal') && allowBackgroundClick ) {
					dte.background();
				}
			} );

		var content = dom.content.find('div.modal-dialog');
		content.children().detach();
		content.append( append );

		// Floating label support - rearrange the DOM for the inputs
		if (dte.c.bootstrap && dte.c.bootstrap.floatingLabels) {
			var floating_label_types = ['readonly', 'text', 'textarea', 'select', 'datetime']
			var fields = dte.order();

			fields
				.filter(function (f) {
					var type = dte.field(f).s.opts.type;

					return floating_label_types.includes(type);
				})
				.forEach(function(f) {
					var node = $(dte.field(f).node());
					var wrapper = node.find('.DTE_Field_InputControl');
					var control = wrapper.children(':first-child');
					var label = node.find('label');

					wrapper.parent().removeClass('col-lg-8').addClass('col-lg-12');
					wrapper.addClass('form-floating');
					control.addClass('form-control').attr("placeholder", f);
					label.appendTo(wrapper);
				});
		}

		if ( shown ) {
			if ( callback ) {
				callback();
			}
			return;
		}

		shown = true;
		fullyShown = false;

		$(dom.content)
			.one('shown.bs.modal', function () {
				// Can only give elements focus when shown
				if ( dte.s.setFocus ) {
					dte.s.setFocus.focus();
				}

				fullyShown = true;

				if ( callback ) {
					callback();
				}
			})
			.one('hidden', function () {
				shown = false;
			})
			.appendTo( 'body' );
		
		modal.show();
	},

	close: function ( dte, callback ) {
		if ( ! shown ) {
			if ( callback ) {
				callback();
			}
			return;
		}

		// Check if actually displayed or not before hiding. BS4 doesn't like `hide`
		// before it has been fully displayed
		if ( ! fullyShown ) {
			$(dom.content)
				.one('shown.bs.modal', function () {
					DataTable.Editor.display.bootstrap.close( dte, callback );
				} );

			return;
		}

		$(dom.content)
			.one( 'hidden.bs.modal', function () {
				$(this).detach();
			} );

		modal.hide();

		shown = false;
		fullyShown = false;

		if ( callback ) {
			callback();
		}
	},

	node: function ( dte ) {
		return dom.content[0];
	},
} );


return Editor;
}));


/*! Buttons for DataTables 2.3.6
 * ©2016-2023 SpryMedia Ltd - datatables.net/license
 */

(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		var jq = require('jquery');
		var cjsRequires = function (root, $) {
			if ( ! $.fn.dataTable ) {
				require('datatables.net')(root, $);
			}
		};

		if (typeof window !== 'undefined') {
			module.exports = function (root, $) {
				if ( ! root ) {
					// CommonJS environments without a window global must pass a
					// root. This will give an error otherwise
					root = window;
				}

				if ( ! $ ) {
					$ = jq( root );
				}

				cjsRequires( root, $ );
				return factory( $, root, root.document );
			};
		}
		else {
			cjsRequires( window, jq );
			module.exports = factory( jq, window, window.document );
		}
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;



// Used for namespacing events added to the document by each instance, so they
// can be removed on destroy
var _instCounter = 0;

// Button namespacing counter for namespacing events on individual buttons
var _buttonCounter = 0;

var _dtButtons = DataTable.ext.buttons;

// Allow for jQuery slim
function _fadeIn(el, duration, fn) {
	if ($.fn.animate) {
		el
			.stop()
			.fadeIn( duration, fn );

	}
	else {
		el.css('display', 'block');

		if (fn) {
			fn.call(el);
		}
	}
}

function _fadeOut(el, duration, fn) {
	if ($.fn.animate) {
		el
			.stop()
			.fadeOut( duration, fn );
	}
	else {
		el.css('display', 'none');
		
		if (fn) {
			fn.call(el);
		}
	}
}

/**
 * [Buttons description]
 * @param {[type]}
 * @param {[type]}
 */
var Buttons = function( dt, config )
{
	// If not created with a `new` keyword then we return a wrapper function that
	// will take the settings object for a DT. This allows easy use of new instances
	// with the `layout` option - e.g. `topLeft: $.fn.dataTable.Buttons( ... )`.
	if ( !(this instanceof Buttons) ) {
		return function (settings) {
			return new Buttons( settings, dt ).container();
		};
	}

	// If there is no config set it to an empty object
	if ( typeof( config ) === 'undefined' ) {
		config = {};	
	}
	
	// Allow a boolean true for defaults
	if ( config === true ) {
		config = {};
	}

	// For easy configuration of buttons an array can be given
	if ( Array.isArray( config ) ) {
		config = { buttons: config };
	}

	this.c = $.extend( true, {}, Buttons.defaults, config );

	// Don't want a deep copy for the buttons
	if ( config.buttons ) {
		this.c.buttons = config.buttons;
	}

	this.s = {
		dt: new DataTable.Api( dt ),
		buttons: [],
		listenKeys: '',
		namespace: 'dtb'+(_instCounter++)
	};

	this.dom = {
		container: $('<'+this.c.dom.container.tag+'/>')
			.addClass( this.c.dom.container.className )
	};

	this._constructor();
};


$.extend( Buttons.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Public methods
	 */

	/**
	 * Get the action of a button
	 * @param  {int|string} Button index
	 * @return {function}
	 *//**
	 * Set the action of a button
	 * @param  {node} node Button element
	 * @param  {function} action Function to set
	 * @return {Buttons} Self for chaining
	 */
	action: function ( node, action )
	{
		var button = this._nodeToButton( node );

		if ( action === undefined ) {
			return button.conf.action;
		}

		button.conf.action = action;

		return this;
	},

	/**
	 * Add an active class to the button to make to look active or get current
	 * active state.
	 * @param  {node} node Button element
	 * @param  {boolean} [flag] Enable / disable flag
	 * @return {Buttons} Self for chaining or boolean for getter
	 */
	active: function ( node, flag ) {
		var button = this._nodeToButton( node );
		var klass = this.c.dom.button.active;
		var jqNode = $(button.node);

		if ( flag === undefined ) {
			return jqNode.hasClass( klass );
		}

		jqNode.toggleClass( klass, flag === undefined ? true : flag );

		return this;
	},

	/**
	 * Add a new button
	 * @param {object} config Button configuration object, base string name or function
	 * @param {int|string} [idx] Button index for where to insert the button
	 * @param {boolean} [draw=true] Trigger a draw. Set a false when adding
	 *   lots of buttons, until the last button.
	 * @return {Buttons} Self for chaining
	 */
	add: function ( config, idx, draw )
	{
		var buttons = this.s.buttons;

		if ( typeof idx === 'string' ) {
			var split = idx.split('-');
			var base = this.s;

			for ( var i=0, ien=split.length-1 ; i<ien ; i++ ) {
				base = base.buttons[ split[i]*1 ];
			}

			buttons = base.buttons;
			idx = split[ split.length-1 ]*1;
		}

		this._expandButton(
			buttons,
			config,
			config !== undefined ? config.split : undefined,
			(config === undefined || config.split === undefined || config.split.length === 0) && base !== undefined,
			false,
			idx
		);

		if (draw === undefined || draw === true) {
			this._draw();
		}
	
		return this;
	},

	/**
	 * Clear buttons from a collection and then insert new buttons
	 */
	collectionRebuild: function ( node, newButtons )
	{
		var button = this._nodeToButton( node );
		
		if(newButtons !== undefined) {
			var i;
			// Need to reverse the array
			for (i=button.buttons.length-1; i>=0; i--) {
				this.remove(button.buttons[i].node);
			}

			// If the collection has prefix and / or postfix buttons we need to add them in
			if (button.conf.prefixButtons) {
				newButtons.unshift.apply(newButtons, button.conf.prefixButtons);
			}

			if (button.conf.postfixButtons) {
				newButtons.push.apply(newButtons, button.conf.postfixButtons);
			}

			for (i=0; i<newButtons.length; i++) {
				var newBtn = newButtons[i];

				this._expandButton(
					button.buttons,
					newBtn,
					newBtn !== undefined && newBtn.config !== undefined && newBtn.config.split !== undefined,
					true,
					newBtn.parentConf !== undefined && newBtn.parentConf.split !== undefined,
					null,
					newBtn.parentConf
				);
			}
		}

		this._draw(button.collection, button.buttons);
	},

	/**
	 * Get the container node for the buttons
	 * @return {jQuery} Buttons node
	 */
	container: function ()
	{
		return this.dom.container;
	},

	/**
	 * Disable a button
	 * @param  {node} node Button node
	 * @return {Buttons} Self for chaining
	 */
	disable: function ( node ) {
		var button = this._nodeToButton( node );

		$(button.node)
			.addClass( this.c.dom.button.disabled )
			.prop('disabled', true);

		return this;
	},

	/**
	 * Destroy the instance, cleaning up event handlers and removing DOM
	 * elements
	 * @return {Buttons} Self for chaining
	 */
	destroy: function ()
	{
		// Key event listener
		$('body').off( 'keyup.'+this.s.namespace );

		// Individual button destroy (so they can remove their own events if
		// needed). Take a copy as the array is modified by `remove`
		var buttons = this.s.buttons.slice();
		var i, ien;
		
		for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
			this.remove( buttons[i].node );
		}

		// Container
		this.dom.container.remove();

		// Remove from the settings object collection
		var buttonInsts = this.s.dt.settings()[0];

		for ( i=0, ien=buttonInsts.length ; i<ien ; i++ ) {
			if ( buttonInsts.inst === this ) {
				buttonInsts.splice( i, 1 );
				break;
			}
		}

		return this;
	},

	/**
	 * Enable / disable a button
	 * @param  {node} node Button node
	 * @param  {boolean} [flag=true] Enable / disable flag
	 * @return {Buttons} Self for chaining
	 */
	enable: function ( node, flag )
	{
		if ( flag === false ) {
			return this.disable( node );
		}

		var button = this._nodeToButton( node );
		$(button.node)
			.removeClass( this.c.dom.button.disabled )
			.prop('disabled', false);

		return this;
	},

	/**
	 * Get a button's index
	 * 
	 * This is internally recursive
	 * @param {element} node Button to get the index of
	 * @return {string} Button index
	 */
	index: function ( node, nested, buttons )
	{
		if ( ! nested ) {
			nested = '';
			buttons = this.s.buttons;
		}

		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			var inner = buttons[i].buttons;

			if (buttons[i].node === node) {
				return nested + i;
			}

			if ( inner && inner.length ) {
				var match = this.index(node, i + '-', inner);

				if (match !== null) {
					return match;
				}
			}
		}

		return null;
	},


	/**
	 * Get the instance name for the button set selector
	 * @return {string} Instance name
	 */
	name: function ()
	{
		return this.c.name;
	},

	/**
	 * Get a button's node of the buttons container if no button is given
	 * @param  {node} [node] Button node
	 * @return {jQuery} Button element, or container
	 */
	node: function ( node )
	{
		if ( ! node ) {
			return this.dom.container;
		}

		var button = this._nodeToButton( node );
		return $(button.node);
	},

	/**
	 * Set / get a processing class on the selected button
	 * @param {element} node Triggering button node
	 * @param  {boolean} flag true to add, false to remove, undefined to get
	 * @return {boolean|Buttons} Getter value or this if a setter.
	 */
	processing: function ( node, flag )
	{
		var dt = this.s.dt;
		var button = this._nodeToButton( node );

		if ( flag === undefined ) {
			return $(button.node).hasClass( 'processing' );
		}

		$(button.node).toggleClass( 'processing', flag );

		$(dt.table().node()).triggerHandler( 'buttons-processing.dt', [
			flag, dt.button( node ), dt, $(node), button.conf
		] );

		return this;
	},

	/**
	 * Remove a button.
	 * @param  {node} node Button node
	 * @return {Buttons} Self for chaining
	 */
	remove: function ( node )
	{
		var button = this._nodeToButton( node );
		var host = this._nodeToHost( node );
		var dt = this.s.dt;

		// Remove any child buttons first
		if ( button.buttons.length ) {
			for ( var i=button.buttons.length-1 ; i>=0 ; i-- ) {
				this.remove( button.buttons[i].node );
			}
		}

		button.conf.destroying = true;

		// Allow the button to remove event handlers, etc
		if ( button.conf.destroy ) {
			button.conf.destroy.call( dt.button(node), dt, $(node), button.conf );
		}

		this._removeKey( button.conf );

		$(button.node).remove();

		var idx = $.inArray( button, host );
		host.splice( idx, 1 );

		return this;
	},

	/**
	 * Get the text for a button
	 * @param  {int|string} node Button index
	 * @return {string} Button text
	 *//**
	 * Set the text for a button
	 * @param  {int|string|function} node Button index
	 * @param  {string} label Text
	 * @return {Buttons} Self for chaining
	 */
	text: function ( node, label )
	{
		var button = this._nodeToButton( node );
		var buttonLiner = this.c.dom.collection.buttonLiner;
		var linerTag = button.inCollection && buttonLiner && buttonLiner.tag ?
			buttonLiner.tag :
			this.c.dom.buttonLiner.tag;
		var dt = this.s.dt;
		var jqNode = $(button.node);
		var text = function ( opt ) {
			return typeof opt === 'function' ?
				opt( dt, jqNode, button.conf ) :
				opt;
		};

		if ( label === undefined ) {
			return text( button.conf.text );
		}

		button.conf.text = label;

		if ( linerTag ) {
			jqNode
				.children( linerTag )
				.eq(0)
				.filter(':not(.dt-down-arrow)')
				.html( text(label) );
		}
		else {
			jqNode.html( text(label) );
		}

		return this;
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */

	/**
	 * Buttons constructor
	 * @private
	 */
	_constructor: function ()
	{
		var that = this;
		var dt = this.s.dt;
		var dtSettings = dt.settings()[0];
		var buttons =  this.c.buttons;

		if ( ! dtSettings._buttons ) {
			dtSettings._buttons = [];
		}

		dtSettings._buttons.push( {
			inst: this,
			name: this.c.name
		} );

		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			this.add( buttons[i] );
		}

		dt.on( 'destroy', function ( e, settings ) {
			if ( settings === dtSettings ) {
				that.destroy();
			}
		} );

		// Global key event binding to listen for button keys
		$('body').on( 'keyup.'+this.s.namespace, function ( e ) {
			if ( ! document.activeElement || document.activeElement === document.body ) {
				// SUse a string of characters for fast lookup of if we need to
				// handle this
				var character = String.fromCharCode(e.keyCode).toLowerCase();

				if ( that.s.listenKeys.toLowerCase().indexOf( character ) !== -1 ) {
					that._keypress( character, e );
				}
			}
		} );
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods
	 */

	/**
	 * Add a new button to the key press listener
	 * @param {object} conf Resolved button configuration object
	 * @private
	 */
	_addKey: function ( conf )
	{
		if ( conf.key ) {
			this.s.listenKeys += $.isPlainObject( conf.key ) ?
				conf.key.key :
				conf.key;
		}
	},

	/**
	 * Insert the buttons into the container. Call without parameters!
	 * @param  {node} [container] Recursive only - Insert point
	 * @param  {array} [buttons] Recursive only - Buttons array
	 * @private
	 */
	_draw: function ( container, buttons )
	{
		if ( ! container ) {
			container = this.dom.container;
			buttons = this.s.buttons;
		}

		container.children().detach();

		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			container.append( buttons[i].inserter );
			container.append( ' ' );

			if ( buttons[i].buttons && buttons[i].buttons.length ) {
				this._draw( buttons[i].collection, buttons[i].buttons );
			}
		}
	},

	/**
	 * Create buttons from an array of buttons
	 * @param  {array} attachTo Buttons array to attach to
	 * @param  {object} button Button definition
	 * @param  {boolean} inCollection true if the button is in a collection
	 * @private
	 */
	_expandButton: function ( attachTo, button, split, inCollection, inSplit, attachPoint, parentConf )
	{
		var dt = this.s.dt;
		var buttonCounter = 0;
		var isSplit = false;
		var buttons = ! Array.isArray( button ) ?
			[ button ] :
			button;
		
		if(button === undefined ) {
			buttons = !Array.isArray(split) ?
				[ split ] :
				split;
		}

		if (button !== undefined && button.split !== undefined) {
			isSplit = true;
		}
			
		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			var conf = this._resolveExtends( buttons[i] );

			if ( ! conf ) {
				continue;
			}

			if( conf.config !== undefined && conf.config.split) {
				isSplit = true;
			}
			else {
				isSplit = false;
			}
			
			// If the configuration is an array, then expand the buttons at this
			// point
			if ( Array.isArray( conf ) ) {
				this._expandButton( attachTo, conf, built !== undefined && built.conf !== undefined ? built.conf.split : undefined, inCollection, parentConf !== undefined && parentConf.split !== undefined, attachPoint, parentConf );
				continue;
			}

			var built = this._buildButton( conf, inCollection, conf.split !== undefined || (conf.config !== undefined && conf.config.split !== undefined), inSplit );
			if ( ! built ) {
				continue;
			}

			if ( attachPoint !== undefined && attachPoint !== null ) {
				attachTo.splice( attachPoint, 0, built );
				attachPoint++;
			}
			else {
				attachTo.push( built );
			}

			
			if ( built.conf.buttons || built.conf.split ) {
				built.collection = $('<'+(isSplit ? this.c.dom.splitCollection.tag : this.c.dom.collection.tag)+'/>');

				built.conf._collection = built.collection;

				if(built.conf.split) {
					for(var j = 0; j < built.conf.split.length; j++) {
						if(typeof built.conf.split[j] === "object") {
							built.conf.split[j].parent = parentConf;
							if(built.conf.split[j].collectionLayout === undefined) {
								built.conf.split[j].collectionLayout = built.conf.collectionLayout;
							}
							if(built.conf.split[j].dropup === undefined) {
								built.conf.split[j].dropup = built.conf.dropup;
							}
							if(built.conf.split[j].fade === undefined) {
								built.conf.split[j].fade = built.conf.fade;
							}
						}
					}
				}
				else {
					$(built.node).append($('<span class="dt-down-arrow">'+this.c.dom.splitDropdown.text+'</span>'))
				}

				this._expandButton( built.buttons, built.conf.buttons, built.conf.split, !isSplit, isSplit, attachPoint, built.conf );
			}
			built.conf.parent = parentConf;

			// init call is made here, rather than buildButton as it needs to
			// be selectable, and for that it needs to be in the buttons array
			if ( conf.init ) {
				conf.init.call( dt.button( built.node ), dt, $(built.node), conf );
			}

			buttonCounter++;
		}
	},

	/**
	 * Create an individual button
	 * @param  {object} config            Resolved button configuration
	 * @param  {boolean} inCollection `true` if a collection button
	 * @return {jQuery} Created button node (jQuery)
	 * @private
	 */
	_buildButton: function ( config, inCollection, isSplit, inSplit )
	{
		var buttonDom = this.c.dom.button;
		var linerDom = this.c.dom.buttonLiner;
		var collectionDom = this.c.dom.collection;
		var splitDom = this.c.dom.split;
		var splitCollectionDom = this.c.dom.splitCollection;
		var splitDropdownButton = this.c.dom.splitDropdownButton;
		var dt = this.s.dt;
		var text = function ( opt ) {
			return typeof opt === 'function' ?
				opt( dt, button, config ) :
				opt;
		};

		// Spacers don't do much other than insert an element into the DOM
		if (config.spacer) {
			var spacer = $('<span></span>')
				.addClass('dt-button-spacer ' + config.style + ' ' + buttonDom.spacerClass)
				.html(text(config.text));

			return {
				conf:         config,
				node:         spacer,
				inserter:     spacer,
				buttons:      [],
				inCollection: inCollection,
				isSplit:	  isSplit,
				inSplit:	  inSplit,
				collection:   null
			};
		}

		if ( !isSplit && inSplit && splitCollectionDom ) {
			buttonDom = splitDropdownButton;
		}
		else if ( !isSplit && inCollection && collectionDom.button ) {
			buttonDom = collectionDom.button;
		} 

		if ( !isSplit && inSplit && splitCollectionDom.buttonLiner ) {
			linerDom = splitCollectionDom.buttonLiner
		}
		else if ( !isSplit && inCollection && collectionDom.buttonLiner ) {
			linerDom = collectionDom.buttonLiner;
		}

		// Make sure that the button is available based on whatever requirements
		// it has. For example, PDF button require pdfmake
		if ( config.available && ! config.available( dt, config ) && !config.hasOwnProperty('html') ) {
			return false;
		}

		var button;
		if(!config.hasOwnProperty('html')) {
			var action = function ( e, dt, button, config ) {
				config.action.call( dt.button( button ), e, dt, button, config );
	
				$(dt.table().node()).triggerHandler( 'buttons-action.dt', [
					dt.button( button ), dt, button, config 
				] );
			};

			var tag = config.tag || buttonDom.tag;
			var clickBlurs = config.clickBlurs === undefined
				? true :
				config.clickBlurs;

			button = $('<'+tag+'/>')
				.addClass( buttonDom.className )
				.addClass( inSplit ? this.c.dom.splitDropdownButton.className : '')
				.attr( 'tabindex', this.s.dt.settings()[0].iTabIndex )
				.attr( 'aria-controls', this.s.dt.table().node().id )
				.on( 'click.dtb', function (e) {
					e.preventDefault();
	
					if ( ! button.hasClass( buttonDom.disabled ) && config.action ) {
						action( e, dt, button, config );
					}
					if( clickBlurs ) {
						button.trigger('blur');
					}
				} )
				.on( 'keypress.dtb', function (e) {
					if ( e.keyCode === 13 ) {
						e.preventDefault();

						if ( ! button.hasClass( buttonDom.disabled ) && config.action ) {
							action( e, dt, button, config );
						}
					}
				} );
	
			// Make `a` tags act like a link
			if ( tag.toLowerCase() === 'a' ) {
				button.attr( 'href', '#' );
			}
	
			// Button tags should have `type=button` so they don't have any default behaviour
			if ( tag.toLowerCase() === 'button' ) {
				button.attr( 'type', 'button' );
			}
	
			if ( linerDom.tag ) {
				var liner = $('<'+linerDom.tag+'/>')
					.html( text( config.text ) )
					.addClass( linerDom.className );
	
				if ( linerDom.tag.toLowerCase() === 'a' ) {
					liner.attr( 'href', '#' );
				}
	
				button.append( liner );
			}
			else {
				button.html( text( config.text ) );
			}
	
			if ( config.enabled === false ) {
				button.addClass( buttonDom.disabled );
			}
	
			if ( config.className ) {
				button.addClass( config.className );
			}
	
			if ( config.titleAttr ) {
				button.attr( 'title', text( config.titleAttr ) );
			}
	
			if ( config.attr ) {
				button.attr( config.attr );
			}
	
			if ( ! config.namespace ) {
				config.namespace = '.dt-button-'+(_buttonCounter++);
			}

			if  ( config.config !== undefined && config.config.split ) {
				config.split = config.config.split;
			}
		}
		else {
			button = $(config.html)
		}
	
		var buttonContainer = this.c.dom.buttonContainer;
		var inserter;
		if ( buttonContainer && buttonContainer.tag ) {
			inserter = $('<'+buttonContainer.tag+'/>')
				.addClass( buttonContainer.className )
				.append( button );
		}
		else {
			inserter = button;
		}

		this._addKey( config );

		// Style integration callback for DOM manipulation
		// Note that this is _not_ documented. It is currently
		// for style integration only
		if( this.c.buttonCreated ) {
			inserter = this.c.buttonCreated( config, inserter );
		}

		var splitDiv;
		if(isSplit) {
			splitDiv = $('<div/>').addClass(this.c.dom.splitWrapper.className)
			splitDiv.append(button);
			var dropButtonConfig = $.extend(config, {
				text: this.c.dom.splitDropdown.text,
				className: this.c.dom.splitDropdown.className,
				closeButton: false,
				attr: {
					'aria-haspopup': 'dialog',
					'aria-expanded': false
				},
				align: this.c.dom.splitDropdown.align,
				splitAlignClass: this.c.dom.splitDropdown.splitAlignClass
				
			})

			this._addKey(dropButtonConfig);

			var splitAction = function ( e, dt, button, config ) {
				_dtButtons.split.action.call( dt.button(splitDiv), e, dt, button, config );
	
				$(dt.table().node()).triggerHandler( 'buttons-action.dt', [
					dt.button( button ), dt, button, config 
				] );
				button.attr('aria-expanded', true)
			};
			
			var dropButton = $('<button class="' + this.c.dom.splitDropdown.className + ' dt-button"><span class="dt-btn-split-drop-arrow">'+this.c.dom.splitDropdown.text+'</span></button>')
				.on( 'click.dtb', function (e) {
					e.preventDefault();
					e.stopPropagation();

					if ( ! dropButton.hasClass( buttonDom.disabled )) {
						splitAction( e, dt, dropButton, dropButtonConfig );
					}
					if ( clickBlurs ) {
						dropButton.trigger('blur');
					}
				} )
				.on( 'keypress.dtb', function (e) {
					if ( e.keyCode === 13 ) {
						e.preventDefault();

						if ( ! dropButton.hasClass( buttonDom.disabled ) ) {
							splitAction( e, dt, dropButton, dropButtonConfig );
						}
					}
				} );

			if(config.split.length === 0) {
				dropButton.addClass('dtb-hide-drop');
			}

			splitDiv.append(dropButton).attr(dropButtonConfig.attr);
		}

		return {
			conf:         config,
			node:         isSplit ? splitDiv.get(0) : button.get(0),
			inserter:     isSplit ? splitDiv : inserter,
			buttons:      [],
			inCollection: inCollection,
			isSplit:	  isSplit,
			inSplit:	  inSplit,
			collection:   null
		};
	},

	/**
	 * Get the button object from a node (recursive)
	 * @param  {node} node Button node
	 * @param  {array} [buttons] Button array, uses base if not defined
	 * @return {object} Button object
	 * @private
	 */
	_nodeToButton: function ( node, buttons )
	{
		if ( ! buttons ) {
			buttons = this.s.buttons;
		}

		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			if ( buttons[i].node === node ) {
				return buttons[i];
			}

			if ( buttons[i].buttons.length ) {
				var ret = this._nodeToButton( node, buttons[i].buttons );

				if ( ret ) {
					return ret;
				}
			}
		}
	},

	/**
	 * Get container array for a button from a button node (recursive)
	 * @param  {node} node Button node
	 * @param  {array} [buttons] Button array, uses base if not defined
	 * @return {array} Button's host array
	 * @private
	 */
	_nodeToHost: function ( node, buttons )
	{
		if ( ! buttons ) {
			buttons = this.s.buttons;
		}

		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			if ( buttons[i].node === node ) {
				return buttons;
			}

			if ( buttons[i].buttons.length ) {
				var ret = this._nodeToHost( node, buttons[i].buttons );

				if ( ret ) {
					return ret;
				}
			}
		}
	},

	/**
	 * Handle a key press - determine if any button's key configured matches
	 * what was typed and trigger the action if so.
	 * @param  {string} character The character pressed
	 * @param  {object} e Key event that triggered this call
	 * @private
	 */
	_keypress: function ( character, e )
	{
		// Check if this button press already activated on another instance of Buttons
		if ( e._buttonsHandled ) {
			return;
		}

		var run = function ( conf, node ) {
			if ( ! conf.key ) {
				return;
			}

			if ( conf.key === character ) {
				e._buttonsHandled = true;
				$(node).click();
			}
			else if ( $.isPlainObject( conf.key ) ) {
				if ( conf.key.key !== character ) {
					return;
				}

				if ( conf.key.shiftKey && ! e.shiftKey ) {
					return;
				}

				if ( conf.key.altKey && ! e.altKey ) {
					return;
				}

				if ( conf.key.ctrlKey && ! e.ctrlKey ) {
					return;
				}

				if ( conf.key.metaKey && ! e.metaKey ) {
					return;
				}

				// Made it this far - it is good
				e._buttonsHandled = true;
				$(node).click();
			}
		};

		var recurse = function ( a ) {
			for ( var i=0, ien=a.length ; i<ien ; i++ ) {
				run( a[i].conf, a[i].node );

				if ( a[i].buttons.length ) {
					recurse( a[i].buttons );
				}
			}
		};

		recurse( this.s.buttons );
	},

	/**
	 * Remove a key from the key listener for this instance (to be used when a
	 * button is removed)
	 * @param  {object} conf Button configuration
	 * @private
	 */
	_removeKey: function ( conf )
	{
		if ( conf.key ) {
			var character = $.isPlainObject( conf.key ) ?
				conf.key.key :
				conf.key;

			// Remove only one character, as multiple buttons could have the
			// same listening key
			var a = this.s.listenKeys.split('');
			var idx = $.inArray( character, a );
			a.splice( idx, 1 );
			this.s.listenKeys = a.join('');
		}
	},

	/**
	 * Resolve a button configuration
	 * @param  {string|function|object} conf Button config to resolve
	 * @return {object} Button configuration
	 * @private
	 */
	_resolveExtends: function ( conf )
	{
		var that = this;
		var dt = this.s.dt;
		var i, ien;
		var toConfObject = function ( base ) {
			var loop = 0;

			// Loop until we have resolved to a button configuration, or an
			// array of button configurations (which will be iterated
			// separately)
			while ( ! $.isPlainObject(base) && ! Array.isArray(base) ) {
				if ( base === undefined ) {
					return;
				}

				if ( typeof base === 'function' ) {
					base = base.call( that, dt, conf );

					if ( ! base ) {
						return false;
					}
				}
				else if ( typeof base === 'string' ) {
					if ( ! _dtButtons[ base ] ) {
						return {html: base}
					}

					base = _dtButtons[ base ];
				}

				loop++;
				if ( loop > 30 ) {
					// Protect against misconfiguration killing the browser
					throw 'Buttons: Too many iterations';
				}
			}

			return Array.isArray( base ) ?
				base :
				$.extend( {}, base );
		};

		conf = toConfObject( conf );

		while ( conf && conf.extend ) {
			// Use `toConfObject` in case the button definition being extended
			// is itself a string or a function
			if ( ! _dtButtons[ conf.extend ] ) {
				throw 'Cannot extend unknown button type: '+conf.extend;
			}

			var objArray = toConfObject( _dtButtons[ conf.extend ] );
			if ( Array.isArray( objArray ) ) {
				return objArray;
			}
			else if ( ! objArray ) {
				// This is a little brutal as it might be possible to have a
				// valid button without the extend, but if there is no extend
				// then the host button would be acting in an undefined state
				return false;
			}

			// Stash the current class name
			var originalClassName = objArray.className;

			if (conf.config !== undefined && objArray.config !== undefined) {
				conf.config = $.extend({}, objArray.config, conf.config)
			}

			conf = $.extend( {}, objArray, conf );

			// The extend will have overwritten the original class name if the
			// `conf` object also assigned a class, but we want to concatenate
			// them so they are list that is combined from all extended buttons
			if ( originalClassName && conf.className !== originalClassName ) {
				conf.className = originalClassName+' '+conf.className;
			}

			// Although we want the `conf` object to overwrite almost all of
			// the properties of the object being extended, the `extend`
			// property should come from the object being extended
			conf.extend = objArray.extend;
		}

		// Buttons to be added to a collection  -gives the ability to define
		// if buttons should be added to the start or end of a collection
		var postfixButtons = conf.postfixButtons;
		if ( postfixButtons ) {
			if ( ! conf.buttons ) {
				conf.buttons = [];
			}

			for ( i=0, ien=postfixButtons.length ; i<ien ; i++ ) {
				conf.buttons.push( postfixButtons[i] );
			}
		}

		var prefixButtons = conf.prefixButtons;
		if ( prefixButtons ) {
			if ( ! conf.buttons ) {
				conf.buttons = [];
			}

			for ( i=0, ien=prefixButtons.length ; i<ien ; i++ ) {
				conf.buttons.splice( i, 0, prefixButtons[i] );
			}
		}

		return conf;
	},

	/**
	 * Display (and replace if there is an existing one) a popover attached to a button
	 * @param {string|node} content Content to show
	 * @param {DataTable.Api} hostButton DT API instance of the button
	 * @param {object} inOpts Options (see object below for all options)
	 */
	_popover: function ( content, hostButton, inOpts, e ) {
		var dt = hostButton;
		var buttonsSettings = this.c;
		var closed = false;
		var options = $.extend( {
			align: 'button-left', // button-right, dt-container, split-left, split-right
			autoClose: false,
			background: true,
			backgroundClassName: 'dt-button-background',
			closeButton: true,
			contentClassName: buttonsSettings.dom.collection.className,
			collectionLayout: '',
			collectionTitle: '',
			dropup: false,
			fade: 400,
			popoverTitle: '',
			rightAlignClassName: 'dt-button-right',
			tag: buttonsSettings.dom.collection.tag
		}, inOpts );

		var hostNode = hostButton.node();

		var close = function () {
			closed = true;

			_fadeOut(
				$('.dt-button-collection'),
				options.fade,
				function () {
					$(this).detach();
				}
			);

			$(dt.buttons( '[aria-haspopup="dialog"][aria-expanded="true"]' ).nodes())
				.attr('aria-expanded', 'false');

			$('div.dt-button-background').off( 'click.dtb-collection' );
			Buttons.background( false, options.backgroundClassName, options.fade, hostNode );

			$(window).off('resize.resize.dtb-collection');
			$('body').off( '.dtb-collection' );
			dt.off( 'buttons-action.b-internal' );
			dt.off( 'destroy' );
		};

		if (content === false) {
			close();
			return;
		}

		var existingExpanded = $(dt.buttons( '[aria-haspopup="dialog"][aria-expanded="true"]' ).nodes());
		if ( existingExpanded.length ) {
			// Reuse the current position if the button that was triggered is inside an existing collection
			if (hostNode.closest('div.dt-button-collection').length) {
				hostNode = existingExpanded.eq(0);
			}

			close();
		}

		// Try to be smart about the layout
		var cnt = $('.dt-button', content).length;
		var mod = '';

		if (cnt === 3) {
			mod = 'dtb-b3';
		}
		else if (cnt === 2) {
			mod = 'dtb-b2';
		}
		else if (cnt === 1) {
			mod = 'dtb-b1';
		}

		var display = $('<div/>')
			.addClass('dt-button-collection')
			.addClass(options.collectionLayout)
			.addClass(options.splitAlignClass)
			.addClass(mod)
			.css('display', 'none')
			.attr({
				'aria-modal': true,
				role: 'dialog'
			});

		content = $(content)
			.addClass(options.contentClassName)
			.attr('role', 'menu')
			.appendTo(display);

		hostNode.attr( 'aria-expanded', 'true' );

		if ( hostNode.parents('body')[0] !== document.body ) {
			hostNode = document.body.lastChild;
		}

		if ( options.popoverTitle ) {
			display.prepend('<div class="dt-button-collection-title">'+options.popoverTitle+'</div>');
		}
		else if ( options.collectionTitle ) {
			display.prepend('<div class="dt-button-collection-title">'+options.collectionTitle+'</div>');
		}

		if (options.closeButton) {
			display.prepend('<div class="dtb-popover-close">x</div>').addClass('dtb-collection-closeable')
		}

		_fadeIn( display.insertAfter( hostNode ), options.fade );

		var tableContainer = $( hostButton.table().container() );
		var position = display.css( 'position' );

		if ( options.span === 'container' || options.align === 'dt-container' ) {
			hostNode = hostNode.parent();
			display.css('width', tableContainer.width());
		}

		// Align the popover relative to the DataTables container
		// Useful for wide popovers such as SearchPanes
		if (position === 'absolute') {
			// Align relative to the host button
			var offsetParent = $(hostNode[0].offsetParent);
			var buttonPosition = hostNode.position();
			var buttonOffset = hostNode.offset();
			var tableSizes = offsetParent.offset();
			var containerPosition = offsetParent.position();
			var computed = window.getComputedStyle(offsetParent[0]);

			tableSizes.height = offsetParent.outerHeight();
			tableSizes.width = offsetParent.width() + parseFloat(computed.paddingLeft);
			tableSizes.right = tableSizes.left + tableSizes.width;
			tableSizes.bottom = tableSizes.top + tableSizes.height;

			// Set the initial position so we can read height / width
			var top = buttonPosition.top + hostNode.outerHeight();
			var left = buttonPosition.left;

			display.css( {
				top: top,
				left: left
			} );

			// Get the popover position
			computed = window.getComputedStyle(display[0]);
			var popoverSizes = display.offset();

			popoverSizes.height = display.outerHeight();
			popoverSizes.width = display.outerWidth();
			popoverSizes.right = popoverSizes.left + popoverSizes.width;
			popoverSizes.bottom = popoverSizes.top + popoverSizes.height;
			popoverSizes.marginTop = parseFloat(computed.marginTop);
			popoverSizes.marginBottom = parseFloat(computed.marginBottom);

			// First position per the class requirements - pop up and right align
			if (options.dropup) {
				top = buttonPosition.top - popoverSizes.height - popoverSizes.marginTop - popoverSizes.marginBottom;
			}

			if (options.align === 'button-right' || display.hasClass( options.rightAlignClassName )) {
				left = buttonPosition.left - popoverSizes.width + hostNode.outerWidth(); 
			}

			// Container alignment - make sure it doesn't overflow the table container
			if (options.align === 'dt-container' || options.align === 'container') {
				if (left < buttonPosition.left) {
					left = -buttonPosition.left;
				}

				if (left + popoverSizes.width > tableSizes.width) {
					left = tableSizes.width - popoverSizes.width;
				}
			}

			// Window adjustment
			if (containerPosition.left + left + popoverSizes.width > $(window).width()) {
				// Overflowing the document to the right
				left = $(window).width() - popoverSizes.width - containerPosition.left;
			}

			if (buttonOffset.left + left < 0) {
				// Off to the left of the document
				left = -buttonOffset.left;
			}

			if (containerPosition.top + top + popoverSizes.height > $(window).height() + $(window).scrollTop()) {
				// Pop up if otherwise we'd need the user to scroll down
				top = buttonPosition.top - popoverSizes.height - popoverSizes.marginTop - popoverSizes.marginBottom;
			}

			if (containerPosition.top + top < $(window).scrollTop()) {
				// Correction for when the top is beyond the top of the page
				top = buttonPosition.top + hostNode.outerHeight();
			}

			// Calculations all done - now set it
			display.css( {
				top: top,
				left: left
			} );
		}
		else {
			// Fix position - centre on screen
			var position = function () {
				var half = $(window).height() / 2;

				var top = display.height() / 2;
				if ( top > half ) {
					top = half;
				}

				display.css( 'marginTop', top*-1 );
			};

			position();

			$(window).on('resize.dtb-collection', function () {
				position();
			});
		}

		if ( options.background ) {
			Buttons.background(
				true,
				options.backgroundClassName,
				options.fade,
				options.backgroundHost || hostNode
			);
		}

		// This is bonkers, but if we don't have a click listener on the
		// background element, iOS Safari will ignore the body click
		// listener below. An empty function here is all that is
		// required to make it work...
		$('div.dt-button-background').on( 'click.dtb-collection', function () {} );

		if ( options.autoClose ) {
			setTimeout( function () {
				dt.on( 'buttons-action.b-internal', function (e, btn, dt, node) {
					if ( node[0] === hostNode[0] ) {
						return;
					}
					close();
				} );
			}, 0);
		}
		
		$(display).trigger('buttons-popover.dt');


		dt.on('destroy', close);

		setTimeout(function() {
			closed = false;
			$('body')
				.on( 'click.dtb-collection', function (e) {
					if (closed) {
						return;
					}

					// andSelf is deprecated in jQ1.8, but we want 1.7 compat
					var back = $.fn.addBack ? 'addBack' : 'andSelf';
					var parent = $(e.target).parent()[0];
	
					if (( ! $(e.target).parents()[back]().filter( content ).length  && !$(parent).hasClass('dt-buttons')) || $(e.target).hasClass('dt-button-background')) {
						close();
					}
				} )
				.on( 'keyup.dtb-collection', function (e) {
					if ( e.keyCode === 27 ) {
						close();
					}
				} )
				.on( 'keydown.dtb-collection', function (e) {
					// Focus trap for tab key
					var elements = $('a, button', content);
					var active = document.activeElement;

					if (e.keyCode !== 9) { // tab
						return;
					}

					if (elements.index(active) === -1) {
						// If current focus is not inside the popover
						elements.first().focus();
						e.preventDefault();
					}
					else if (e.shiftKey) {
						// Reverse tabbing order when shift key is pressed
						if (active === elements[0]) {
							elements.last().focus();
							e.preventDefault();
						}
					}
					else {
						if (active === elements.last()[0]) {
							elements.first().focus();
							e.preventDefault();
						}
					}
				} );
		}, 0);
	}
} );



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Statics
 */

/**
 * Show / hide a background layer behind a collection
 * @param  {boolean} Flag to indicate if the background should be shown or
 *   hidden 
 * @param  {string} Class to assign to the background
 * @static
 */
Buttons.background = function ( show, className, fade, insertPoint ) {
	if ( fade === undefined ) {
		fade = 400;
	}
	if ( ! insertPoint ) {
		insertPoint = document.body;
	}

	if ( show ) {
		_fadeIn(
			$('<div/>')
				.addClass( className )
				.css( 'display', 'none' )
				.insertAfter( insertPoint ),
			fade
		);
	}
	else {
		_fadeOut(
			$('div.'+className),
			fade,
			function () {
				$(this)
					.removeClass( className )
					.remove();
			}
		);
	}
};

/**
 * Instance selector - select Buttons instances based on an instance selector
 * value from the buttons assigned to a DataTable. This is only useful if
 * multiple instances are attached to a DataTable.
 * @param  {string|int|array} Instance selector - see `instance-selector`
 *   documentation on the DataTables site
 * @param  {array} Button instance array that was attached to the DataTables
 *   settings object
 * @return {array} Buttons instances
 * @static
 */
Buttons.instanceSelector = function ( group, buttons )
{
	if ( group === undefined || group === null ) {
		return $.map( buttons, function ( v ) {
			return v.inst;
		} );
	}

	var ret = [];
	var names = $.map( buttons, function ( v ) {
		return v.name;
	} );

	// Flatten the group selector into an array of single options
	var process = function ( input ) {
		if ( Array.isArray( input ) ) {
			for ( var i=0, ien=input.length ; i<ien ; i++ ) {
				process( input[i] );
			}
			return;
		}

		if ( typeof input === 'string' ) {
			if ( input.indexOf( ',' ) !== -1 ) {
				// String selector, list of names
				process( input.split(',') );
			}
			else {
				// String selector individual name
				var idx = $.inArray( input.trim(), names );

				if ( idx !== -1 ) {
					ret.push( buttons[ idx ].inst );
				}
			}
		}
		else if ( typeof input === 'number' ) {
			// Index selector
			ret.push( buttons[ input ].inst );
		}
		else if ( typeof input === 'object' ) {
			// Actual instance selector
			ret.push( input );
		}
	};
	
	process( group );

	return ret;
};

/**
 * Button selector - select one or more buttons from a selector input so some
 * operation can be performed on them.
 * @param  {array} Button instances array that the selector should operate on
 * @param  {string|int|node|jQuery|array} Button selector - see
 *   `button-selector` documentation on the DataTables site
 * @return {array} Array of objects containing `inst` and `idx` properties of
 *   the selected buttons so you know which instance each button belongs to.
 * @static
 */
Buttons.buttonSelector = function ( insts, selector )
{
	var ret = [];
	var nodeBuilder = function ( a, buttons, baseIdx ) {
		var button;
		var idx;

		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			button = buttons[i];

			if ( button ) {
				idx = baseIdx !== undefined ?
					baseIdx+i :
					i+'';

				a.push( {
					node: button.node,
					name: button.conf.name,
					idx:  idx
				} );

				if ( button.buttons ) {
					nodeBuilder( a, button.buttons, idx+'-' );
				}
			}
		}
	};

	var run = function ( selector, inst ) {
		var i, ien;
		var buttons = [];
		nodeBuilder( buttons, inst.s.buttons );

		var nodes = $.map( buttons, function (v) {
			return v.node;
		} );

		if ( Array.isArray( selector ) || selector instanceof $ ) {
			for ( i=0, ien=selector.length ; i<ien ; i++ ) {
				run( selector[i], inst );
			}
			return;
		}

		if ( selector === null || selector === undefined || selector === '*' ) {
			// Select all
			for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
				ret.push( {
					inst: inst,
					node: buttons[i].node
				} );
			}
		}
		else if ( typeof selector === 'number' ) {
			// Main button index selector
			if (inst.s.buttons[ selector ]) {
				ret.push( {
					inst: inst,
					node: inst.s.buttons[ selector ].node
				} );
			}
		}
		else if ( typeof selector === 'string' ) {
			if ( selector.indexOf( ',' ) !== -1 ) {
				// Split
				var a = selector.split(',');

				for ( i=0, ien=a.length ; i<ien ; i++ ) {
					run( a[i].trim(), inst );
				}
			}
			else if ( selector.match( /^\d+(\-\d+)*$/ ) ) {
				// Sub-button index selector
				var indexes = $.map( buttons, function (v) {
					return v.idx;
				} );

				ret.push( {
					inst: inst,
					node: buttons[ $.inArray( selector, indexes ) ].node
				} );
			}
			else if ( selector.indexOf( ':name' ) !== -1 ) {
				// Button name selector
				var name = selector.replace( ':name', '' );

				for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
					if ( buttons[i].name === name ) {
						ret.push( {
							inst: inst,
							node: buttons[i].node
						} );
					}
				}
			}
			else {
				// jQuery selector on the nodes
				$( nodes ).filter( selector ).each( function () {
					ret.push( {
						inst: inst,
						node: this
					} );
				} );
			}
		}
		else if ( typeof selector === 'object' && selector.nodeName ) {
			// Node selector
			var idx = $.inArray( selector, nodes );

			if ( idx !== -1 ) {
				ret.push( {
					inst: inst,
					node: nodes[ idx ]
				} );
			}
		}
	};


	for ( var i=0, ien=insts.length ; i<ien ; i++ ) {
		var inst = insts[i];

		run( selector, inst );
	}

	return ret;
};

/**
 * Default function used for formatting output data.
 * @param {*} str Data to strip
 */
Buttons.stripData = function ( str, config ) {
	if ( typeof str !== 'string' ) {
		return str;
	}

	// Always remove script tags
	str = str.replace( /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '' );

	// Always remove comments
	str = str.replace( /<!\-\-.*?\-\->/g, '' );

	if ( ! config || config.stripHtml ) {
		str = str.replace( /<[^>]*>/g, '' );
	}

	if ( ! config || config.trim ) {
		str = str.replace( /^\s+|\s+$/g, '' );
	}

	if ( ! config || config.stripNewlines ) {
		str = str.replace( /\n/g, ' ' );
	}

	if ( ! config || config.decodeEntities ) {
		_exportTextarea.innerHTML = str;
		str = _exportTextarea.value;
	}

	return str;
};


/**
 * Buttons defaults. For full documentation, please refer to the docs/option
 * directory or the DataTables site.
 * @type {Object}
 * @static
 */
Buttons.defaults = {
	buttons: [ 'copy', 'excel', 'csv', 'pdf', 'print' ],
	name: 'main',
	tabIndex: 0,
	dom: {
		container: {
			tag: 'div',
			className: 'dt-buttons'
		},
		collection: {
			tag: 'div',
			className: ''
		},
		button: {
			tag: 'button',
			className: 'dt-button',
			active: 'active',
			disabled: 'disabled',
			spacerClass: ''
		},
		buttonLiner: {
			tag: 'span',
			className: ''
		},
		split: {
			tag: 'div',
			className: 'dt-button-split',
		},
		splitWrapper: {
			tag: 'div',
			className: 'dt-btn-split-wrapper',
		},
		splitDropdown: {
			tag: 'button',
			text: '&#x25BC;',
			className: 'dt-btn-split-drop',
			align: 'split-right',
			splitAlignClass: 'dt-button-split-left'
		},
		splitDropdownButton: {
			tag: 'button',
			className: 'dt-btn-split-drop-button dt-button',
		},
		splitCollection: {
			tag: 'div',
			className: 'dt-button-split-collection',
		}
	}
};

/**
 * Version information
 * @type {string}
 * @static
 */
Buttons.version = '2.3.6';


$.extend( _dtButtons, {
	collection: {
		text: function ( dt ) {
			return dt.i18n( 'buttons.collection', 'Collection' );
		},
		className: 'buttons-collection',
		closeButton: false,
		init: function ( dt, button, config ) {
			button.attr( 'aria-expanded', false );
		},
		action: function ( e, dt, button, config ) {
			if ( config._collection.parents('body').length ) {
				this.popover(false, config);
			}
			else {
				this.popover(config._collection, config);
			}

			// When activated using a key - auto focus on the
			// first item in the popover
			if (e.type === 'keypress') {
				$('a, button', config._collection).eq(0).focus();
			}
		},
		attr: {
			'aria-haspopup': 'dialog'
		}
		// Also the popover options, defined in Buttons.popover
	},
	split: {
		text: function ( dt ) {
			return dt.i18n( 'buttons.split', 'Split' );
		},
		className: 'buttons-split',
		closeButton: false,
		init: function ( dt, button, config ) {
			return button.attr( 'aria-expanded', false );
		},
		action: function ( e, dt, button, config ) {
			this.popover(config._collection, config);
		},
		attr: {
			'aria-haspopup': 'dialog'
		}
		// Also the popover options, defined in Buttons.popover
	},
	copy: function ( dt, conf ) {
		if ( _dtButtons.copyHtml5 ) {
			return 'copyHtml5';
		}
	},
	csv: function ( dt, conf ) {
		if ( _dtButtons.csvHtml5 && _dtButtons.csvHtml5.available( dt, conf ) ) {
			return 'csvHtml5';
		}
	},
	excel: function ( dt, conf ) {
		if ( _dtButtons.excelHtml5 && _dtButtons.excelHtml5.available( dt, conf ) ) {
			return 'excelHtml5';
		}
	},
	pdf: function ( dt, conf ) {
		if ( _dtButtons.pdfHtml5 && _dtButtons.pdfHtml5.available( dt, conf ) ) {
			return 'pdfHtml5';
		}
	},
	pageLength: function ( dt ) {
		var lengthMenu = dt.settings()[0].aLengthMenu;
		var vals = [];
		var lang = [];
		var text = function ( dt ) {
			return dt.i18n( 'buttons.pageLength', {
				"-1": 'Show all rows',
				_:    'Show %d rows'
			}, dt.page.len() );
		};

		// Support for DataTables 1.x 2D array
		if (Array.isArray( lengthMenu[0] )) {
			vals = lengthMenu[0];
			lang = lengthMenu[1];
		}
		else {
			for (var i=0 ; i<lengthMenu.length ; i++) {
				var option = lengthMenu[i];

				// Support for DataTables 2 object in the array
				if ($.isPlainObject(option)) {
					vals.push(option.value);
					lang.push(option.label);
				}
				else {
					vals.push(option);
					lang.push(option);
				}
			}
		}

		return {
			extend: 'collection',
			text: text,
			className: 'buttons-page-length',
			autoClose: true,
			buttons: $.map( vals, function ( val, i ) {
				return {
					text: lang[i],
					className: 'button-page-length',
					action: function ( e, dt ) {
						dt.page.len( val ).draw();
					},
					init: function ( dt, node, conf ) {
						var that = this;
						var fn = function () {
							that.active( dt.page.len() === val );
						};

						dt.on( 'length.dt'+conf.namespace, fn );
						fn();
					},
					destroy: function ( dt, node, conf ) {
						dt.off( 'length.dt'+conf.namespace );
					}
				};
			} ),
			init: function ( dt, node, conf ) {
				var that = this;
				dt.on( 'length.dt'+conf.namespace, function () {
					that.text( conf.text );
				} );
			},
			destroy: function ( dt, node, conf ) {
				dt.off( 'length.dt'+conf.namespace );
			}
		};
	},
	spacer: {
		style: 'empty',
		spacer: true,
		text: function ( dt ) {
			return dt.i18n( 'buttons.spacer', '' );
		}
	}
} );


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * DataTables API
 *
 * For complete documentation, please refer to the docs/api directory or the
 * DataTables site
 */

// Buttons group and individual button selector
DataTable.Api.register( 'buttons()', function ( group, selector ) {
	// Argument shifting
	if ( selector === undefined ) {
		selector = group;
		group = undefined;
	}

	this.selector.buttonGroup = group;

	var res = this.iterator( true, 'table', function ( ctx ) {
		if ( ctx._buttons ) {
			return Buttons.buttonSelector(
				Buttons.instanceSelector( group, ctx._buttons ),
				selector
			);
		}
	}, true );

	res._groupSelector = group;
	return res;
} );

// Individual button selector
DataTable.Api.register( 'button()', function ( group, selector ) {
	// just run buttons() and truncate
	var buttons = this.buttons( group, selector );

	if ( buttons.length > 1 ) {
		buttons.splice( 1, buttons.length );
	}

	return buttons;
} );

// Active buttons
DataTable.Api.registerPlural( 'buttons().active()', 'button().active()', function ( flag ) {
	if ( flag === undefined ) {
		return this.map( function ( set ) {
			return set.inst.active( set.node );
		} );
	}

	return this.each( function ( set ) {
		set.inst.active( set.node, flag );
	} );
} );

// Get / set button action
DataTable.Api.registerPlural( 'buttons().action()', 'button().action()', function ( action ) {
	if ( action === undefined ) {
		return this.map( function ( set ) {
			return set.inst.action( set.node );
		} );
	}

	return this.each( function ( set ) {
		set.inst.action( set.node, action );
	} );
} );

// Collection control
DataTable.Api.registerPlural( 'buttons().collectionRebuild()', 'button().collectionRebuild()', function ( buttons ) {
	return this.each( function ( set ) {
		for(var i = 0; i < buttons.length; i++) {
			if(typeof buttons[i] === 'object') {
				buttons[i].parentConf = set;
			}
		}
		set.inst.collectionRebuild( set.node, buttons );
	} );
} );

// Enable / disable buttons
DataTable.Api.register( ['buttons().enable()', 'button().enable()'], function ( flag ) {
	return this.each( function ( set ) {
		set.inst.enable( set.node, flag );
	} );
} );

// Disable buttons
DataTable.Api.register( ['buttons().disable()', 'button().disable()'], function () {
	return this.each( function ( set ) {
		set.inst.disable( set.node );
	} );
} );

// Button index
DataTable.Api.register( 'button().index()', function () {
	var idx = null;

	this.each( function ( set ) {
		var res = set.inst.index( set.node );

		if (res !== null) {
			idx = res;
		}
	} );

	return idx;
} );

// Get button nodes
DataTable.Api.registerPlural( 'buttons().nodes()', 'button().node()', function () {
	var jq = $();

	// jQuery will automatically reduce duplicates to a single entry
	$( this.each( function ( set ) {
		jq = jq.add( set.inst.node( set.node ) );
	} ) );

	return jq;
} );

// Get / set button processing state
DataTable.Api.registerPlural( 'buttons().processing()', 'button().processing()', function ( flag ) {
	if ( flag === undefined ) {
		return this.map( function ( set ) {
			return set.inst.processing( set.node );
		} );
	}

	return this.each( function ( set ) {
		set.inst.processing( set.node, flag );
	} );
} );

// Get / set button text (i.e. the button labels)
DataTable.Api.registerPlural( 'buttons().text()', 'button().text()', function ( label ) {
	if ( label === undefined ) {
		return this.map( function ( set ) {
			return set.inst.text( set.node );
		} );
	}

	return this.each( function ( set ) {
		set.inst.text( set.node, label );
	} );
} );

// Trigger a button's action
DataTable.Api.registerPlural( 'buttons().trigger()', 'button().trigger()', function () {
	return this.each( function ( set ) {
		set.inst.node( set.node ).trigger( 'click' );
	} );
} );

// Button resolver to the popover
DataTable.Api.register( 'button().popover()', function (content, options) {
	return this.map( function ( set ) {
		return set.inst._popover( content, this.button(this[0].node), options );
	} );
} );

// Get the container elements
DataTable.Api.register( 'buttons().containers()', function () {
	var jq = $();
	var groupSelector = this._groupSelector;

	// We need to use the group selector directly, since if there are no buttons
	// the result set will be empty
	this.iterator( true, 'table', function ( ctx ) {
		if ( ctx._buttons ) {
			var insts = Buttons.instanceSelector( groupSelector, ctx._buttons );

			for ( var i=0, ien=insts.length ; i<ien ; i++ ) {
				jq = jq.add( insts[i].container() );
			}
		}
	} );

	return jq;
} );

DataTable.Api.register( 'buttons().container()', function () {
	// API level of nesting is `buttons()` so we can zip into the containers method
	return this.containers().eq(0);
} );

// Add a new button
DataTable.Api.register( 'button().add()', function ( idx, conf, draw ) {
	var ctx = this.context;

	// Don't use `this` as it could be empty - select the instances directly
	if ( ctx.length ) {
		var inst = Buttons.instanceSelector( this._groupSelector, ctx[0]._buttons );

		if ( inst.length ) {
			inst[0].add( conf, idx , draw);
		}
	}

	return this.button( this._groupSelector, idx );
} );

// Destroy the button sets selected
DataTable.Api.register( 'buttons().destroy()', function () {
	this.pluck( 'inst' ).unique().each( function ( inst ) {
		inst.destroy();
	} );

	return this;
} );

// Remove a button
DataTable.Api.registerPlural( 'buttons().remove()', 'buttons().remove()', function () {
	this.each( function ( set ) {
		set.inst.remove( set.node );
	} );

	return this;
} );

// Information box that can be used by buttons
var _infoTimer;
DataTable.Api.register( 'buttons.info()', function ( title, message, time ) {
	var that = this;

	if ( title === false ) {
		this.off('destroy.btn-info');
		_fadeOut(
			$('#datatables_buttons_info'),
			400,
			function () {
				$(this).remove();
			}
		);
		clearTimeout( _infoTimer );
		_infoTimer = null;

		return this;
	}

	if ( _infoTimer ) {
		clearTimeout( _infoTimer );
	}

	if ( $('#datatables_buttons_info').length ) {
		$('#datatables_buttons_info').remove();
	}

	title = title ? '<h2>'+title+'</h2>' : '';

	_fadeIn(
		$('<div id="datatables_buttons_info" class="dt-button-info"/>')
			.html( title )
			.append( $('<div/>')[ typeof message === 'string' ? 'html' : 'append' ]( message ) )
			.css( 'display', 'none' )
			.appendTo( 'body' )
	);

	if ( time !== undefined && time !== 0 ) {
		_infoTimer = setTimeout( function () {
			that.buttons.info( false );
		}, time );
	}

	this.on('destroy.btn-info', function () {
		that.buttons.info(false);
	});

	return this;
} );

// Get data from the table for export - this is common to a number of plug-in
// buttons so it is included in the Buttons core library
DataTable.Api.register( 'buttons.exportData()', function ( options ) {
	if ( this.context.length ) {
		return _exportData( new DataTable.Api( this.context[0] ), options );
	}
} );

// Get information about the export that is common to many of the export data
// types (DRY)
DataTable.Api.register( 'buttons.exportInfo()', function ( conf ) {
	if ( ! conf ) {
		conf = {};
	}

	return {
		filename: _filename( conf ),
		title: _title( conf ),
		messageTop: _message(this, conf.message || conf.messageTop, 'top'),
		messageBottom: _message(this, conf.messageBottom, 'bottom')
	};
} );



/**
 * Get the file name for an exported file.
 *
 * @param {object}	config Button configuration
 * @param {boolean} incExtension Include the file name extension
 */
var _filename = function ( config )
{
	// Backwards compatibility
	var filename = config.filename === '*' && config.title !== '*' && config.title !== undefined && config.title !== null && config.title !== '' ?
		config.title :
		config.filename;

	if ( typeof filename === 'function' ) {
		filename = filename();
	}

	if ( filename === undefined || filename === null ) {
		return null;
	}

	if ( filename.indexOf( '*' ) !== -1 ) {
		filename = filename.replace( '*', $('head > title').text() ).trim();
	}

	// Strip characters which the OS will object to
	filename = filename.replace(/[^a-zA-Z0-9_\u00A1-\uFFFF\.,\-_ !\(\)]/g, "");

	var extension = _stringOrFunction( config.extension );
	if ( ! extension ) {
		extension = '';
	}

	return filename + extension;
};

/**
 * Simply utility method to allow parameters to be given as a function
 *
 * @param {undefined|string|function} option Option
 * @return {null|string} Resolved value
 */
var _stringOrFunction = function ( option )
{
	if ( option === null || option === undefined ) {
		return null;
	}
	else if ( typeof option === 'function' ) {
		return option();
	}
	return option;
};

/**
 * Get the title for an exported file.
 *
 * @param {object} config	Button configuration
 */
var _title = function ( config )
{
	var title = _stringOrFunction( config.title );

	return title === null ?
		null : title.indexOf( '*' ) !== -1 ?
			title.replace( '*', $('head > title').text() || 'Exported data' ) :
			title;
};

var _message = function ( dt, option, position )
{
	var message = _stringOrFunction( option );
	if ( message === null ) {
		return null;
	}

	var caption = $('caption', dt.table().container()).eq(0);
	if ( message === '*' ) {
		var side = caption.css( 'caption-side' );
		if ( side !== position ) {
			return null;
		}

		return caption.length ?
			caption.text() :
			'';
	}

	return message;
};




var _exportTextarea = $('<textarea/>')[0];
var _exportData = function ( dt, inOpts )
{
	var config = $.extend( true, {}, {
		rows:           null,
		columns:        '',
		modifier:       {
			search: 'applied',
			order:  'applied'
		},
		orthogonal:     'display',
		stripHtml:      true,
		stripNewlines:  true,
		decodeEntities: true,
		trim:           true,
		format:         {
			header: function ( d ) {
				return Buttons.stripData( d, config );
			},
			footer: function ( d ) {
				return Buttons.stripData( d, config );
			},
			body: function ( d ) {
				return Buttons.stripData( d, config );
			}
		},
		customizeData: null
	}, inOpts );

	var header = dt.columns( config.columns ).indexes().map( function (idx) {
		var el = dt.column( idx ).header();
		return config.format.header( el.innerHTML, idx, el );
	} ).toArray();

	var footer = dt.table().footer() ?
		dt.columns( config.columns ).indexes().map( function (idx) {
			var el = dt.column( idx ).footer();
			return config.format.footer( el ? el.innerHTML : '', idx, el );
		} ).toArray() :
		null;
	
	// If Select is available on this table, and any rows are selected, limit the export
	// to the selected rows. If no rows are selected, all rows will be exported. Specify
	// a `selected` modifier to control directly.
	var modifier = $.extend( {}, config.modifier );
	if ( dt.select && typeof dt.select.info === 'function' && modifier.selected === undefined ) {
		if ( dt.rows( config.rows, $.extend( { selected: true }, modifier ) ).any() ) {
			$.extend( modifier, { selected: true } )
		}
	}

	var rowIndexes = dt.rows( config.rows, modifier ).indexes().toArray();
	var selectedCells = dt.cells( rowIndexes, config.columns );
	var cells = selectedCells
		.render( config.orthogonal )
		.toArray();
	var cellNodes = selectedCells
		.nodes()
		.toArray();

	var columns = header.length;
	var rows = columns > 0 ? cells.length / columns : 0;
	var body = [];
	var cellCounter = 0;

	for ( var i=0, ien=rows ; i<ien ; i++ ) {
		var row = [ columns ];

		for ( var j=0 ; j<columns ; j++ ) {
			row[j] = config.format.body( cells[ cellCounter ], i, j, cellNodes[ cellCounter ] );
			cellCounter++;
		}

		body[i] = row;
	}

	var data = {
		header: header,
		footer: footer,
		body:   body
	};

	if ( config.customizeData ) {
		config.customizeData( data );
	}

	return data;
};


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * DataTables interface
 */

// Attach to DataTables objects for global access
$.fn.dataTable.Buttons = Buttons;
$.fn.DataTable.Buttons = Buttons;



// DataTables creation - check if the buttons have been defined for this table,
// they will have been if the `B` option was used in `dom`, otherwise we should
// create the buttons instance here so they can be inserted into the document
// using the API. Listen for `init` for compatibility with pre 1.10.10, but to
// be removed in future.
$(document).on( 'init.dt plugin-init.dt', function (e, settings) {
	if ( e.namespace !== 'dt' ) {
		return;
	}

	var opts = settings.oInit.buttons || DataTable.defaults.buttons;

	if ( opts && ! settings._buttons ) {
		new Buttons( settings, opts ).container();
	}
} );

function _init ( settings, options ) {
	var api = new DataTable.Api( settings );
	var opts = options
		? options
		: api.init().buttons || DataTable.defaults.buttons;

	return new Buttons( api, opts ).container();
}

// DataTables `dom` feature option
DataTable.ext.feature.push( {
	fnInit: _init,
	cFeature: "B"
} );

// DataTables 2 layout feature
if ( DataTable.ext.features ) {
	DataTable.ext.features.register( 'buttons', _init );
}


return DataTable;
}));


/*! Bootstrap integration for DataTables' Buttons
 * ©2016 SpryMedia Ltd - datatables.net/license
 */

(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net-bs5', 'datatables.net-buttons'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		var jq = require('jquery');
		var cjsRequires = function (root, $) {
			if ( ! $.fn.dataTable ) {
				require('datatables.net-bs5')(root, $);
			}

			if ( ! $.fn.dataTable.Buttons ) {
				require('datatables.net-buttons')(root, $);
			}
		};

		if (typeof window !== 'undefined') {
			module.exports = function (root, $) {
				if ( ! root ) {
					// CommonJS environments without a window global must pass a
					// root. This will give an error otherwise
					root = window;
				}

				if ( ! $ ) {
					$ = jq( root );
				}

				cjsRequires( root, $ );
				return factory( $, root, root.document );
			};
		}
		else {
			cjsRequires( window, jq );
			module.exports = factory( jq, window, window.document );
		}
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;



$.extend( true, DataTable.Buttons.defaults, {
	dom: {
		container: {
			className: 'dt-buttons btn-group flex-wrap'
		},
		button: {
			className: 'btn btn-secondary'
		},
		collection: {
			tag: 'div',
			className: 'dropdown-menu',
			closeButton: false,
			button: {
				tag: 'a',
				className: 'dt-button dropdown-item',
				active: 'active',
				disabled: 'disabled'
			}
		},
		splitWrapper: {
			tag: 'div',
			className: 'dt-btn-split-wrapper btn-group',
			closeButton: false,
		},
		splitDropdown: {
			tag: 'button',
			text: '',
			className: 'btn btn-secondary dt-btn-split-drop dropdown-toggle dropdown-toggle-split',
			closeButton: false,
			align: 'split-left',
			splitAlignClass: 'dt-button-split-left'
		},
		splitDropdownButton: {
			tag: 'button',
			className: 'dt-btn-split-drop-button btn btn-secondary',
			closeButton: false
		}
	},
	buttonCreated: function ( config, button ) {
		return config.buttons ?
			$('<div class="btn-group"/>').append(button) :
			button;
	}
} );

DataTable.ext.buttons.collection.className += ' dropdown-toggle';
DataTable.ext.buttons.collection.rightAlignClassName = 'dropdown-menu-right';


return DataTable;
}));


/*! DateTime picker for DataTables.net v1.4.1
 *
 * © SpryMedia Ltd, all rights reserved.
 * License: MIT datatables.net/license/mit
 */

(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		var jq = require('jquery');
		var cjsRequires = function (root, $) {		};

		if (typeof window === 'undefined') {
			module.exports = function (root, $) {
				if ( ! root ) {
					// CommonJS environments without a window global must pass a
					// root. This will give an error otherwise
					root = window;
				}

				if ( ! $ ) {
					$ = jq( root );
				}

				cjsRequires( root, $ );
				return factory( $, root, root.document );
			};
		}
		else {
			cjsRequires( window, jq );
			module.exports = factory( jq, window, window.document );
		}
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';



/**
 * @summary     DateTime picker for DataTables.net
 * @version     1.4.1
 * @file        dataTables.dateTime.js
 * @author      SpryMedia Ltd
 * @contact     www.datatables.net/contact
 */

// Supported formatting and parsing libraries:
// * Moment
// * Luxon
// * DayJS
var dateLib;

/*
 * This file provides a DateTime GUI picker (calendar and time input). Only the
 * format YYYY-MM-DD is supported without additional software, but the end user
 * experience can be greatly enhanced by including the momentjs, dayjs or luxon library
 * which provide date / time parsing and formatting options.
 *
 * This functionality is required because the HTML5 date and datetime input
 * types are not widely supported in desktop browsers.
 *
 * Constructed by using:
 *
 *     new DateTime( input, opts )
 *
 * where `input` is the HTML input element to use and `opts` is an object of
 * options based on the `DateTime.defaults` object.
 */
var DateTime = function ( input, opts ) {
	// Check if called with a window or jQuery object for DOM less applications
	// This is for backwards compatibility with CommonJS loader
	if (DateTime.factory(input, opts)) {
		return DateTime;
	}

	// Attempt to auto detect the formatting library (if there is one). Having it in
	// the constructor allows load order independence.
	if (typeof dateLib === 'undefined') {
		dateLib = window.moment
			? window.moment
			: window.dayjs
				? window.dayjs
				: window.luxon
					? window.luxon
					: null;
	}

	this.c = $.extend( true, {}, DateTime.defaults, opts );
	var classPrefix = this.c.classPrefix;
	var i18n = this.c.i18n;

	// Only IS8601 dates are supported without moment, dayjs or luxon
	if ( ! dateLib && this.c.format !== 'YYYY-MM-DD' ) {
		throw "DateTime: Without momentjs, dayjs or luxon only the format 'YYYY-MM-DD' can be used";
	}

	// Min and max need to be `Date` objects in the config
	if (typeof this.c.minDate === 'string') {
		this.c.minDate = new Date(this.c.minDate);
	}
	if (typeof this.c.maxDate === 'string') {
		this.c.maxDate = new Date(this.c.maxDate);
	}

	// DOM structure
	var structure = $(
		'<div class="'+classPrefix+'">'+
			'<div class="'+classPrefix+'-date">'+
				'<div class="'+classPrefix+'-title">'+
					'<div class="'+classPrefix+'-iconLeft">'+
						'<button type="button"></button>'+
					'</div>'+
					'<div class="'+classPrefix+'-iconRight">'+
						'<button type="button"></button>'+
					'</div>'+
					'<div class="'+classPrefix+'-label">'+
						'<span></span>'+
						'<select class="'+classPrefix+'-month"></select>'+
					'</div>'+
					'<div class="'+classPrefix+'-label">'+
						'<span></span>'+
						'<select class="'+classPrefix+'-year"></select>'+
					'</div>'+
				'</div>'+
				'<div class="'+classPrefix+'-buttons">'+
					'<a class="'+classPrefix+'-clear"></a>'+
					'<a class="'+classPrefix+'-today"></a>'+
				'</div>'+
				'<div class="'+classPrefix+'-calendar"></div>'+
			'</div>'+
			'<div class="'+classPrefix+'-time">'+
				'<div class="'+classPrefix+'-hours"></div>'+
				'<div class="'+classPrefix+'-minutes"></div>'+
				'<div class="'+classPrefix+'-seconds"></div>'+
			'</div>'+
			'<div class="'+classPrefix+'-error"></div>'+
		'</div>'
	);

	this.dom = {
		container: structure,
		date:      structure.find( '.'+classPrefix+'-date' ),
		title:     structure.find( '.'+classPrefix+'-title' ),
		calendar:  structure.find( '.'+classPrefix+'-calendar' ),
		time:      structure.find( '.'+classPrefix+'-time' ),
		error:     structure.find( '.'+classPrefix+'-error' ),
		buttons:   structure.find( '.'+classPrefix+'-buttons' ),
		clear:     structure.find( '.'+classPrefix+'-clear' ),
		today:     structure.find( '.'+classPrefix+'-today' ),
		previous:  structure.find( '.'+classPrefix+'-iconLeft' ),
		next:      structure.find( '.'+classPrefix+'-iconRight' ),
		input:     $(input)
	};

	this.s = {
		/** @type {Date} Date value that the picker has currently selected */
		d: null,

		/** @type {Date} Date of the calendar - might not match the value */
		display: null,

		/** @type {number} Used to select minutes in a range where the range base is itself unavailable */
		minutesRange: null,

		/** @type {number} Used to select minutes in a range where the range base is itself unavailable */
		secondsRange: null,

		/** @type {String} Unique namespace string for this instance */
		namespace: 'dateime-'+(DateTime._instance++),

		/** @type {Object} Parts of the picker that should be shown */
		parts: {
			date:    this.c.format.match( /[YMD]|L(?!T)|l/ ) !== null,
			time:    this.c.format.match( /[Hhm]|LT|LTS/ ) !== null,
			seconds: this.c.format.indexOf( 's' )   !== -1,
			hours12: this.c.format.match( /[haA]/ ) !== null
		}
	};

	this.dom.container
		.append( this.dom.date )
		.append( this.dom.time )
		.append( this.dom.error );

	this.dom.date
		.append( this.dom.title )
		.append( this.dom.buttons )
		.append( this.dom.calendar );

	this._constructor();
};

$.extend( DateTime.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Public
	 */
	
	/**
	 * Destroy the control
	 */
	destroy: function () {
		this._hide(true);
		this.dom.container.off().empty();
		this.dom.input
			.removeAttr('autocomplete')
			.off('.datetime');
	},

	errorMsg: function ( msg ) {
		var error = this.dom.error;

		if ( msg ) {
			error.html( msg );
		}
		else {
			error.empty();
		}

		return this;
	},

	hide: function () {
		this._hide();

		return this;
	},

	max: function ( date ) {
		this.c.maxDate = typeof date === 'string'
			? new Date(date)
			: date;

		this._optionsTitle();
		this._setCalander();

		return this;
	},

	min: function ( date ) {
		this.c.minDate = typeof date === 'string'
			? new Date(date)
			: date;

		this._optionsTitle();
		this._setCalander();

		return this;
	},

	/**
	 * Check if an element belongs to this control
	 *
	 * @param  {node} node Element to check
	 * @return {boolean}   true if owned by this control, false otherwise
	 */
	owns: function ( node ) {
		return $(node).parents().filter( this.dom.container ).length > 0;
	},

	/**
	 * Get / set the value
	 *
	 * @param  {string|Date} set   Value to set
	 * @param  {boolean} [write=true] Flag to indicate if the formatted value
	 *   should be written into the input element
	 */
	val: function ( set, write ) {
		if ( set === undefined ) {
			return this.s.d;
		}

		if ( set instanceof Date ) {
			this.s.d = this._dateToUtc( set );
		}
		else if ( set === null || set === '' ) {
			this.s.d = null;
		}
		else if ( set === '--now' ) {
			this.s.d = this._dateToUtc(new Date());
		}
		else if ( typeof set === 'string' ) {
			this.s.d = this._dateToUtc(
				this._convert(set, this.c.format, null)
			);
		}

		if ( write || write === undefined ) {
			if ( this.s.d ) {
				this._writeOutput();
			}
			else {
				// The input value was not valid...
				this.dom.input.val( set );
			}
		}

		// Need something to display
		this.s.display = this.s.d
			? new Date( this.s.d.toString() )
			: new Date();

		// Set the day of the month to be 1 so changing between months doesn't
        // run into issues when going from day 31 to 28 (for example)
		this.s.display.setUTCDate( 1 );

		// Update the display elements for the new value
		this._setTitle();
		this._setCalander();
		this._setTime();

		return this;
	},

	/**
	 * Similar to `val()` but uses a given date / time format
	 *
	 * @param format Format to get the data as (getter) or that is input (setter)
	 * @param val Value to write (if undefined, used as a getter)
	 * @returns 
	 */
	valFormat: function (format, val) {
		if (! val) {
			return this._convert(this.val(), null, format);
		}

		// Convert from the format given here to the instance's configured format
		this.val(
			this._convert(val, format, null)
		);

		return this;
	},

	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */
	
	/**
	 * Build the control and assign initial event handlers
	 *
	 * @private
	 */
	_constructor: function () {
		var that = this;
		var classPrefix = this.c.classPrefix;
		var last = this.dom.input.val();

		var onChange = function () {
			var curr = that.dom.input.val();

			if (curr !== last) {
				that.c.onChange.call( that, curr, that.s.d, that.dom.input );
				last = curr;
			}
		};

		if ( ! this.s.parts.date ) {
			this.dom.date.css( 'display', 'none' );
		}

		if ( ! this.s.parts.time ) {
			this.dom.time.css( 'display', 'none' );
		}

		if ( ! this.s.parts.seconds ) {
			this.dom.time.children('div.'+classPrefix+'-seconds').remove();
			this.dom.time.children('span').eq(1).remove();
		}

		if ( ! this.c.buttons.clear ) {
			this.dom.clear.css( 'display', 'none' );
		}

		if ( ! this.c.buttons.today ) {
			this.dom.today.css( 'display', 'none' );
		}

		// Render the options
		this._optionsTitle();

		$(document).on('i18n.dt', function (e, settings) {
			if (settings.oLanguage.datetime) {
				$.extend(true, that.c.i18n, settings.oLanguage.datetime);
				that._optionsTitle();
			}
		});

		// When attached to a hidden input, we always show the input picker, and
		// do so inline
		if (this.dom.input.attr('type') === 'hidden') {
			this.dom.container.addClass('inline');
			this.c.attachTo = 'input';

			this.val( this.dom.input.val(), false );
			this._show();
		}

		// Set the initial value
		if (last) {
			this.val( last, false );
		}

		// Trigger the display of the widget when clicking or focusing on the
		// input element
		this.dom.input
			.attr('autocomplete', 'off')
			.on('focus.datetime click.datetime', function () {
				// If already visible - don't do anything
				if ( that.dom.container.is(':visible') || that.dom.input.is(':disabled') ) {
					return;
				}

				// In case the value has changed by text
				that.val( that.dom.input.val(), false );

				that._show();
			} )
			.on('keyup.datetime', function () {
				// Update the calendar's displayed value as the user types
				if ( that.dom.container.is(':visible') ) {
					that.val( that.dom.input.val(), false );
				}
			} );

		// Main event handlers for input in the widget
		this.dom.container
			.on( 'change', 'select', function () {
				var select = $(this);
				var val = select.val();

				if ( select.hasClass(classPrefix+'-month') ) {
					// Month select
					that._correctMonth( that.s.display, val );
					that._setTitle();
					that._setCalander();
				}
				else if ( select.hasClass(classPrefix+'-year') ) {
					// Year select
					that.s.display.setUTCFullYear( val );
					that._setTitle();
					that._setCalander();
				}
				else if ( select.hasClass(classPrefix+'-hours') || select.hasClass(classPrefix+'-ampm') ) {
					// Hours - need to take account of AM/PM input if present
					if ( that.s.parts.hours12 ) {
						var hours = $(that.dom.container).find('.'+classPrefix+'-hours').val() * 1;
						var pm = $(that.dom.container).find('.'+classPrefix+'-ampm').val() === 'pm';

						that.s.d.setUTCHours( hours === 12 && !pm ?
							0 :
							pm && hours !== 12 ?
								hours + 12 :
								hours
						);
					}
					else {
						that.s.d.setUTCHours( val );
					}

					that._setTime();
					that._writeOutput( true );

					onChange();
				}
				else if ( select.hasClass(classPrefix+'-minutes') ) {
					// Minutes select
					that.s.d.setUTCMinutes( val );
					that._setTime();
					that._writeOutput( true );

					onChange();
				}
				else if ( select.hasClass(classPrefix+'-seconds') ) {
					// Seconds select
					that.s.d.setSeconds( val );
					that._setTime();
					that._writeOutput( true );

					onChange();
				}

				that.dom.input.focus();
				that._position();
			} )
			.on( 'click', function (e) {
				var d = that.s.d;
				var nodeName = e.target.nodeName.toLowerCase();
				var target = nodeName === 'span' ?
					e.target.parentNode :
					e.target;

				nodeName = target.nodeName.toLowerCase();

				if ( nodeName === 'select' ) {
					return;
				}

				e.stopPropagation();

				if ( nodeName === 'a' ) {
					e.preventDefault();

					if ($(target).hasClass(classPrefix+'-clear')) {
						// Clear the value and don't change the display
						that.s.d = null;
						that.dom.input.val('');
						that._writeOutput();
						that._setCalander();
						that._setTime();

						onChange();
					}
					else if ($(target).hasClass(classPrefix+'-today')) {
						// Don't change the value, but jump to the month
						// containing today
						that.s.display = new Date();

						that._setTitle();
						that._setCalander();
					}
				}
				if ( nodeName === 'button' ) {
					var button = $(target);
					var parent = button.parent();

					if ( parent.hasClass('disabled') && ! parent.hasClass('range') ) {
						button.blur();
						return;
					}

					if ( parent.hasClass(classPrefix+'-iconLeft') ) {
						// Previous month
						that.s.display.setUTCMonth( that.s.display.getUTCMonth()-1 );
						that._setTitle();
						that._setCalander();

						that.dom.input.focus();
					}
					else if ( parent.hasClass(classPrefix+'-iconRight') ) {
						// Next month
						that._correctMonth( that.s.display, that.s.display.getUTCMonth()+1 );
						that._setTitle();
						that._setCalander();

						that.dom.input.focus();
					}
					else if ( button.parents('.'+classPrefix+'-time').length ) {
						var val = button.data('value');
						var unit = button.data('unit');

						d = that._needValue();

						if ( unit === 'minutes' ) {
							if ( parent.hasClass('disabled') && parent.hasClass('range') ) {
								that.s.minutesRange = val;
								that._setTime();
								return;
							}
							else {
								that.s.minutesRange = null;
							}
						}

						if ( unit === 'seconds' ) {
							if ( parent.hasClass('disabled') && parent.hasClass('range') ) {
								that.s.secondsRange = val;
								that._setTime();
								return;
							}
							else {
								that.s.secondsRange = null;
							}
						}

						// Specific to hours for 12h clock
						if ( val === 'am' ) {
							if ( d.getUTCHours() >= 12 ) {
								val = d.getUTCHours() - 12;
							}
							else {
								return;
							}
						}
						else if ( val === 'pm' ) {
							if ( d.getUTCHours() < 12 ) {
								val = d.getUTCHours() + 12;
							}
							else {
								return;
							}
						}

						var set = unit === 'hours' ?
							'setUTCHours' :
							unit === 'minutes' ?
								'setUTCMinutes' :
								'setSeconds';

						d[set]( val );
						that._setCalander();
						that._setTime();
						that._writeOutput( true );
						onChange();
					}
					else {
						// Calendar click
						d = that._needValue();

						// Can't be certain that the current day will exist in
						// the new month, and likewise don't know that the
						// new day will exist in the old month, But 1 always
						// does, so we can change the month without worry of a
						// recalculation being done automatically by `Date`
						d.setUTCDate( 1 );
						d.setUTCFullYear( button.data('year') );
						d.setUTCMonth( button.data('month') );
						d.setUTCDate( button.data('day') );

						that._writeOutput( true );

						// Don't hide if there is a time picker, since we want to
						// be able to select a time as well.
						if ( ! that.s.parts.time ) {
							// This is annoying but IE has some kind of async
							// behaviour with focus and the focus from the above
							// write would occur after this hide - resulting in the
							// calendar opening immediately
							setTimeout( function () {
								that._hide();
							}, 10 );
						}
						else {
							that._setCalander();
							that._setTime();
						}

						onChange();
					}
				}
				else {
					// Click anywhere else in the widget - return focus to the
					// input element
					that.dom.input.focus();
				}
			} );
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private
	 */

	/**
	 * Compare the date part only of two dates - this is made super easy by the
	 * toDateString method!
	 *
	 * @param  {Date} a Date 1
	 * @param  {Date} b Date 2
	 * @private
	 */
	_compareDates: function( a, b ) {
		// Can't use toDateString as that converts to local time
		// luxon uses different method names so need to be able to call them
		return this._isLuxon()
			? dateLib.DateTime.fromJSDate(a).toUTC().toISODate() === dateLib.DateTime.fromJSDate(b).toUTC().toISODate()
			: this._dateToUtcString(a) === this._dateToUtcString(b);
	},

	/**
	 * Convert from one format to another
	 *
	 * @param {string|Date} val Value 
	 * @param {string|null} from Format to convert from. If null a `Date` must be given
	 * @param {string|null} to Format to convert to. If null a `Date` will be returned
	 * @returns {string|Date} Converted value
	 */
	_convert: function(val, from, to) {
		if (! val) {
			return val;
		}

		if (! dateLib) {
			// Note that in here from and to can either be null or YYYY-MM-DD
			// They cannot be anything else
			if ((! from && ! to) || (from && to)) {
				// No conversion
				return val;
			}
			else if (! from) {
				// Date in, string back
				return val.getUTCFullYear() +'-'+
					this._pad(val.getUTCMonth() + 1) +'-'+
					this._pad(val.getUTCDate());
			}
			else { // (! to)
				// String in, date back
				var match = val.match(/(\d{4})\-(\d{2})\-(\d{2})/ );
				return match ?
					new Date( match[1], match[2]-1, match[3] ) :
					null;
			}
		}
		else if (this._isLuxon()) {
			// Luxon
			var dtLux = val instanceof Date
				? dateLib.DateTime.fromJSDate(val).toUTC()
				: dateLib.DateTime.fromFormat(val, from);

			if (! dtLux.isValid) {
				return null;
			}

			return to
				? dtLux.toFormat(to)
				: dtLux.toJSDate();
		}
		else {
			// Moment / DayJS
			var dtMo = val instanceof Date
				? dateLib.utc( val, undefined, this.c.locale, this.c.strict )
				: dateLib( val, from, this.c.locale, this.c.strict );
			
			if (! dtMo.isValid()) {
				return null;
			}

			return to
				? dtMo.format(to)
				: dtMo.toDate();
		}
	},

	/**
	 * When changing month, take account of the fact that some months don't have
	 * the same number of days. For example going from January to February you
	 * can have the 31st of Jan selected and just add a month since the date
	 * would still be 31, and thus drop you into March.
	 *
	 * @param  {Date} date  Date - will be modified
	 * @param  {integer} month Month to set
	 * @private
	 */
	_correctMonth: function ( date, month ) {
		var days = this._daysInMonth( date.getUTCFullYear(), month );
		var correctDays = date.getUTCDate() > days;

		date.setUTCMonth( month );

		if ( correctDays ) {
			date.setUTCDate( days );
			date.setUTCMonth( month );
		}
	},

	/**
	 * Get the number of days in a method. Based on
	 * http://stackoverflow.com/a/4881951 by Matti Virkkunen
	 *
	 * @param  {integer} year  Year
	 * @param  {integer} month Month (starting at 0)
	 * @private
	 */
	_daysInMonth: function ( year, month ) {
		// 
		var isLeap = ((year % 4) === 0 && ((year % 100) !== 0 || (year % 400) === 0));
		var months = [31, (isLeap ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

		return months[month];
	},

	/**
	 * Create a new date object which has the UTC values set to the local time.
	 * This allows the local time to be used directly for the library which
	 * always bases its calculations and display on UTC.
	 *
	 * @param  {Date} s Date to "convert"
	 * @return {Date}   Shifted date
	 */
	_dateToUtc: function ( s ) {
		if (! s) {
			return s;
		}

		return new Date( Date.UTC(
			s.getFullYear(), s.getMonth(), s.getDate(),
			s.getHours(), s.getMinutes(), s.getSeconds()
		) );
	},

	/**
	 * Create a UTC ISO8601 date part from a date object
	 *
	 * @param  {Date} d Date to "convert"
	 * @return {string} ISO formatted date
	 */
	_dateToUtcString: function ( d ) {
		// luxon uses different method names so need to be able to call them
		return this._isLuxon()
			? dateLib.DateTime.fromJSDate(d).toUTC().toISODate()
			: d.getUTCFullYear()+'-'+
				this._pad(d.getUTCMonth()+1)+'-'+
				this._pad(d.getUTCDate());
	},

	/**
	 * Hide the control and remove events related to its display
	 *
	 * @private
	 */
	_hide: function (destroy) {
		if (! destroy && this.dom.input.attr('type') === 'hidden') {
			return;
		}

		var namespace = this.s.namespace;

		this.dom.container.detach();

		$(window).off( '.'+namespace );
		$(document).off( 'keydown.'+namespace );
		$('div.dataTables_scrollBody').off( 'scroll.'+namespace );
		$('div.DTE_Body_Content').off( 'scroll.'+namespace );
		$('body').off( 'click.'+namespace );
		$(this.dom.input[0].offsetParent).off('.'+namespace);
	},

	/**
	 * Convert a 24 hour value to a 12 hour value
	 *
	 * @param  {integer} val 24 hour value
	 * @return {integer}     12 hour value
	 * @private
	 */
	_hours24To12: function ( val ) {
		return val === 0 ?
			12 :
			val > 12 ?
				val - 12 :
				val;
	},

	/**
	 * Generate the HTML for a single day in the calendar - this is basically
	 * and HTML cell with a button that has data attributes so we know what was
	 * clicked on (if it is clicked on) and a bunch of classes for styling.
	 *
	 * @param  {object} day Day object from the `_htmlMonth` method
	 * @return {string}     HTML cell
	 */
	_htmlDay: function( day )
	{
		if ( day.empty ) {
			return '<td class="empty"></td>';
		}

		var classes = [ 'selectable' ];
		var classPrefix = this.c.classPrefix;

		if ( day.disabled ) {
			classes.push( 'disabled' );
		}

		if ( day.today ) {
			classes.push( 'now' );
		}

		if ( day.selected ) {
			classes.push( 'selected' );
		}

		return '<td data-day="' + day.day + '" class="' + classes.join(' ') + '">' +
				'<button class="'+classPrefix+'-button '+classPrefix+'-day" type="button" ' +'data-year="' + day.year + '" data-month="' + day.month + '" data-day="' + day.day + '">' +
					'<span>'+day.day+'</span>'+
				'</button>' +
			'</td>';
	},


	/**
	 * Create the HTML for a month to be displayed in the calendar table.
	 * 
	 * Based upon the logic used in Pikaday - MIT licensed
	 * Copyright (c) 2014 David Bushell
	 * https://github.com/dbushell/Pikaday
	 *
	 * @param  {integer} year  Year
	 * @param  {integer} month Month (starting at 0)
	 * @return {string} Calendar month HTML
	 * @private
	 */
	_htmlMonth: function ( year, month ) {
		var now    = this._dateToUtc( new Date() ),
			days   = this._daysInMonth( year, month ),
			before = new Date( Date.UTC(year, month, 1) ).getUTCDay(),
			data   = [],
			row    = [];

		if ( this.c.firstDay > 0 ) {
			before -= this.c.firstDay;

			if (before < 0) {
				before += 7;
			}
		}

		var cells = days + before,
			after = cells;

		while ( after > 7 ) {
			after -= 7;
		}

		cells += 7 - after;

		var minDate = this.c.minDate;
		var maxDate = this.c.maxDate;

		if ( minDate ) {
			minDate.setUTCHours(0);
			minDate.setUTCMinutes(0);
			minDate.setSeconds(0);
		}

		if ( maxDate ) {
			maxDate.setUTCHours(23);
			maxDate.setUTCMinutes(59);
			maxDate.setSeconds(59);
		}

		for ( var i=0, r=0 ; i<cells ; i++ ) {
			var day      = new Date( Date.UTC(year, month, 1 + (i - before)) ),
				selected = this.s.d ? this._compareDates(day, this.s.d) : false,
				today    = this._compareDates(day, now),
				empty    = i < before || i >= (days + before),
				disabled = (minDate && day < minDate) ||
				           (maxDate && day > maxDate);

			var disableDays = this.c.disableDays;
			if ( Array.isArray( disableDays ) && $.inArray( day.getUTCDay(), disableDays ) !== -1 ) {
				disabled = true;
			}
			else if ( typeof disableDays === 'function' && disableDays( day ) === true ) {
				disabled = true;
			}

			var dayConfig = {
				day:      1 + (i - before),
				month:    month,
				year:     year,
				selected: selected,
				today:    today,
				disabled: disabled,
				empty:    empty
			};

			row.push( this._htmlDay(dayConfig) );

			if ( ++r === 7 ) {
				if ( this.c.showWeekNumber ) {
					row.unshift( this._htmlWeekOfYear(i - before, month, year) );
				}

				data.push( '<tr>'+row.join('')+'</tr>' );
				row = [];
				r = 0;
			}
		}

		var classPrefix = this.c.classPrefix;
		var className = classPrefix+'-table';
		if ( this.c.showWeekNumber ) {
			className += ' weekNumber';
		}

		// Show / hide month icons based on min/max
		if ( minDate ) {
			var underMin = minDate >= new Date( Date.UTC(year, month, 1, 0, 0, 0 ) );

			this.dom.title.find('div.'+classPrefix+'-iconLeft')
				.css( 'display', underMin ? 'none' : 'block' );
		}

		if ( maxDate ) {
			var overMax = maxDate < new Date( Date.UTC(year, month+1, 1, 0, 0, 0 ) );

			this.dom.title.find('div.'+classPrefix+'-iconRight')
				.css( 'display', overMax ? 'none' : 'block' );
		}

		return '<table class="'+className+'">' +
				'<thead>'+
					this._htmlMonthHead() +
				'</thead>'+
				'<tbody>'+
					data.join('') +
				'</tbody>'+
			'</table>';
	},

	/**
	 * Create the calendar table's header (week days)
	 *
	 * @return {string} HTML cells for the row
	 * @private
	 */
	_htmlMonthHead: function () {
		var a = [];
		var firstDay = this.c.firstDay;
		var i18n = this.c.i18n;

		// Take account of the first day shift
		var dayName = function ( day ) {
			day += firstDay;

			while (day >= 7) {
				day -= 7;
			}

			return i18n.weekdays[day];
		};
		
		// Empty cell in the header
		if ( this.c.showWeekNumber ) {
			a.push( '<th></th>' );
		}

		for ( var i=0 ; i<7 ; i++ ) {
			a.push( '<th>'+dayName( i )+'</th>' );
		}

		return a.join('');
	},

	/**
	 * Create a cell that contains week of the year - ISO8601
	 *
	 * Based on https://stackoverflow.com/questions/6117814/ and
	 * http://techblog.procurios.nl/k/n618/news/view/33796/14863/
	 *
	 * @param  {integer} d Day of month
	 * @param  {integer} m Month of year (zero index)
	 * @param  {integer} y Year
	 * @return {string}   
	 * @private
	 */
	_htmlWeekOfYear: function ( d, m, y ) {
		var date = new Date( y, m, d, 0, 0, 0, 0 );

		// First week of the year always has 4th January in it
		date.setDate( date.getDate() + 4 - (date.getDay() || 7) );

		var oneJan = new Date( y, 0, 1 );
		var weekNum = Math.ceil( ( ( (date - oneJan) / 86400000) + 1)/7 );

		return '<td class="'+this.c.classPrefix+'-week">' + weekNum + '</td>';
	},

	/**
	 * Determine if Luxon is being used
	 *
	 * @returns Flag for Luxon
	 */
	_isLuxon: function () {
		return dateLib && dateLib.DateTime && dateLib.Duration && dateLib.Settings
			? true
			: false;
	},

	/**
	 * Check if the instance has a date object value - it might be null.
	 * If is doesn't set one to now.
	 * @returns A Date object
	 * @private
	 */
	_needValue: function () {
		if ( ! this.s.d ) {
			this.s.d = this._dateToUtc( new Date() );

			if (! this.s.parts.time) {
				this.s.d.setUTCHours(0);
				this.s.d.setUTCMinutes(0);
				this.s.d.setSeconds(0);
				this.s.d.setMilliseconds(0);
			}
		}

		return this.s.d;
	},

	/**
	 * Create option elements from a range in an array
	 *
	 * @param  {string} selector Class name unique to the select element to use
	 * @param  {array} values   Array of values
	 * @param  {array} [labels] Array of labels. If given must be the same
	 *   length as the values parameter.
	 * @private
	 */
	_options: function ( selector, values, labels ) {
		if ( ! labels ) {
			labels = values;
		}

		var select = this.dom.container.find('select.'+this.c.classPrefix+'-'+selector);
		select.empty();

		for ( var i=0, ien=values.length ; i<ien ; i++ ) {
			select.append( '<option value="'+values[i]+'">'+labels[i]+'</option>' );
		}
	},

	/**
	 * Set an option and update the option's span pair (since the select element
	 * has opacity 0 for styling)
	 *
	 * @param  {string} selector Class name unique to the select element to use
	 * @param  {*}      val      Value to set
	 * @private
	 */
	_optionSet: function ( selector, val ) {
		var select = this.dom.container.find('select.'+this.c.classPrefix+'-'+selector);
		var span = select.parent().children('span');

		select.val( val );

		var selected = select.find('option:selected');
		span.html( selected.length !== 0 ?
			selected.text() :
			this.c.i18n.unknown
		);
	},

	/**
	 * Create time options list.
	 *
	 * @param  {string} unit Time unit - hours, minutes or seconds
	 * @param  {integer} count Count range - 12, 24 or 60
	 * @param  {integer} val Existing value for this unit
	 * @param  {integer[]} allowed Values allow for selection
	 * @param  {integer} range Override range
	 * @private
	 */
	_optionsTime: function ( unit, count, val, allowed, range ) {
		var classPrefix = this.c.classPrefix;
		var container = this.dom.container.find('div.'+classPrefix+'-'+unit);
		var i, j;
		var render = count === 12 ?
			function (i) { return i; } :
			this._pad;
		var classPrefix = this.c.classPrefix;
		var className = classPrefix+'-table';
		var i18n = this.c.i18n;

		if ( ! container.length ) {
			return;
		}

		var a = '';
		var span = 10;
		var button = function (value, label, className) {
			// Shift the value for PM
			if ( count === 12 && typeof value === 'number' ) {
				if (val >= 12 ) {
					value += 12;
				}

				if (value == 12) {
					value = 0;
				}
				else if (value == 24) {
					value = 12;
				}
			}

			var selected = val === value || (value === 'am' && val < 12) || (value === 'pm' && val >= 12) ?
				'selected' :
				'';
			
			if (typeof value === 'number' && allowed && $.inArray(value, allowed) === -1) {
				selected += ' disabled';
			}

			if ( className ) {
				selected += ' '+className;
			}

			return '<td class="selectable '+selected+'">' +
				'<button class="'+classPrefix+'-button '+classPrefix+'-day" type="button" data-unit="'+unit+'" data-value="'+value+ '">' +
					'<span>'+label+'</span>'+
				'</button>' +
			'</td>';
		}

		if ( count === 12 ) {
			// Hours with AM/PM
			a += '<tr>';
			
			for ( i=1 ; i<=6 ; i++ ) {
				a += button(i, render(i));
			}
			a += button('am', i18n.amPm[0]);

			a += '</tr>';
			a += '<tr>';

			for ( i=7 ; i<=12 ; i++ ) {
				a += button(i, render(i));
			}
			a += button('pm', i18n.amPm[1]);
			a += '</tr>';

			span = 7;
		}
		else if ( count === 24 ) {
			// Hours - 24
			var c = 0;
			for (j=0 ; j<4 ; j++ ) {
				a += '<tr>';
				for ( i=0 ; i<6 ; i++ ) {
					a += button(c, render(c));
					c++;
				}
				a += '</tr>';
			}

			span = 6;
		}
		else {
			// Minutes and seconds
			a += '<tr>';
			for (j=0 ; j<60 ; j+=10 ) {
				a += button(j, render(j), 'range');
			}
			a += '</tr>';
			
			// Slight hack to allow for the different number of columns
			a += '</tbody></thead><table class="'+className+' '+className+'-nospace"><tbody>';

			var start = range !== null
				? range
				: val === -1
					? 0
					: Math.floor( val / 10 )*10;

			a += '<tr>';
			for (j=start+1 ; j<start+10 ; j++ ) {
				a += button(j, render(j));
			}
			a += '</tr>';

			span = 6;
		}

		container
			.empty()
			.append(
				'<table class="'+className+'">'+
					'<thead><tr><th colspan="'+span+'">'+
						i18n[unit] +
					'</th></tr></thead>'+
					'<tbody>'+
						a+
					'</tbody>'+
				'</table>'
			);
	},

	/**
	 * Create the options for the month and year
	 *
	 * @param  {integer} year  Year
	 * @param  {integer} month Month (starting at 0)
	 * @private
	 */
	_optionsTitle: function () {
		var i18n = this.c.i18n;
		var min = this.c.minDate;
		var max = this.c.maxDate;
		var minYear = min ? min.getFullYear() : null;
		var maxYear = max ? max.getFullYear() : null;

		var i = minYear !== null ? minYear : new Date().getFullYear() - this.c.yearRange;
		var j = maxYear !== null ? maxYear : new Date().getFullYear() + this.c.yearRange;

		this._options( 'month', this._range( 0, 11 ), i18n.months );
		this._options( 'year', this._range( i, j ) );

		// Set the language strings in case any have changed
		this.dom.today.text(i18n.today).text(i18n.today);
		this.dom.clear.text(i18n.clear).text(i18n.clear);
		this.dom.previous
			.attr('title', i18n.previous)
			.children('button')
			.text(i18n.previous);
		this.dom.next
			.attr('title', i18n.next)
			.children('button')
			.text(i18n.next);
	},

	/**
	 * Simple two digit pad
	 *
	 * @param  {integer} i      Value that might need padding
	 * @return {string|integer} Padded value
	 * @private
	 */
	_pad: function ( i ) {
		return i<10 ? '0'+i : i;
	},

	/**
	 * Position the calendar to look attached to the input element
	 * @private
	 */
	_position: function () {
		var offset = this.c.attachTo === 'input' ? this.dom.input.position() : this.dom.input.offset();
		var container = this.dom.container;
		var inputHeight = this.dom.input.outerHeight();

		if (container.hasClass('inline')) {
			container.insertAfter( this.dom.input );
			return;
		}

		if ( this.s.parts.date && this.s.parts.time && $(window).width() > 550 ) {
			container.addClass('horizontal');
		}
		else {
			container.removeClass('horizontal');
		}

		if(this.c.attachTo === 'input') {
			container
				.css( {
					top: offset.top + inputHeight,
					left: offset.left
				} )
				.insertAfter( this.dom.input );
		}
		else {
			container
				.css( {
					top: offset.top + inputHeight,
					left: offset.left
				} )
				.appendTo( 'body' );
		}

		var calHeight = container.outerHeight();
		var calWidth = container.outerWidth();
		var scrollTop = $(window).scrollTop();

		// Correct to the bottom
		if ( offset.top + inputHeight + calHeight - scrollTop > $(window).height() ) {
			var newTop = offset.top - calHeight;

			container.css( 'top', newTop < 0 ? 0 : newTop );
		}

		// Correct to the right
		if ( calWidth + offset.left > $(window).width() ) {
			var newLeft = $(window).width() - calWidth;

			// Account for elements which are inside a position absolute element
			if (this.c.attachTo === 'input') {
				newLeft -= $(container).offsetParent().offset().left;
			}

			container.css( 'left', newLeft < 0 ? 0 : newLeft );
		}
	},

	/**
	 * Create a simple array with a range of values
	 *
	 * @param  {integer} start   Start value (inclusive)
	 * @param  {integer} end     End value (inclusive)
	 * @param  {integer} [inc=1] Increment value
	 * @return {array}           Created array
	 * @private
	 */
	_range: function ( start, end, inc ) {
		var a = [];

		if ( ! inc ) {
			inc = 1;
		}

		for ( var i=start ; i<=end ; i+=inc ) {
			a.push( i );
		}

		return a;
	},

	/**
	 * Redraw the calendar based on the display date - this is a destructive
	 * operation
	 *
	 * @private
	 */
	_setCalander: function () {
		if ( this.s.display ) {
			this.dom.calendar
				.empty()
				.append( this._htmlMonth(
					this.s.display.getUTCFullYear(),
					this.s.display.getUTCMonth()
				) );
		}
	},

	/**
	 * Set the month and year for the calendar based on the current display date
	 *
	 * @private
	 */
	_setTitle: function () {
		this._optionSet( 'month', this.s.display.getUTCMonth() );
		this._optionSet( 'year', this.s.display.getUTCFullYear() );
	},

	/**
	 * Set the time based on the current value of the widget
	 *
	 * @private
	 */
	_setTime: function () {
		var that = this;
		var d = this.s.d;
		
		// luxon uses different method names so need to be able to call them. This happens a few time later in this method too
		var luxDT = null
		if (this._isLuxon()) {
			luxDT = dateLib.DateTime.fromJSDate(d).toUTC();
		}

		var hours = luxDT != null
			? luxDT.hour
			: d
				? d.getUTCHours()
				: -1;

		var allowed = function ( prop ) { // Backwards compt with `Increment` option
			return that.c[prop+'Available'] ?
				that.c[prop+'Available'] :
				that._range( 0, 59, that.c[prop+'Increment'] );
		}

		this._optionsTime( 'hours', this.s.parts.hours12 ? 12 : 24, hours, this.c.hoursAvailable )
		this._optionsTime(
			'minutes',
			60,
			luxDT != null
				? luxDT.minute
				: d
					? d.getUTCMinutes()
					: -1,
			allowed('minutes'),
			this.s.minutesRange
		);
		this._optionsTime(
			'seconds',
			60,
			luxDT != null
				? luxDT.second
				: d
					? d.getSeconds()
					: -1,
			allowed('seconds'),
			this.s.secondsRange
		);
	},

	/**
	 * Show the widget and add events to the document required only while it
	 * is displayed
	 * 
	 * @private
	 */
	_show: function () {
		var that = this;
		var namespace = this.s.namespace;

		this._position();

		// Need to reposition on scroll
		$(window).on( 'scroll.'+namespace+' resize.'+namespace, function () {
			that._position();
		} );

		$('div.DTE_Body_Content').on( 'scroll.'+namespace, function () {
			that._position();
		} );

		$('div.dataTables_scrollBody').on( 'scroll.'+namespace, function () {
			that._position();
		} );

		var offsetParent = this.dom.input[0].offsetParent;

		if ( offsetParent !== document.body ) {
			$(offsetParent).on( 'scroll.'+namespace, function () {
				that._position();
			} );
		}

		// On tab focus will move to a different field (no keyboard navigation
		// in the date picker - this might need to be changed).
		$(document).on( 'keydown.'+namespace, function (e) {
			if (
				e.keyCode === 9  || // tab
				e.keyCode === 27 || // esc
				e.keyCode === 13    // return
			) {
				that._hide();
			}
		} );

		// Hide if clicking outside of the widget - but in a different click
		// event from the one that was used to trigger the show (bubble and
		// inline)
		setTimeout( function () {
			$('body').on( 'click.'+namespace, function (e) {
				var parents = $(e.target).parents();

				if ( ! parents.filter( that.dom.container ).length && e.target !== that.dom.input[0] ) {
					that._hide();
				}
			} );
		}, 10 );
	},

	/**
	 * Write the formatted string to the input element this control is attached
	 * to
	 *
	 * @private
	 */
	_writeOutput: function ( focus ) {
		var date = this.s.d;
		var out = '';

		if (date) {
			out = this._convert(date, null, this.c.format);
		}

		this.dom.input
			.val( out )
			.trigger('change', {write: date});
		
		if ( this.dom.input.attr('type') === 'hidden' ) {
			this.val(out, false);
		}

		if ( focus ) {
			this.dom.input.focus();
		}
	}
} );

/**
 * Use a specificmoment compatible date library
 */
DateTime.use = function (lib) {
	dateLib = lib;
};

/**
 * For generating unique namespaces
 *
 * @type {Number}
 * @private
 */
DateTime._instance = 0;

/**
 * To indicate to DataTables what type of library this is
 */
DateTime.type = 'DateTime';

/**
 * Defaults for the date time picker
 *
 * @type {Object}
 */
DateTime.defaults = {
	attachTo: 'body',

	buttons: {
		clear: false,
		today: false
	},

	// Not documented - could be an internal property
	classPrefix: 'dt-datetime',

	// function or array of ints
	disableDays: null,

	// first day of the week (0: Sunday, 1: Monday, etc)
	firstDay: 1,

	format: 'YYYY-MM-DD',

	hoursAvailable: null,

	i18n: {
		clear:    'Clear',
		previous: 'Previous',
		next:     'Next',
		months:   [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December' ],
		weekdays: [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ],
		amPm:     [ 'am', 'pm' ],
		hours:    'Hour',
		minutes:  'Minute',
		seconds:  'Second',
		unknown:  '-',
		today:    'Today'
	},

	maxDate: null,

	minDate: null,

	minutesAvailable: null,

	minutesIncrement: 1, // deprecated

	strict: true,

	locale: 'en',

	onChange: function () {},

	secondsAvailable: null,

	secondsIncrement: 1, // deprecated

	// show the ISO week number at the head of the row
	showWeekNumber: false,

	// overruled by max / min date
	yearRange: 25
};

DateTime.version = '1.4.1';

/**
 * CommonJS factory function pass through. Matches DataTables.
 * @param {*} root Window
 * @param {*} jq jQUery
 * @returns {boolean} Indicator
 */
DateTime.factory = function (root, jq) {
	var is = false;

	// Test if the first parameter is a window object
	if (root && root.document) {
		window = root;
		document = root.document;
	}

	// Test if the second parameter is a jQuery object
	if (jq && jq.fn && jq.fn.jquery) {
		$ = jq;
		is = true;
	}

	return is;
}

// Global export - if no conflicts
if (! window.DateTime) {
	window.DateTime = DateTime;
}

// Global DataTable
if (window.DataTable) {
	window.DataTable.DateTime = DateTime;
}

// Make available via jQuery
$.fn.dtDateTime = function (options) {
	return this.each(function() {
		new DateTime(this, options);
	});
}

// Attach to DataTables if present
if ($.fn.dataTable) {
	$.fn.dataTable.DateTime = DateTime;
	$.fn.DataTable.DateTime = DateTime;

	if ($.fn.dataTable.Editor) {
		$.fn.dataTable.Editor.DateTime = DateTime;
	}
}


return DateTime;
}));


/*! FixedHeader 3.3.2
 * © SpryMedia Ltd - datatables.net/license
 */

(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		var jq = require('jquery');
		var cjsRequires = function (root, $) {
			if ( ! $.fn.dataTable ) {
				require('datatables.net')(root, $);
			}
		};

		if (typeof window !== 'undefined') {
			module.exports = function (root, $) {
				if ( ! root ) {
					// CommonJS environments without a window global must pass a
					// root. This will give an error otherwise
					root = window;
				}

				if ( ! $ ) {
					$ = jq( root );
				}

				cjsRequires( root, $ );
				return factory( $, root, root.document );
			};
		}
		else {
			cjsRequires( window, jq );
			module.exports = factory( jq, window, window.document );
		}
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;



/**
 * @summary     FixedHeader
 * @description Fix a table's header or footer, so it is always visible while
 *              scrolling
 * @version     3.3.2
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk
 * @copyright   SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

var _instCounter = 0;

var FixedHeader = function ( dt, config ) {
	// Sanity check - you just know it will happen
	if ( ! (this instanceof FixedHeader) ) {
		throw "FixedHeader must be initialised with the 'new' keyword.";
	}

	// Allow a boolean true for defaults
	if ( config === true ) {
		config = {};
	}

	dt = new DataTable.Api( dt );

	this.c = $.extend( true, {}, FixedHeader.defaults, config );

	this.s = {
		dt: dt,
		position: {
			theadTop: 0,
			tbodyTop: 0,
			tfootTop: 0,
			tfootBottom: 0,
			width: 0,
			left: 0,
			tfootHeight: 0,
			theadHeight: 0,
			windowHeight: $(window).height(),
			visible: true
		},
		headerMode: null,
		footerMode: null,
		autoWidth: dt.settings()[0].oFeatures.bAutoWidth,
		namespace: '.dtfc'+(_instCounter++),
		scrollLeft: {
			header: -1,
			footer: -1
		},
		enable: true
	};

	this.dom = {
		floatingHeader: null,
		thead: $(dt.table().header()),
		tbody: $(dt.table().body()),
		tfoot: $(dt.table().footer()),
		header: {
			host: null,
			floating: null,
			floatingParent: $('<div class="dtfh-floatingparent">'),
			placeholder: null
		},
		footer: {
			host: null,
			floating: null,
			floatingParent: $('<div class="dtfh-floatingparent">'),
			placeholder: null
		}
	};

	this.dom.header.host = this.dom.thead.parent();
	this.dom.footer.host = this.dom.tfoot.parent();

	var dtSettings = dt.settings()[0];
	if ( dtSettings._fixedHeader ) {
		throw "FixedHeader already initialised on table "+dtSettings.nTable.id;
	}

	dtSettings._fixedHeader = this;

	this._constructor();
};


/*
 * Variable: FixedHeader
 * Purpose:  Prototype for FixedHeader
 * Scope:    global
 */
$.extend( FixedHeader.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * API methods
	 */

	/**
	 * Kill off FH and any events
	 */
	destroy: function () {
		var dom = this.dom;

		this.s.dt.off( '.dtfc' );
		$(window).off( this.s.namespace );

		// Remove clones of FC blockers
		if (dom.header.rightBlocker) {
			dom.header.rightBlocker.remove();
		}
		if (dom.header.leftBlocker) {
			dom.header.leftBlocker.remove();
		}
		if (dom.footer.rightBlocker) {
			dom.footer.rightBlocker.remove();
		}
		if (dom.footer.leftBlocker) {
			dom.footer.leftBlocker.remove();
		}

		if ( this.c.header ) {
			this._modeChange( 'in-place', 'header', true );
		}

		if ( this.c.footer && dom.tfoot.length ) {
			this._modeChange( 'in-place', 'footer', true );
		}
	},

	/**
	 * Enable / disable the fixed elements
	 *
	 * @param  {boolean} enable `true` to enable, `false` to disable
	 */
	enable: function ( enable, update )
	{
		this.s.enable = enable;

		if ( update || update === undefined ) {
			this._positions();
			this._scroll( true );
		}
	},

	/**
	 * Get enabled status
	 */
	enabled: function ()
	{
		return this.s.enable;
	},
	
	/**
	 * Set header offset 
	 *
	 * @param  {int} new value for headerOffset
	 */
	headerOffset: function ( offset )
	{
		if ( offset !== undefined ) {
			this.c.headerOffset = offset;
			this.update();
		}

		return this.c.headerOffset;
	},
	
	/**
	 * Set footer offset
	 *
	 * @param  {int} new value for footerOffset
	 */
	footerOffset: function ( offset )
	{
		if ( offset !== undefined ) {
			this.c.footerOffset = offset;
			this.update();
		}

		return this.c.footerOffset;
	},

	
	/**
	 * Recalculate the position of the fixed elements and force them into place
	 */
	update: function (force)
	{
		if (! this.s.enable) {
			return;
		}

		var table = this.s.dt.table().node();

		if ( $(table).is(':visible') ) {
			this.enable( true, false );
		}
		else {
			this.enable( false, false );
		}

		// Don't update if header is not in the document atm (due to
		// async events)
		if ($(table).children('thead').length === 0) {
			return;
		}

		this._positions();
		this._scroll( force !== undefined ? force : true );
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */
	
	/**
	 * FixedHeader constructor - adding the required event listeners and
	 * simple initialisation
	 *
	 * @private
	 */
	_constructor: function ()
	{
		var that = this;
		var dt = this.s.dt;

		$(window)
			.on( 'scroll'+this.s.namespace, function () {
				that._scroll();
			} )
			.on( 'resize'+this.s.namespace, DataTable.util.throttle( function () {
				that.s.position.windowHeight = $(window).height();
				that.update();
			}, 50 ) );

		var autoHeader = $('.fh-fixedHeader');
		if ( ! this.c.headerOffset && autoHeader.length ) {
			this.c.headerOffset = autoHeader.outerHeight();
		}

		var autoFooter = $('.fh-fixedFooter');
		if ( ! this.c.footerOffset && autoFooter.length ) {
			this.c.footerOffset = autoFooter.outerHeight();
		}

		dt
			.on( 'column-reorder.dt.dtfc column-visibility.dt.dtfc column-sizing.dt.dtfc responsive-display.dt.dtfc', function (e, ctx) {
				that.update();
			} )
			.on( 'draw.dt.dtfc', function (e, ctx) {
				// For updates from our own table, don't reclone, but for all others, do
				that.update(ctx === dt.settings()[0] ? false : true);
			} );

		dt.on( 'destroy.dtfc', function () {
			that.destroy();
		} );

		this._positions();
		this._scroll();
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods
	 */

	/**
	 * Clone a fixed item to act as a place holder for the original element
	 * which is moved into a clone of the table element, and moved around the
	 * document to give the fixed effect.
	 *
	 * @param  {string}  item  'header' or 'footer'
	 * @param  {boolean} force Force the clone to happen, or allow automatic
	 *   decision (reuse existing if available)
	 * @private
	 */
	_clone: function ( item, force )
	{
		var that = this;
		var dt = this.s.dt;
		var itemDom = this.dom[ item ];
		var itemElement = item === 'header' ?
			this.dom.thead :
			this.dom.tfoot;

		// If footer and scrolling is enabled then we don't clone
		// Instead the table's height is decreased accordingly - see `_scroll()`
		if (item === 'footer' && this._scrollEnabled()) {
			return;
		}	

		if ( ! force && itemDom.floating ) {
			// existing floating element - reuse it
			itemDom.floating.removeClass( 'fixedHeader-floating fixedHeader-locked' );
		}
		else {
			var docScrollLeft = $(document).scrollLeft();
			var docScrollTop = $(document).scrollTop();

			if ( itemDom.floating ) {
				if(itemDom.placeholder !== null) {
					itemDom.placeholder.remove();
				}
				this._unsize( item );
				itemDom.floating.children().detach();
				itemDom.floating.remove();
			}

			var tableNode = $(dt.table().node()); 
			var scrollBody = $(tableNode.parent());
			var scrollEnabled = this._scrollEnabled();

			itemDom.floating = $( dt.table().node().cloneNode( false ) )
				.attr( 'aria-hidden', 'true' )
				.css({
					'table-layout': 'fixed',
					top: 0,
					left: 0
				})
				.removeAttr( 'id' )
				.append( itemElement );

			itemDom.floatingParent
				.css({
					width: scrollBody.width(),
					overflow: 'hidden',
					height: 'fit-content',
					position: 'fixed',
					left: scrollEnabled ? tableNode.offset().left + scrollBody.scrollLeft() : 0
				})
				.css(
					item === 'header' ?
						{
							top: this.c.headerOffset,
							bottom: ''
						} :
						{
							top: '',
							bottom: this.c.footerOffset
						}
				)
				.addClass(item === 'footer' ? 'dtfh-floatingparentfoot' : 'dtfh-floatingparenthead')
				.append(itemDom.floating)
				.appendTo( 'body' );

			this._stickyPosition(itemDom.floating, '-');

			var scrollLeftUpdate = function () {
				var scrollLeft = scrollBody.scrollLeft()
				that.s.scrollLeft = {footer: scrollLeft, header: scrollLeft};
				itemDom.floatingParent.scrollLeft(that.s.scrollLeft.header);
			}

			scrollLeftUpdate();
			scrollBody
				.off('scroll.dtfh')
				.on('scroll.dtfh', scrollLeftUpdate);

			// Insert a fake thead/tfoot into the DataTable to stop it jumping around
			itemDom.placeholder = itemElement.clone( false );
			itemDom.placeholder
				.find( '*[id]' )
				.removeAttr( 'id' );

			itemDom.host.prepend( itemDom.placeholder );

			// Clone widths
			this._matchWidths( itemDom.placeholder, itemDom.floating );

			// The above action will remove the table header, potentially causing the table to
			// collapse to a smaller size, before it is then re-inserted (append). The result
			// can be that the document, if scrolling, can "jump".
			$(document)
				.scrollTop(docScrollTop)
				.scrollLeft(docScrollLeft);
		}
	},

	/**
	 * This method sets the sticky position of the header elements to match fixed columns
	 * @param {JQuery<HTMLElement>} el 
	 * @param {string} sign 
	 */
	_stickyPosition: function(el, sign) {
		if (this._scrollEnabled()) {
			var that = this
			var rtl = $(that.s.dt.table().node()).css('direction') === 'rtl';

			el.find('th').each(function() {
				// Find out if fixed header has previously set this column
				if ($(this).css('position') === 'sticky') {
					var right = $(this).css('right');
					var left = $(this).css('left');
					if (right !== 'auto' && !rtl) {
						// New position either adds or dismisses the barWidth
						var potential = +right.replace(/px/g, '') + (sign === '-' ? -1 : 1) * that.s.dt.settings()[0].oBrowser.barWidth;
						$(this).css('right', potential > 0 ? potential : 0);
					}
					else if(left !== 'auto' && rtl) {
						var potential = +left.replace(/px/g, '') + (sign === '-' ? -1 : 1) * that.s.dt.settings()[0].oBrowser.barWidth;
						$(this).css('left', potential > 0 ? potential : 0);
					}
				}
			});
		}
	},

	/**
	 * Copy widths from the cells in one element to another. This is required
	 * for the footer as the footer in the main table takes its sizes from the
	 * header columns. That isn't present in the footer so to have it still
	 * align correctly, the sizes need to be copied over. It is also required
	 * for the header when auto width is not enabled
	 *
	 * @param  {jQuery} from Copy widths from
	 * @param  {jQuery} to   Copy widths to
	 * @private
	 */
	_matchWidths: function ( from, to ) {
		var get = function ( name ) {
			return $(name, from)
				.map( function () {
					return $(this).css('width').replace(/[^\d\.]/g, '') * 1;
				} ).toArray();
		};

		var set = function ( name, toWidths ) {
			$(name, to).each( function ( i ) {
				$(this).css( {
					width: toWidths[i],
					minWidth: toWidths[i]
				} );
			} );
		};

		var thWidths = get( 'th' );
		var tdWidths = get( 'td' );

		set( 'th', thWidths );
		set( 'td', tdWidths );
	},

	/**
	 * Remove assigned widths from the cells in an element. This is required
	 * when inserting the footer back into the main table so the size is defined
	 * by the header columns and also when auto width is disabled in the
	 * DataTable.
	 *
	 * @param  {string} item The `header` or `footer`
	 * @private
	 */
	_unsize: function ( item ) {
		var el = this.dom[ item ].floating;

		if ( el && (item === 'footer' || (item === 'header' && ! this.s.autoWidth)) ) {
			$('th, td', el).css( {
				width: '',
				minWidth: ''
			} );
		}
		else if ( el && item === 'header' ) {
			$('th, td', el).css( 'min-width', '' );
		}
	},

	/**
	 * Reposition the floating elements to take account of horizontal page
	 * scroll
	 *
	 * @param  {string} item       The `header` or `footer`
	 * @param  {int}    scrollLeft Document scrollLeft
	 * @private
	 */
	_horizontal: function ( item, scrollLeft )
	{
		var itemDom = this.dom[ item ];
		var position = this.s.position;
		var lastScrollLeft = this.s.scrollLeft;

		if ( itemDom.floating && lastScrollLeft[ item ] !== scrollLeft ) {
			// If scrolling is enabled we need to match the floating header to the body
			if (this._scrollEnabled()) {
				var newScrollLeft = $($(this.s.dt.table().node()).parent()).scrollLeft()
				itemDom.floating.scrollLeft(newScrollLeft);
				itemDom.floatingParent.scrollLeft(newScrollLeft);
			}

			lastScrollLeft[ item ] = scrollLeft;
		}
	},

	/**
	 * Change from one display mode to another. Each fixed item can be in one
	 * of:
	 *
	 * * `in-place` - In the main DataTable
	 * * `in` - Floating over the DataTable
	 * * `below` - (Header only) Fixed to the bottom of the table body
	 * * `above` - (Footer only) Fixed to the top of the table body
	 * 
	 * @param  {string}  mode        Mode that the item should be shown in
	 * @param  {string}  item        'header' or 'footer'
	 * @param  {boolean} forceChange Force a redraw of the mode, even if already
	 *     in that mode.
	 * @private
	 */
	_modeChange: function ( mode, item, forceChange )
	{
		var dt = this.s.dt;
		var itemDom = this.dom[ item ];
		var position = this.s.position;

		// Just determine if scroll is enabled once
		var scrollEnabled = this._scrollEnabled();

		// If footer and scrolling is enabled then we don't clone
		// Instead the table's height is decreased accordingly - see `_scroll()`
		if (item === 'footer' && scrollEnabled) {
			return;
		}		

		// It isn't trivial to add a !important css attribute...
		var importantWidth = function (w) {
			itemDom.floating.attr('style', function(i,s) {
				return (s || '') + 'width: '+w+'px !important;';
			});

			// If not scrolling also have to update the floatingParent
			if (!scrollEnabled) {
				itemDom.floatingParent.attr('style', function(i,s) {
					return (s || '') + 'width: '+w+'px !important;';
				});
			}
		};

		// Record focus. Browser's will cause input elements to loose focus if
		// they are inserted else where in the doc
		var tablePart = this.dom[ item==='footer' ? 'tfoot' : 'thead' ];
		var focus = $.contains( tablePart[0], document.activeElement ) ?
			document.activeElement :
			null;
		var scrollBody = $($(this.s.dt.table().node()).parent());

		if ( mode === 'in-place' ) {
			// Insert the header back into the table's real header
			if ( itemDom.placeholder ) {
				itemDom.placeholder.remove();
				itemDom.placeholder = null;
			}

			this._unsize( item );

			if ( item === 'header' ) {
				itemDom.host.prepend( tablePart );
			}
			else {
				itemDom.host.append( tablePart );
			}

			if ( itemDom.floating ) {
				itemDom.floating.remove();
				itemDom.floating = null;
				this._stickyPosition(itemDom.host, '+');
			}

			if ( itemDom.floatingParent ) {
				itemDom.floatingParent.remove();
			}

			$($(itemDom.host.parent()).parent()).scrollLeft(scrollBody.scrollLeft())
		}
		else if ( mode === 'in' ) {
			// Remove the header from the read header and insert into a fixed
			// positioned floating table clone
			this._clone( item, forceChange );

			// Get useful position values
			var scrollOffset = scrollBody.offset();
			var windowTop = $(document).scrollTop();
			var windowHeight = $(window).height();
			var windowBottom = windowTop + windowHeight;
			var bodyTop = scrollEnabled ? scrollOffset.top : position.tbodyTop;
			var bodyBottom = scrollEnabled ? scrollOffset.top + scrollBody.outerHeight() : position.tfootTop

			// Calculate the amount that the footer or header needs to be shuffled
			var shuffle = item === 'footer' ?
				// footer and top of body isn't on screen
				bodyTop > windowBottom ?
					// Yes - push the footer below
					position.tfootHeight :
					// No - bottom set to the gap between the top of the body and the bottom of the window
					bodyTop + position.tfootHeight - windowBottom :
				// Otherwise must be a header so get the difference from the bottom of the
				//  desired floating header and the bottom of the table body
				windowTop + this.c.headerOffset + position.theadHeight - bodyBottom
				
			// Set the top or bottom based off of the offset and the shuffle value
			var prop = item === 'header' ? 'top' : 'bottom';
			var val = this.c[item+'Offset'] - (shuffle > 0 ? shuffle : 0);

			itemDom.floating.addClass( 'fixedHeader-floating' );
			itemDom.floatingParent
				.css(prop, val)
				.css( {
					'left': position.left,
					'height': item === 'header' ? position.theadHeight : position.tfootHeight,
					'z-index': 2
				})
				.append(itemDom.floating);

			importantWidth(position.width);

			if ( item === 'footer' ) {
				itemDom.floating.css( 'top', '' );
			}
		}
		else if ( mode === 'below' ) { // only used for the header
			// Fix the position of the floating header at base of the table body
			this._clone( item, forceChange );

			itemDom.floating.addClass( 'fixedHeader-locked' );
			itemDom.floatingParent.css({
				position: 'absolute',
				top: position.tfootTop - position.theadHeight,
				left: position.left+'px'
			});

			importantWidth(position.width);
		}
		else if ( mode === 'above' ) { // only used for the footer
			// Fix the position of the floating footer at top of the table body
			this._clone( item, forceChange );

			itemDom.floating.addClass( 'fixedHeader-locked' );
			itemDom.floatingParent.css({
				position: 'absolute',
				top: position.tbodyTop,
				left: position.left+'px'
			});

			importantWidth(position.width);
		}

		// Restore focus if it was lost
		if ( focus && focus !== document.activeElement ) {
			setTimeout( function () {
				focus.focus();
			}, 10 );
		}

		this.s.scrollLeft.header = -1;
		this.s.scrollLeft.footer = -1;
		this.s[item+'Mode'] = mode;
	},

	/**
	 * Cache the positional information that is required for the mode
	 * calculations that FixedHeader performs.
	 *
	 * @private
	 */
	_positions: function ()
	{
		var dt = this.s.dt;
		var table = dt.table();
		var position = this.s.position;
		var dom = this.dom;
		var tableNode = $(table.node());
		var scrollEnabled = this._scrollEnabled();

		// Need to use the header and footer that are in the main table,
		// regardless of if they are clones, since they hold the positions we
		// want to measure from
		var thead = $(dt.table().header());
		var tfoot = $(dt.table().footer());
		var tbody = dom.tbody;
		var scrollBody = tableNode.parent();

		position.visible = tableNode.is(':visible');
		position.width = tableNode.outerWidth();
		position.left = tableNode.offset().left;
		position.theadTop = thead.offset().top;
		position.tbodyTop = scrollEnabled ? scrollBody.offset().top : tbody.offset().top;
		position.tbodyHeight = scrollEnabled ? scrollBody.outerHeight() : tbody.outerHeight();
		position.theadHeight = thead.outerHeight();
		position.theadBottom = position.theadTop + position.theadHeight;

		if ( tfoot.length ) {
			position.tfootTop = position.tbodyTop + position.tbodyHeight; //tfoot.offset().top;
			position.tfootBottom = position.tfootTop + tfoot.outerHeight();
			position.tfootHeight = tfoot.outerHeight();
		}
		else {
			position.tfootTop = position.tbodyTop + tbody.outerHeight();
			position.tfootBottom = position.tfootTop;
			position.tfootHeight = position.tfootTop;
		}
	},


	/**
	 * Mode calculation - determine what mode the fixed items should be placed
	 * into.
	 *
	 * @param  {boolean} forceChange Force a redraw of the mode, even if already
	 *     in that mode.
	 * @private
	 */
	_scroll: function ( forceChange )
	{
		if (this.s.dt.settings()[0].bDestroying) {
			return;
		}

		// ScrollBody details
		var scrollEnabled = this._scrollEnabled();
		var scrollBody = $(this.s.dt.table().node()).parent();
		var scrollOffset =  scrollBody.offset();
		var scrollHeight =  scrollBody.outerHeight();

		// Window details
		var windowLeft = $(document).scrollLeft();
		var windowTop = $(document).scrollTop();
		var windowHeight = $(window).height();
		var windowBottom = windowHeight + windowTop


		var position = this.s.position;
		var headerMode, footerMode;

		// Body Details
		var bodyTop = (scrollEnabled ? scrollOffset.top : position.tbodyTop);
		var bodyLeft = (scrollEnabled ? scrollOffset.left : position.left);
		var bodyBottom = (scrollEnabled ? scrollOffset.top + scrollHeight : position.tfootTop);
		var bodyWidth = (scrollEnabled ? scrollBody.outerWidth() : position.tbodyWidth);

		var windowBottom = windowTop + windowHeight;

		if ( this.c.header ) {
			if ( ! this.s.enable ) {
				headerMode = 'in-place';
			}
			// The header is in it's normal place if the body top is lower than
			//  the scroll of the window plus the headerOffset and the height of the header
			else if ( ! position.visible || windowTop + this.c.headerOffset + position.theadHeight <= bodyTop) {
				headerMode = 'in-place';
			}
			// The header should be floated if
			else if (
				// The scrolling plus the header offset plus the height of the header is lower than the top of the body
				windowTop + this.c.headerOffset + position.theadHeight > bodyTop &&
				// And the scrolling at the top plus the header offset is above the bottom of the body
				windowTop + this.c.headerOffset + position.theadHeight < bodyBottom
			) {
				headerMode = 'in';
				var scrollBody = $($(this.s.dt.table().node()).parent());

				// Further to the above, If the scrolling plus the header offset plus the header height is lower
				// than the bottom of the table a shuffle is required so have to force the calculation
				if(windowTop + this.c.headerOffset + position.theadHeight > bodyBottom || this.dom.header.floatingParent === undefined){
					forceChange = true;
				}
				else {
					this.dom.header.floatingParent
						.css({
							'top': this.c.headerOffset,
							'position': 'fixed'
						})
						.append(this.dom.header.floating);
				}
			}
			// Anything else and the view is below the table
			else {
				headerMode = 'below';
			}

			if ( forceChange || headerMode !== this.s.headerMode ) {
				this._modeChange( headerMode, 'header', forceChange );
			}

			this._horizontal( 'header', windowLeft );
		}

		var header = {
			offset: {top: 0, left: 0},
			height: 0
		}
		var footer = {
			offset: {top: 0, left: 0},
			height: 0
		}

		if ( this.c.footer && this.dom.tfoot.length ) {
			if ( ! this.s.enable ) {
				footerMode = 'in-place';
			}
			else if ( ! position.visible || position.tfootBottom + this.c.footerOffset <= windowBottom ) {
				footerMode = 'in-place';
			}
			else if (
				bodyBottom + position.tfootHeight + this.c.footerOffset > windowBottom &&
				bodyTop + this.c.footerOffset < windowBottom
			) {
				footerMode = 'in';
				forceChange = true;
			}
			else {
				footerMode = 'above';
			}
			
			if ( forceChange || footerMode !== this.s.footerMode ) {
				this._modeChange( footerMode, 'footer', forceChange );
			}

			this._horizontal( 'footer', windowLeft );
			
			var getOffsetHeight = function (el) {
				return {
					offset: el.offset(),
					height: el.outerHeight()
				};
			};
		
			header = this.dom.header.floating ? getOffsetHeight(this.dom.header.floating) : getOffsetHeight(this.dom.thead);
			footer = this.dom.footer.floating ? getOffsetHeight(this.dom.footer.floating) : getOffsetHeight(this.dom.tfoot);

			// If scrolling is enabled and the footer is off the screen
			if (scrollEnabled && footer.offset.top > windowTop){// && footer.offset.top >= windowBottom) {
				// Calculate the gap between the top of the scrollBody and the top of the window
				var overlap = windowTop - scrollOffset.top;
				// The new height is the bottom of the window
				var newHeight = windowBottom +
					// If the gap between the top of the scrollbody and the window is more than
					//  the height of the header then the top of the table is still visible so add that gap
					// Doing this has effectively calculated the height from the top of the table to the bottom of the current page
					(overlap > -header.height ? overlap : 0) -
					// Take from that
					(
						// The top of the header plus
						header.offset.top +
						// The header height if the standard header is present
						(overlap < -header.height ? header.height : 0) +
						// And the height of the footer
						footer.height
					)

					// Don't want a negative height
				if (newHeight < 0) {
					newHeight = 0;
				}

				// At the end of the above calculation the space between the header (top of the page if floating)
				// and the point just above the footer should be the new value for the height of the table.
				scrollBody.outerHeight(newHeight);
				
				// Need some rounding here as sometimes very small decimal places are encountered
				// If the actual height is bigger or equal to the height we just applied then the footer is "Floating"
				if(Math.round(scrollBody.outerHeight()) >= Math.round(newHeight)) {
					$(this.dom.tfoot.parent()).addClass("fixedHeader-floating");
				}
				// Otherwise max-width has kicked in so it is not floating
				else {
					$(this.dom.tfoot.parent()).removeClass("fixedHeader-floating");
				}
			}
		}

		if(this.dom.header.floating){
			this.dom.header.floatingParent.css('left', bodyLeft-windowLeft);
		}
		if(this.dom.footer.floating){
			this.dom.footer.floatingParent.css('left', bodyLeft-windowLeft);
		}

		// If fixed columns is being used on this table then the blockers need to be copied across
		// Cloning these is cleaner than creating as our own as it will keep consistency with fixedColumns automatically
		// ASSUMING that the class remains the same
		if (this.s.dt.settings()[0]._fixedColumns !== undefined) {
			var adjustBlocker = function (side, end, el) {
				if (el === undefined) {
					var blocker = $('div.dtfc-'+side+'-'+end+'-blocker');

					el = blocker.length === 0 ?
						null :
						blocker.clone().css('z-index', 1);
				}

				if(el !== null) {
					if (headerMode === 'in' || headerMode === 'below') {
						el
							.appendTo('body')
							.css({
								top: end === 'top' ? header.offset.top : footer.offset.top,
								left: side === 'right' ? bodyLeft + bodyWidth - el.width() : bodyLeft
							});
					}
					else {
						el.detach();
					}
				}

				return el;
			}

			// Adjust all blockers
			this.dom.header.rightBlocker = adjustBlocker('right', 'top', this.dom.header.rightBlocker);
			this.dom.header.leftBlocker = adjustBlocker('left', 'top', this.dom.header.leftBlocker);
			this.dom.footer.rightBlocker = adjustBlocker('right', 'bottom', this.dom.footer.rightBlocker);
			this.dom.footer.leftBlocker = adjustBlocker('left', 'bottom', this.dom.footer.leftBlocker);
		}
	},

	/**
	 * Function to check if scrolling is enabled on the table or not
	 * @returns Boolean value indicating if scrolling on the table is enabled or not
	 */
	_scrollEnabled: function() {
		var oScroll = this.s.dt.settings()[0].oScroll;
		if(oScroll.sY !== "" || oScroll.sX !== "") {
			return true;
		}
		return false
	}
} );


/**
 * Version
 * @type {String}
 * @static
 */
FixedHeader.version = "3.3.2";

/**
 * Defaults
 * @type {Object}
 * @static
 */
FixedHeader.defaults = {
	header: true,
	footer: false,
	headerOffset: 0,
	footerOffset: 0
};


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * DataTables interfaces
 */

// Attach for constructor access
$.fn.dataTable.FixedHeader = FixedHeader;
$.fn.DataTable.FixedHeader = FixedHeader;


// DataTables creation - check if the FixedHeader option has been defined on the
// table and if so, initialise
$(document).on( 'init.dt.dtfh', function (e, settings, json) {
	if ( e.namespace !== 'dt' ) {
		return;
	}

	var init = settings.oInit.fixedHeader;
	var defaults = DataTable.defaults.fixedHeader;

	if ( (init || defaults) && ! settings._fixedHeader ) {
		var opts = $.extend( {}, defaults, init );

		if ( init !== false ) {
			new FixedHeader( settings, opts );
		}
	}
} );

// DataTables API methods
DataTable.Api.register( 'fixedHeader()', function () {} );

DataTable.Api.register( 'fixedHeader.adjust()', function () {
	return this.iterator( 'table', function ( ctx ) {
		var fh = ctx._fixedHeader;

		if ( fh ) {
			fh.update();
		}
	} );
} );

DataTable.Api.register( 'fixedHeader.enable()', function ( flag ) {
	return this.iterator( 'table', function ( ctx ) {
		var fh = ctx._fixedHeader;

		flag = ( flag !== undefined ? flag : true );
		if ( fh && flag !== fh.enabled() ) {
			fh.enable( flag );
		}
	} );
} );

DataTable.Api.register( 'fixedHeader.enabled()', function () {
	if ( this.context.length ) {
		var fh = this.context[0]._fixedHeader;

		if ( fh ) {
			return fh.enabled();
		}
	}

	return false;
} );

DataTable.Api.register( 'fixedHeader.disable()', function ( ) {
	return this.iterator( 'table', function ( ctx ) {
		var fh = ctx._fixedHeader;

		if ( fh && fh.enabled() ) {
			fh.enable( false );
		}
	} );
} );

$.each( ['header', 'footer'], function ( i, el ) {
	DataTable.Api.register( 'fixedHeader.'+el+'Offset()', function ( offset ) {
		var ctx = this.context;

		if ( offset === undefined ) {
			return ctx.length && ctx[0]._fixedHeader ?
				ctx[0]._fixedHeader[el +'Offset']() :
				undefined;
		}

		return this.iterator( 'table', function ( ctx ) {
			var fh = ctx._fixedHeader;

			if ( fh ) {
				fh[ el +'Offset' ]( offset );
			}
		} );
	} );
} );


return DataTable;
}));


/*! SearchBuilder 1.4.2
 * ©SpryMedia Ltd - datatables.net/license/mit
 */

(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		var jq = require('jquery');
		var cjsRequires = function (root, $) {
			if ( ! $.fn.dataTable ) {
				require('datatables.net')(root, $);
			}
		};

		if (typeof window !== 'undefined') {
			module.exports = function (root, $) {
				if ( ! root ) {
					// CommonJS environments without a window global must pass a
					// root. This will give an error otherwise
					root = window;
				}

				if ( ! $ ) {
					$ = jq( root );
				}

				cjsRequires( root, $ );
				return factory( $, root, root.document );
			};
		}
		else {
			cjsRequires( window, jq );
			module.exports = factory( jq, window, window.document );
		}
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


(function () {
    'use strict';

    var $$3;
    var dataTable$3;
    function moment() {
        return window.moment;
    }
    function luxon() {
        return window.luxon;
    }
    /**
     * Sets the value of jQuery for use in the file
     *
     * @param jq the instance of jQuery to be set
     */
    function setJQuery$2(jq) {
        $$3 = jq;
        dataTable$3 = jq.fn.dataTable;
    }
    /**
     * The Criteria class is used within SearchBuilder to represent a search criteria
     */
    var Criteria = /** @class */ (function () {
        function Criteria(table, opts, topGroup, index, depth, serverData) {
            if (index === void 0) { index = 0; }
            if (depth === void 0) { depth = 1; }
            if (serverData === void 0) { serverData = undefined; }
            var _this = this;
            // Check that the required version of DataTables is included
            if (!dataTable$3 || !dataTable$3.versionCheck || !dataTable$3.versionCheck('1.10.0')) {
                throw new Error('SearchPane requires DataTables 1.10 or newer');
            }
            this.classes = $$3.extend(true, {}, Criteria.classes);
            // Get options from user and any extra conditions/column types defined by plug-ins
            this.c = $$3.extend(true, {}, Criteria.defaults, $$3.fn.dataTable.ext.searchBuilder, opts);
            var i18n = this.c.i18n;
            this.s = {
                condition: undefined,
                conditions: {},
                data: undefined,
                dataIdx: -1,
                dataPoints: [],
                dateFormat: false,
                depth: depth,
                dt: table,
                filled: false,
                index: index,
                origData: undefined,
                preventRedraw: false,
                serverData: serverData,
                topGroup: topGroup,
                type: '',
                value: []
            };
            this.dom = {
                buttons: $$3('<div/>')
                    .addClass(this.classes.buttonContainer),
                condition: $$3('<select disabled/>')
                    .addClass(this.classes.condition)
                    .addClass(this.classes.dropDown)
                    .addClass(this.classes.italic)
                    .attr('autocomplete', 'hacking'),
                conditionTitle: $$3('<option value="" disabled selected hidden/>')
                    .html(this.s.dt.i18n('searchBuilder.condition', i18n.condition)),
                container: $$3('<div/>')
                    .addClass(this.classes.container),
                data: $$3('<select/>')
                    .addClass(this.classes.data)
                    .addClass(this.classes.dropDown)
                    .addClass(this.classes.italic),
                dataTitle: $$3('<option value="" disabled selected hidden/>')
                    .html(this.s.dt.i18n('searchBuilder.data', i18n.data)),
                defaultValue: $$3('<select disabled/>')
                    .addClass(this.classes.value)
                    .addClass(this.classes.dropDown)
                    .addClass(this.classes.select)
                    .addClass(this.classes.italic),
                "delete": $$3('<button/>')
                    .html(this.s.dt.i18n('searchBuilder.delete', i18n["delete"]))
                    .addClass(this.classes["delete"])
                    .addClass(this.classes.button)
                    .attr('title', this.s.dt.i18n('searchBuilder.deleteTitle', i18n.deleteTitle))
                    .attr('type', 'button'),
                inputCont: $$3('<div/>')
                    .addClass(this.classes.inputCont),
                // eslint-disable-next-line no-useless-escape
                left: $$3('<button/>')
                    .html(this.s.dt.i18n('searchBuilder.left', i18n.left))
                    .addClass(this.classes.left)
                    .addClass(this.classes.button)
                    .attr('title', this.s.dt.i18n('searchBuilder.leftTitle', i18n.leftTitle))
                    .attr('type', 'button'),
                // eslint-disable-next-line no-useless-escape
                right: $$3('<button/>')
                    .html(this.s.dt.i18n('searchBuilder.right', i18n.right))
                    .addClass(this.classes.right)
                    .addClass(this.classes.button)
                    .attr('title', this.s.dt.i18n('searchBuilder.rightTitle', i18n.rightTitle))
                    .attr('type', 'button'),
                value: [
                    $$3('<select disabled/>')
                        .addClass(this.classes.value)
                        .addClass(this.classes.dropDown)
                        .addClass(this.classes.italic)
                        .addClass(this.classes.select)
                ],
                valueTitle: $$3('<option value="--valueTitle--" disabled selected hidden/>')
                    .html(this.s.dt.i18n('searchBuilder.value', i18n.value))
            };
            // If the greyscale option is selected then add the class to add the grey colour to SearchBuilder
            if (this.c.greyscale) {
                this.dom.data.addClass(this.classes.greyscale);
                this.dom.condition.addClass(this.classes.greyscale);
                this.dom.defaultValue.addClass(this.classes.greyscale);
                for (var _i = 0, _a = this.dom.value; _i < _a.length; _i++) {
                    var val = _a[_i];
                    val.addClass(this.classes.greyscale);
                }
            }
            $$3(window).on('resize.dtsb', dataTable$3.util.throttle(function () {
                _this.s.topGroup.trigger('dtsb-redrawLogic');
            }));
            this._buildCriteria();
            return this;
        }
        /**
         * Escape html characters within a string
         *
         * @param txt the string to be escaped
         * @returns the escaped string
         */
        Criteria._escapeHTML = function (txt) {
            return txt
                .toString()
                .replace(/&amp;/g, '&')
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .replace(/&quot;/g, '"');
        };
        /**
         * Parses formatted numbers down to a form where they can be compared
         *
         * @param val the value to convert
         * @returns the converted value
         */
        Criteria.parseNumFmt = function (val) {
            return +val.replace(/(?!^-)[^0-9.]/g, '');
        };
        /**
         * Adds the left button to the criteria
         */
        Criteria.prototype.updateArrows = function (hasSiblings) {
            if (hasSiblings === void 0) { hasSiblings = false; }
            // Empty the container and append all of the elements in the correct order
            this.dom.container.children().detach();
            this.dom.container
                .append(this.dom.data)
                .append(this.dom.condition)
                .append(this.dom.inputCont);
            this.setListeners();
            // Trigger the inserted events for the value elements as they are inserted
            if (this.dom.value[0] !== undefined) {
                this.dom.value[0].trigger('dtsb-inserted');
            }
            for (var i = 1; i < this.dom.value.length; i++) {
                this.dom.inputCont.append(this.dom.value[i]);
                this.dom.value[i].trigger('dtsb-inserted');
            }
            // If this is a top level criteria then don't let it move left
            if (this.s.depth > 1) {
                this.dom.buttons.append(this.dom.left);
            }
            // If the depthLimit of the query has been hit then don't add the right button
            if ((this.c.depthLimit === false || this.s.depth < this.c.depthLimit) && hasSiblings) {
                this.dom.buttons.append(this.dom.right);
            }
            else {
                this.dom.right.remove();
            }
            this.dom.buttons.append(this.dom["delete"]);
            this.dom.container.append(this.dom.buttons);
        };
        /**
         * Destroys the criteria, removing listeners and container from the dom
         */
        Criteria.prototype.destroy = function () {
            // Turn off listeners
            this.dom.data.off('.dtsb');
            this.dom.condition.off('.dtsb');
            this.dom["delete"].off('.dtsb');
            for (var _i = 0, _a = this.dom.value; _i < _a.length; _i++) {
                var val = _a[_i];
                val.off('.dtsb');
            }
            // Remove container from the dom
            this.dom.container.remove();
        };
        /**
         * Passes in the data for the row and compares it against this single criteria
         *
         * @param rowData The data for the row to be compared
         * @returns boolean Whether the criteria has passed
         */
        Criteria.prototype.search = function (rowData, rowIdx) {
            var condition = this.s.conditions[this.s.condition];
            if (this.s.condition !== undefined && condition !== undefined) {
                var filter = rowData[this.s.dataIdx];
                // This check is in place for if a custom decimal character is in place
                if (this.s.type.includes('num') &&
                    (this.s.dt.settings()[0].oLanguage.sDecimal !== '' ||
                        this.s.dt.settings()[0].oLanguage.sThousands !== '')) {
                    var splitRD = [rowData[this.s.dataIdx]];
                    if (this.s.dt.settings()[0].oLanguage.sDecimal !== '') {
                        splitRD = rowData[this.s.dataIdx].split(this.s.dt.settings()[0].oLanguage.sDecimal);
                    }
                    if (this.s.dt.settings()[0].oLanguage.sThousands !== '') {
                        for (var i = 0; i < splitRD.length; i++) {
                            splitRD[i] = splitRD[i].replace(this.s.dt.settings()[0].oLanguage.sThousands, ',');
                        }
                    }
                    filter = splitRD.join('.');
                }
                // If orthogonal data is in place we need to get it's values for searching
                if (this.c.orthogonal.search !== 'filter') {
                    var settings = this.s.dt.settings()[0];
                    filter = settings.oApi._fnGetCellData(settings, rowIdx, this.s.dataIdx, typeof this.c.orthogonal === 'string' ?
                        this.c.orthogonal :
                        this.c.orthogonal.search);
                }
                if (this.s.type === 'array') {
                    // Make sure we are working with an array
                    if (!Array.isArray(filter)) {
                        filter = [filter];
                    }
                    filter.sort();
                    for (var _i = 0, filter_1 = filter; _i < filter_1.length; _i++) {
                        var filt = filter_1[_i];
                        if (filt && typeof filt === 'string') {
                            filt = filt.replace(/[\r\n\u2028]/g, ' ');
                        }
                    }
                }
                else if (filter !== null && typeof filter === 'string') {
                    filter = filter.replace(/[\r\n\u2028]/g, ' ');
                }
                if (this.s.type.includes('html') && typeof filter === 'string') {
                    filter = filter.replace(/(<([^>]+)>)/ig, '');
                }
                // Not ideal, but jqueries .val() returns an empty string even
                // when the value set is null, so we shall assume the two are equal
                if (filter === null) {
                    filter = '';
                }
                return condition.search(filter, this.s.value, this);
            }
        };
        /**
         * Gets the details required to rebuild the criteria
         */
        Criteria.prototype.getDetails = function (deFormatDates) {
            if (deFormatDates === void 0) { deFormatDates = false; }
            // This check is in place for if a custom decimal character is in place
            if (this.s.type !== null &&
                this.s.type.includes('num') &&
                (this.s.dt.settings()[0].oLanguage.sDecimal !== '' || this.s.dt.settings()[0].oLanguage.sThousands !== '')) {
                for (var i = 0; i < this.s.value.length; i++) {
                    var splitRD = [this.s.value[i].toString()];
                    if (this.s.dt.settings()[0].oLanguage.sDecimal !== '') {
                        splitRD = this.s.value[i].split(this.s.dt.settings()[0].oLanguage.sDecimal);
                    }
                    if (this.s.dt.settings()[0].oLanguage.sThousands !== '') {
                        for (var j = 0; j < splitRD.length; j++) {
                            splitRD[j] = splitRD[j].replace(this.s.dt.settings()[0].oLanguage.sThousands, ',');
                        }
                    }
                    this.s.value[i] = splitRD.join('.');
                }
            }
            else if (this.s.type !== null && deFormatDates) {
                if (this.s.type.includes('date') ||
                    this.s.type.includes('time')) {
                    for (var i = 0; i < this.s.value.length; i++) {
                        if (this.s.value[i].match(/^\d{4}-([0]\d|1[0-2])-([0-2]\d|3[01])$/g) === null) {
                            this.s.value[i] = '';
                        }
                    }
                }
                else if (this.s.type.includes('moment')) {
                    for (var i = 0; i < this.s.value.length; i++) {
                        if (this.s.value[i] &&
                            this.s.value[i].length > 0 &&
                            moment()(this.s.value[i], this.s.dateFormat, true).isValid()) {
                            this.s.value[i] = moment()(this.s.value[i], this.s.dateFormat).format('YYYY-MM-DD HH:mm:ss');
                        }
                    }
                }
                else if (this.s.type.includes('luxon')) {
                    for (var i = 0; i < this.s.value.length; i++) {
                        if (this.s.value[i] &&
                            this.s.value[i].length > 0 &&
                            luxon().DateTime.fromFormat(this.s.value[i], this.s.dateFormat).invalid === null) {
                            this.s.value[i] = luxon().DateTime.fromFormat(this.s.value[i], this.s.dateFormat).toFormat('yyyy-MM-dd HH:mm:ss');
                        }
                    }
                }
            }
            if (this.s.type.includes('num') && this.s.dt.page.info().serverSide) {
                for (var i = 0; i < this.s.value.length; i++) {
                    this.s.value[i] = this.s.value[i].replace(/[^0-9.\-]/g, '');
                }
            }
            return {
                condition: this.s.condition,
                data: this.s.data,
                origData: this.s.origData,
                type: this.s.type,
                value: this.s.value.map(function (a) { return a !== null && a !== undefined ? a.toString() : a; })
            };
        };
        /**
         * Getter for the node for the container of the criteria
         *
         * @returns JQuery<HTMLElement> the node for the container
         */
        Criteria.prototype.getNode = function () {
            return this.dom.container;
        };
        /**
         * Populates the criteria data, condition and value(s) as far as has been selected
         */
        Criteria.prototype.populate = function () {
            this._populateData();
            // If the column index has been found attempt to select a condition
            if (this.s.dataIdx !== -1) {
                this._populateCondition();
                // If the condittion has been found attempt to select the values
                if (this.s.condition !== undefined) {
                    this._populateValue();
                }
            }
        };
        /**
         * Rebuilds the criteria based upon the details passed in
         *
         * @param loadedCriteria the details required to rebuild the criteria
         */
        Criteria.prototype.rebuild = function (loadedCriteria) {
            // Check to see if the previously selected data exists, if so select it
            var foundData = false;
            var dataIdx;
            this._populateData();
            // If a data selection has previously been made attempt to find and select it
            if (loadedCriteria.data !== undefined) {
                var italic_1 = this.classes.italic;
                var data_1 = this.dom.data;
                this.dom.data.children('option').each(function () {
                    if (!foundData &&
                        ($$3(this).text() === loadedCriteria.data ||
                            loadedCriteria.origData && $$3(this).prop('origData') === loadedCriteria.origData)) {
                        $$3(this).prop('selected', true);
                        data_1.removeClass(italic_1);
                        foundData = true;
                        dataIdx = $$3(this).val();
                    }
                    else {
                        $$3(this).removeProp('selected');
                    }
                });
            }
            // If the data has been found and selected then the condition can be populated and searched
            if (foundData) {
                this.s.data = loadedCriteria.data;
                this.s.origData = loadedCriteria.origData;
                this.s.dataIdx = dataIdx;
                this.c.orthogonal = this._getOptions().orthogonal;
                this.dom.dataTitle.remove();
                this._populateCondition();
                this.dom.conditionTitle.remove();
                var condition = void 0;
                // Check to see if the previously selected condition exists, if so select it
                var options = this.dom.condition.children('option');
                // eslint-disable-next-line @typescript-eslint/prefer-for-of
                for (var i = 0; i < options.length; i++) {
                    var option = $$3(options[i]);
                    if (loadedCriteria.condition !== undefined &&
                        option.val() === loadedCriteria.condition &&
                        typeof loadedCriteria.condition === 'string') {
                        option.prop('selected', true);
                        condition = option.val();
                    }
                    else {
                        option.removeProp('selected');
                    }
                }
                this.s.condition = condition;
                // If the condition has been found and selected then the value can be populated and searched
                if (this.s.condition !== undefined) {
                    this.dom.conditionTitle.removeProp('selected');
                    this.dom.conditionTitle.remove();
                    this.dom.condition.removeClass(this.classes.italic);
                    // eslint-disable-next-line @typescript-eslint/prefer-for-of
                    for (var i = 0; i < options.length; i++) {
                        var option = $$3(options[i]);
                        if (option.val() !== this.s.condition) {
                            option.removeProp('selected');
                        }
                    }
                    this._populateValue(loadedCriteria);
                }
                else {
                    this.dom.conditionTitle.prependTo(this.dom.condition).prop('selected', true);
                }
            }
        };
        /**
         * Sets the listeners for the criteria
         */
        Criteria.prototype.setListeners = function () {
            var _this = this;
            this.dom.data
                .unbind('change')
                .on('change.dtsb', function () {
                _this.dom.dataTitle.removeProp('selected');
                // Need to go over every option to identify the correct selection
                var options = _this.dom.data.children('option.' + _this.classes.option);
                // eslint-disable-next-line @typescript-eslint/prefer-for-of
                for (var i = 0; i < options.length; i++) {
                    var option = $$3(options[i]);
                    if (option.val() === _this.dom.data.val()) {
                        _this.dom.data.removeClass(_this.classes.italic);
                        option.prop('selected', true);
                        _this.s.dataIdx = +option.val();
                        _this.s.data = option.text();
                        _this.s.origData = option.prop('origData');
                        _this.c.orthogonal = _this._getOptions().orthogonal;
                        // When the data is changed, the values in condition and
                        // value may also change so need to renew them
                        _this._clearCondition();
                        _this._clearValue();
                        _this._populateCondition();
                        // If this criteria was previously active in the search then
                        // remove it from the search and trigger a new search
                        if (_this.s.filled) {
                            _this.s.filled = false;
                            _this.s.dt.draw();
                            _this.setListeners();
                        }
                        _this.s.dt.state.save();
                    }
                    else {
                        option.removeProp('selected');
                    }
                }
            });
            this.dom.condition
                .unbind('change')
                .on('change.dtsb', function () {
                _this.dom.conditionTitle.removeProp('selected');
                // Need to go over every option to identify the correct selection
                var options = _this.dom.condition.children('option.' + _this.classes.option);
                // eslint-disable-next-line @typescript-eslint/prefer-for-of
                for (var i = 0; i < options.length; i++) {
                    var option = $$3(options[i]);
                    if (option.val() === _this.dom.condition.val()) {
                        _this.dom.condition.removeClass(_this.classes.italic);
                        option.prop('selected', true);
                        var condDisp = option.val();
                        // Find the condition that has been selected and store it internally
                        for (var _i = 0, _a = Object.keys(_this.s.conditions); _i < _a.length; _i++) {
                            var cond = _a[_i];
                            if (cond === condDisp) {
                                _this.s.condition = condDisp;
                                break;
                            }
                        }
                        // When the condition is changed, the value selector may switch between
                        // a select element and an input element
                        _this._clearValue();
                        _this._populateValue();
                        for (var _b = 0, _c = _this.dom.value; _b < _c.length; _b++) {
                            var val = _c[_b];
                            // If this criteria was previously active in the search then remove
                            // it from the search and trigger a new search
                            if (_this.s.filled && val !== undefined && _this.dom.inputCont.has(val[0]).length !== 0) {
                                _this.s.filled = false;
                                _this.s.dt.draw();
                                _this.setListeners();
                            }
                        }
                        if (_this.dom.value.length === 0 ||
                            _this.dom.value.length === 1 && _this.dom.value[0] === undefined) {
                            _this.s.dt.draw();
                        }
                    }
                    else {
                        option.removeProp('selected');
                    }
                }
            });
        };
        Criteria.prototype.setupButtons = function () {
            if (window.innerWidth > 550) {
                this.dom.container.removeClass(this.classes.vertical);
                this.dom.buttons.css('left', null);
                this.dom.buttons.css('top', null);
                return;
            }
            this.dom.container.addClass(this.classes.vertical);
            this.dom.buttons.css('left', this.dom.data.innerWidth());
            this.dom.buttons.css('top', this.dom.data.position().top);
        };
        /**
         * Builds the elements of the dom together
         */
        Criteria.prototype._buildCriteria = function () {
            // Append Titles for select elements
            this.dom.data.append(this.dom.dataTitle);
            this.dom.condition.append(this.dom.conditionTitle);
            // Add elements to container
            this.dom.container
                .append(this.dom.data)
                .append(this.dom.condition);
            this.dom.inputCont.empty();
            for (var _i = 0, _a = this.dom.value; _i < _a.length; _i++) {
                var val = _a[_i];
                val.append(this.dom.valueTitle);
                this.dom.inputCont.append(val);
            }
            // Add buttons to container
            this.dom.buttons
                .append(this.dom["delete"])
                .append(this.dom.right);
            this.dom.container.append(this.dom.inputCont).append(this.dom.buttons);
            this.setListeners();
        };
        /**
         * Clears the condition select element
         */
        Criteria.prototype._clearCondition = function () {
            this.dom.condition.empty();
            this.dom.conditionTitle.prop('selected', true).attr('disabled', 'true');
            this.dom.condition.prepend(this.dom.conditionTitle).prop('selectedIndex', 0);
            this.s.conditions = {};
            this.s.condition = undefined;
        };
        /**
         * Clears the value elements
         */
        Criteria.prototype._clearValue = function () {
            if (this.s.condition !== undefined) {
                if (this.dom.value.length > 0 && this.dom.value[0] !== undefined) {
                    var _loop_1 = function (val) {
                        if (val !== undefined) {
                            // Timeout is annoying but because of IOS
                            setTimeout(function () {
                                val.remove();
                            }, 50);
                        }
                    };
                    // Remove all of the value elements
                    for (var _i = 0, _a = this.dom.value; _i < _a.length; _i++) {
                        var val = _a[_i];
                        _loop_1(val);
                    }
                }
                // Call the init function to get the value elements for this condition
                this.dom.value = [].concat(this.s.conditions[this.s.condition].init(this, Criteria.updateListener));
                if (this.dom.value.length > 0 && this.dom.value[0] !== undefined) {
                    this.dom.inputCont
                        .empty()
                        .append(this.dom.value[0])
                        .insertAfter(this.dom.condition);
                    this.dom.value[0].trigger('dtsb-inserted');
                    // Insert all of the value elements
                    for (var i = 1; i < this.dom.value.length; i++) {
                        this.dom.inputCont.append(this.dom.value[i]);
                        this.dom.value[i].trigger('dtsb-inserted');
                    }
                }
            }
            else {
                var _loop_2 = function (val) {
                    if (val !== undefined) {
                        // Timeout is annoying but because of IOS
                        setTimeout(function () {
                            val.remove();
                        }, 50);
                    }
                };
                // Remove all of the value elements
                for (var _b = 0, _c = this.dom.value; _b < _c.length; _b++) {
                    var val = _c[_b];
                    _loop_2(val);
                }
                // Append the default valueTitle to the default select element
                this.dom.valueTitle
                    .prop('selected', true);
                this.dom.defaultValue
                    .append(this.dom.valueTitle)
                    .insertAfter(this.dom.condition);
            }
            this.s.value = [];
            this.dom.value = [
                $$3('<select disabled/>')
                    .addClass(this.classes.value)
                    .addClass(this.classes.dropDown)
                    .addClass(this.classes.italic)
                    .addClass(this.classes.select)
                    .append(this.dom.valueTitle.clone())
            ];
        };
        /**
         * Gets the options for the column
         *
         * @returns {object} The options for the column
         */
        Criteria.prototype._getOptions = function () {
            var table = this.s.dt;
            return $$3.extend(true, {}, Criteria.defaults, table.settings()[0].aoColumns[this.s.dataIdx].searchBuilder);
        };
        /**
         * Populates the condition dropdown
         */
        Criteria.prototype._populateCondition = function () {
            var conditionOpts = [];
            var conditionsLength = Object.keys(this.s.conditions).length;
            var colInits = this.s.dt.settings()[0].aoColumns;
            var column = +this.dom.data.children('option:selected').val();
            // If there are no conditions stored then we need to get them from the appropriate type
            if (conditionsLength === 0) {
                this.s.type = this.s.dt.columns().type().toArray()[column];
                if (colInits !== undefined) {
                    var colInit = colInits[column];
                    if (colInit.searchBuilderType !== undefined && colInit.searchBuilderType !== null) {
                        this.s.type = colInit.searchBuilderType;
                    }
                    else if (this.s.type === undefined || this.s.type === null) {
                        this.s.type = colInit.sType;
                    }
                }
                // If the column type is still unknown, call a draw to try reading it again
                if (this.s.type === null || this.s.type === undefined) {
                    $$3.fn.dataTable.ext.oApi._fnColumnTypes(this.s.dt.settings()[0]);
                    this.s.type = this.s.dt.columns().type().toArray()[column];
                }
                // Enable the condition element
                this.dom.condition
                    .removeAttr('disabled')
                    .empty()
                    .append(this.dom.conditionTitle)
                    .addClass(this.classes.italic);
                this.dom.conditionTitle
                    .prop('selected', true);
                var decimal = this.s.dt.settings()[0].oLanguage.sDecimal;
                // This check is in place for if a custom decimal character is in place
                if (decimal !== '' && this.s.type.indexOf(decimal) === this.s.type.length - decimal.length) {
                    if (this.s.type.includes('num-fmt')) {
                        this.s.type = this.s.type.replace(decimal, '');
                    }
                    else if (this.s.type.includes('num')) {
                        this.s.type = this.s.type.replace(decimal, '');
                    }
                }
                // Select which conditions are going to be used based on the column type
                var conditionObj = this.c.conditions[this.s.type] !== undefined ?
                    this.c.conditions[this.s.type] :
                    this.s.type.includes('moment') ?
                        this.c.conditions.moment :
                        this.s.type.includes('luxon') ?
                            this.c.conditions.luxon :
                            this.c.conditions.string;
                // If it is a moment format then extract the date format
                if (this.s.type.includes('moment')) {
                    this.s.dateFormat = this.s.type.replace(/moment-/g, '');
                }
                else if (this.s.type.includes('luxon')) {
                    this.s.dateFormat = this.s.type.replace(/luxon-/g, '');
                }
                // Add all of the conditions to the select element
                for (var _i = 0, _a = Object.keys(conditionObj); _i < _a.length; _i++) {
                    var condition = _a[_i];
                    if (conditionObj[condition] !== null) {
                        // Serverside processing does not supply the options for the select elements
                        // Instead input elements need to be used for these instead
                        if (this.s.dt.page.info().serverSide && conditionObj[condition].init === Criteria.initSelect) {
                            var col = colInits[column];
                            if (this.s.serverData && this.s.serverData[col.data]) {
                                conditionObj[condition].init = Criteria.initSelectSSP;
                                conditionObj[condition].inputValue = Criteria.inputValueSelect;
                                conditionObj[condition].isInputValid = Criteria.isInputValidSelect;
                            }
                            else {
                                conditionObj[condition].init = Criteria.initInput;
                                conditionObj[condition].inputValue = Criteria.inputValueInput;
                                conditionObj[condition].isInputValid = Criteria.isInputValidInput;
                            }
                        }
                        this.s.conditions[condition] = conditionObj[condition];
                        var condName = conditionObj[condition].conditionName;
                        if (typeof condName === 'function') {
                            condName = condName(this.s.dt, this.c.i18n);
                        }
                        conditionOpts.push($$3('<option>', {
                            text: condName,
                            value: condition
                        })
                            .addClass(this.classes.option)
                            .addClass(this.classes.notItalic));
                    }
                }
            }
            // Otherwise we can just load them in
            else if (conditionsLength > 0) {
                this.dom.condition.empty().removeAttr('disabled').addClass(this.classes.italic);
                for (var _b = 0, _c = Object.keys(this.s.conditions); _b < _c.length; _b++) {
                    var condition = _c[_b];
                    var condName = this.s.conditions[condition].conditionName;
                    if (typeof condName === 'function') {
                        condName = condName(this.s.dt, this.c.i18n);
                    }
                    var newOpt = $$3('<option>', {
                        text: condName,
                        value: condition
                    })
                        .addClass(this.classes.option)
                        .addClass(this.classes.notItalic);
                    if (this.s.condition !== undefined && this.s.condition === condName) {
                        newOpt.prop('selected', true);
                        this.dom.condition.removeClass(this.classes.italic);
                    }
                    conditionOpts.push(newOpt);
                }
            }
            else {
                this.dom.condition
                    .attr('disabled', 'true')
                    .addClass(this.classes.italic);
                return;
            }
            for (var _d = 0, conditionOpts_1 = conditionOpts; _d < conditionOpts_1.length; _d++) {
                var opt = conditionOpts_1[_d];
                this.dom.condition.append(opt);
            }
            // Selecting a default condition if one is set
            if (colInits[column].searchBuilder && colInits[column].searchBuilder.defaultCondition) {
                var defaultCondition = colInits[column].searchBuilder.defaultCondition;
                // If it is a number just use it as an index
                if (typeof defaultCondition === 'number') {
                    this.dom.condition.prop('selectedIndex', defaultCondition);
                    this.dom.condition.trigger('change');
                }
                // If it is a string then things get slightly more tricly
                else if (typeof defaultCondition === 'string') {
                    // We need to check each condition option to see if any will match
                    for (var i = 0; i < conditionOpts.length; i++) {
                        // Need to check against the stored conditions so we can match the token "cond" to the option
                        for (var _e = 0, _f = Object.keys(this.s.conditions); _e < _f.length; _e++) {
                            var cond = _f[_e];
                            var condName = this.s.conditions[cond].conditionName;
                            if (
                            // If the conditionName matches the text of the option
                            (typeof condName === 'string' ? condName : condName(this.s.dt, this.c.i18n)) ===
                                conditionOpts[i].text() &&
                                // and the tokens match
                                cond === defaultCondition) {
                                // Select that option
                                this.dom.condition
                                    .prop('selectedIndex', this.dom.condition.children().toArray().indexOf(conditionOpts[i][0]))
                                    .removeClass(this.classes.italic);
                                this.dom.condition.trigger('change');
                                i = conditionOpts.length;
                                break;
                            }
                        }
                    }
                }
            }
            // If not default set then default to 0, the title
            else {
                this.dom.condition.prop('selectedIndex', 0);
            }
        };
        /**
         * Populates the data / column select element
         */
        Criteria.prototype._populateData = function () {
            var columns = this.s.dt.settings()[0].aoColumns;
            var includeColumns = this.s.dt.columns(this.c.columns).indexes().toArray();
            this.dom.data.empty().append(this.dom.dataTitle);
            for (var index = 0; index < columns.length; index++) {
                // Need to check that the column can be filtered on before adding it
                if (this.c.columns === true || includeColumns.includes(index)) {
                    var col = columns[index];
                    var opt = {
                        index: index,
                        origData: col.data,
                        text: (col.searchBuilderTitle || col.sTitle)
                            .replace(/(<([^>]+)>)/ig, '')
                    };
                    this.dom.data.append($$3('<option>', {
                        text: opt.text,
                        value: opt.index
                    })
                        .addClass(this.classes.option)
                        .addClass(this.classes.notItalic)
                        .prop('origData', col.data)
                        .prop('selected', this.s.dataIdx === opt.index ? true : false));
                    if (this.s.dataIdx === opt.index) {
                        this.dom.dataTitle.removeProp('selected');
                    }
                }
            }
        };
        /**
         * Populates the Value select element
         *
         * @param loadedCriteria optional, used to reload criteria from predefined filters
         */
        Criteria.prototype._populateValue = function (loadedCriteria) {
            var _this = this;
            var prevFilled = this.s.filled;
            this.s.filled = false;
            // Remove any previous value elements
            // Timeout is annoying but because of IOS
            setTimeout(function () {
                _this.dom.defaultValue.remove();
            }, 50);
            var _loop_3 = function (val) {
                // Timeout is annoying but because of IOS
                setTimeout(function () {
                    if (val !== undefined) {
                        val.remove();
                    }
                }, 50);
            };
            for (var _i = 0, _a = this.dom.value; _i < _a.length; _i++) {
                var val = _a[_i];
                _loop_3(val);
            }
            var children = this.dom.inputCont.children();
            if (children.length > 1) {
                // eslint-disable-next-line @typescript-eslint/prefer-for-of
                for (var i = 0; i < children.length; i++) {
                    $$3(children[i]).remove();
                }
            }
            // Find the column with the title matching the data for the criteria and take note of the index
            if (loadedCriteria !== undefined) {
                this.s.dt.columns().every(function (index) {
                    if (_this.s.dt.settings()[0].aoColumns[index].sTitle === loadedCriteria.data) {
                        _this.s.dataIdx = index;
                    }
                });
            }
            // Initialise the value elements based on the condition
            this.dom.value = [].concat(this.s.conditions[this.s.condition].init(this, Criteria.updateListener, loadedCriteria !== undefined ? loadedCriteria.value : undefined));
            if (loadedCriteria !== undefined && loadedCriteria.value !== undefined) {
                this.s.value = loadedCriteria.value;
            }
            this.dom.inputCont.empty();
            // Insert value elements and trigger the inserted event
            if (this.dom.value[0] !== undefined) {
                this.dom.value[0]
                    .appendTo(this.dom.inputCont)
                    .trigger('dtsb-inserted');
            }
            for (var i = 1; i < this.dom.value.length; i++) {
                this.dom.value[i]
                    .insertAfter(this.dom.value[i - 1])
                    .trigger('dtsb-inserted');
            }
            // Check if the criteria can be used in a search
            this.s.filled = this.s.conditions[this.s.condition].isInputValid(this.dom.value, this);
            this.setListeners();
            // If it can and this is different to before then trigger a draw
            if (!this.s.preventRedraw && prevFilled !== this.s.filled) {
                // If using SSP we want to restrict the amount of server calls that take place
                //  and this will already have taken place
                if (!this.s.dt.page.info().serverSide) {
                    this.s.dt.draw();
                }
                this.setListeners();
            }
        };
        /**
         * Provides throttling capabilities to SearchBuilder without having to use dt's _fnThrottle function
         * This is because that function is not quite suitable for our needs as it runs initially rather than waiting
         *
         * @param args arguments supplied to the throttle function
         * @returns Function that is to be run that implements the throttling
         */
        Criteria.prototype._throttle = function (fn, frequency) {
            if (frequency === void 0) { frequency = 200; }
            var last = null;
            var timer = null;
            var that = this;
            if (frequency === null) {
                frequency = 200;
            }
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var now = +new Date();
                if (last !== null && now < last + frequency) {
                    clearTimeout(timer);
                }
                else {
                    last = now;
                }
                timer = setTimeout(function () {
                    last = null;
                    fn.apply(that, args);
                }, frequency);
            };
        };
        Criteria.version = '1.1.0';
        Criteria.classes = {
            button: 'dtsb-button',
            buttonContainer: 'dtsb-buttonContainer',
            condition: 'dtsb-condition',
            container: 'dtsb-criteria',
            data: 'dtsb-data',
            "delete": 'dtsb-delete',
            dropDown: 'dtsb-dropDown',
            greyscale: 'dtsb-greyscale',
            input: 'dtsb-input',
            inputCont: 'dtsb-inputCont',
            italic: 'dtsb-italic',
            joiner: 'dtsp-joiner',
            left: 'dtsb-left',
            notItalic: 'dtsb-notItalic',
            option: 'dtsb-option',
            right: 'dtsb-right',
            select: 'dtsb-select',
            value: 'dtsb-value',
            vertical: 'dtsb-vertical'
        };
        /**
         * Default initialisation function for select conditions
         */
        Criteria.initSelect = function (that, fn, preDefined, array) {
            if (preDefined === void 0) { preDefined = null; }
            if (array === void 0) { array = false; }
            var column = that.dom.data.children('option:selected').val();
            var indexArray = that.s.dt.rows().indexes().toArray();
            var settings = that.s.dt.settings()[0];
            that.dom.valueTitle.prop('selected', true);
            // Declare select element to be used with all of the default classes and listeners.
            var el = $$3('<select/>')
                .addClass(Criteria.classes.value)
                .addClass(Criteria.classes.dropDown)
                .addClass(Criteria.classes.italic)
                .addClass(Criteria.classes.select)
                .append(that.dom.valueTitle)
                .on('change.dtsb', function () {
                $$3(this).removeClass(Criteria.classes.italic);
                fn(that, this);
            });
            if (that.c.greyscale) {
                el.addClass(Criteria.classes.greyscale);
            }
            var added = [];
            var options = [];
            // Add all of the options from the table to the select element.
            // Only add one option for each possible value
            for (var _i = 0, indexArray_1 = indexArray; _i < indexArray_1.length; _i++) {
                var index = indexArray_1[_i];
                var filter = settings.oApi._fnGetCellData(settings, index, column, typeof that.c.orthogonal === 'string' ?
                    that.c.orthogonal :
                    that.c.orthogonal.search);
                var value = {
                    filter: typeof filter === 'string' ?
                        filter.replace(/[\r\n\u2028]/g, ' ') : // Need to replace certain characters to match search values
                        filter,
                    index: index,
                    text: settings.oApi._fnGetCellData(settings, index, column, typeof that.c.orthogonal === 'string' ?
                        that.c.orthogonal :
                        that.c.orthogonal.display)
                };
                // If we are dealing with an array type, either make sure we are working with arrays, or sort them
                if (that.s.type === 'array') {
                    value.filter = !Array.isArray(value.filter) ? [value.filter] : value.filter;
                    value.text = !Array.isArray(value.text) ? [value.text] : value.text;
                }
                // Function to add an option to the select element
                var addOption = function (filt, text) {
                    if (that.s.type.includes('html') && filt !== null && typeof filt === 'string') {
                        filt.replace(/(<([^>]+)>)/ig, '');
                    }
                    // Add text and value, stripping out any html if that is the column type
                    var opt = $$3('<option>', {
                        type: Array.isArray(filt) ? 'Array' : 'String',
                        value: filt
                    })
                        .data('sbv', filt)
                        .addClass(that.classes.option)
                        .addClass(that.classes.notItalic)
                        // Have to add the text this way so that special html characters are not escaped - &amp; etc.
                        .html(typeof text === 'string' ?
                        text.replace(/(<([^>]+)>)/ig, '') :
                        text);
                    var val = opt.val();
                    // Check that this value has not already been added
                    if (added.indexOf(val) === -1) {
                        added.push(val);
                        options.push(opt);
                        if (preDefined !== null && Array.isArray(preDefined[0])) {
                            preDefined[0] = preDefined[0].sort().join(',');
                        }
                        // If this value was previously selected as indicated by preDefined, then select it again
                        if (preDefined !== null && opt.val() === preDefined[0]) {
                            opt.prop('selected', true);
                            el.removeClass(Criteria.classes.italic);
                            that.dom.valueTitle.removeProp('selected');
                        }
                    }
                };
                // If this is to add the individual values within the array we need to loop over the array
                if (array) {
                    for (var i = 0; i < value.filter.length; i++) {
                        addOption(value.filter[i], value.text[i]);
                    }
                }
                // Otherwise the value that is in the cell is to be added
                else {
                    addOption(value.filter, Array.isArray(value.text) ? value.text.join(', ') : value.text);
                }
            }
            options.sort(function (a, b) {
                if (that.s.type === 'array' ||
                    that.s.type === 'string' ||
                    that.s.type === 'html') {
                    if (a.val() < b.val()) {
                        return -1;
                    }
                    else if (a.val() > b.val()) {
                        return 1;
                    }
                    else {
                        return 0;
                    }
                }
                else if (that.s.type === 'num' ||
                    that.s.type === 'html-num') {
                    if (+a.val().replace(/(<([^>]+)>)/ig, '') < +b.val().replace(/(<([^>]+)>)/ig, '')) {
                        return -1;
                    }
                    else if (+a.val().replace(/(<([^>]+)>)/ig, '') > +b.val().replace(/(<([^>]+)>)/ig, '')) {
                        return 1;
                    }
                    else {
                        return 0;
                    }
                }
                else if (that.s.type === 'num-fmt' || that.s.type === 'html-num-fmt') {
                    if (+a.val().replace(/[^0-9.]/g, '') < +b.val().replace(/[^0-9.]/g, '')) {
                        return -1;
                    }
                    else if (+a.val().replace(/[^0-9.]/g, '') > +b.val().replace(/[^0-9.]/g, '')) {
                        return 1;
                    }
                    else {
                        return 0;
                    }
                }
            });
            for (var _a = 0, options_1 = options; _a < options_1.length; _a++) {
                var opt = options_1[_a];
                el.append(opt);
            }
            return el;
        };
        /**
         * Default initialisation function for select conditions
         */
        Criteria.initSelectSSP = function (that, fn, preDefined) {
            if (preDefined === void 0) { preDefined = null; }
            that.dom.valueTitle.prop('selected', true);
            // Declare select element to be used with all of the default classes and listeners.
            var el = $$3('<select/>')
                .addClass(Criteria.classes.value)
                .addClass(Criteria.classes.dropDown)
                .addClass(Criteria.classes.italic)
                .addClass(Criteria.classes.select)
                .append(that.dom.valueTitle)
                .on('change.dtsb', function () {
                $$3(this).removeClass(Criteria.classes.italic);
                fn(that, this);
            });
            if (that.c.greyscale) {
                el.addClass(Criteria.classes.greyscale);
            }
            var options = [];
            for (var _i = 0, _a = that.s.serverData[that.s.origData]; _i < _a.length; _i++) {
                var option = _a[_i];
                var value = option.value;
                var label = option.label;
                // Function to add an option to the select element
                var addOption = function (filt, text) {
                    if (that.s.type.includes('html') && filt !== null && typeof filt === 'string') {
                        filt.replace(/(<([^>]+)>)/ig, '');
                    }
                    // Add text and value, stripping out any html if that is the column type
                    var opt = $$3('<option>', {
                        type: Array.isArray(filt) ? 'Array' : 'String',
                        value: filt
                    })
                        .data('sbv', filt)
                        .addClass(that.classes.option)
                        .addClass(that.classes.notItalic)
                        // Have to add the text this way so that special html characters are not escaped - &amp; etc.
                        .html(typeof text === 'string' ?
                        text.replace(/(<([^>]+)>)/ig, '') :
                        text);
                    options.push(opt);
                    // If this value was previously selected as indicated by preDefined, then select it again
                    if (preDefined !== null && opt.val() === preDefined[0]) {
                        opt.prop('selected', true);
                        el.removeClass(Criteria.classes.italic);
                        that.dom.valueTitle.removeProp('selected');
                    }
                };
                addOption(value, label);
            }
            for (var _b = 0, options_2 = options; _b < options_2.length; _b++) {
                var opt = options_2[_b];
                el.append(opt);
            }
            return el;
        };
        /**
         * Default initialisation function for select array conditions
         *
         * This exists because there needs to be different select functionality for contains/without and equals/not
         */
        Criteria.initSelectArray = function (that, fn, preDefined) {
            if (preDefined === void 0) { preDefined = null; }
            return Criteria.initSelect(that, fn, preDefined, true);
        };
        /**
         * Default initialisation function for input conditions
         */
        Criteria.initInput = function (that, fn, preDefined) {
            if (preDefined === void 0) { preDefined = null; }
            // Declare the input element
            var searchDelay = that.s.dt.settings()[0].searchDelay;
            var el = $$3('<input/>')
                .addClass(Criteria.classes.value)
                .addClass(Criteria.classes.input)
                .on('input.dtsb keypress.dtsb', that._throttle(function (e) {
                var code = e.keyCode || e.which;
                return fn(that, this, code);
            }, searchDelay === null ? 100 : searchDelay));
            if (that.c.greyscale) {
                el.addClass(Criteria.classes.greyscale);
            }
            // If there is a preDefined value then add it
            if (preDefined !== null) {
                el.val(preDefined[0]);
            }
            // This is add responsive functionality to the logic button without redrawing everything else
            that.s.dt.one('draw.dtsb', function () {
                that.s.topGroup.trigger('dtsb-redrawLogic');
            });
            return el;
        };
        /**
         * Default initialisation function for conditions requiring 2 inputs
         */
        Criteria.init2Input = function (that, fn, preDefined) {
            if (preDefined === void 0) { preDefined = null; }
            // Declare all of the necessary jQuery elements
            var searchDelay = that.s.dt.settings()[0].searchDelay;
            var els = [
                $$3('<input/>')
                    .addClass(Criteria.classes.value)
                    .addClass(Criteria.classes.input)
                    .on('input.dtsb keypress.dtsb', that._throttle(function (e) {
                    var code = e.keyCode || e.which;
                    return fn(that, this, code);
                }, searchDelay === null ? 100 : searchDelay)),
                $$3('<span>')
                    .addClass(that.classes.joiner)
                    .html(that.s.dt.i18n('searchBuilder.valueJoiner', that.c.i18n.valueJoiner)),
                $$3('<input/>')
                    .addClass(Criteria.classes.value)
                    .addClass(Criteria.classes.input)
                    .on('input.dtsb keypress.dtsb', that._throttle(function (e) {
                    var code = e.keyCode || e.which;
                    return fn(that, this, code);
                }, searchDelay === null ? 100 : searchDelay))
            ];
            if (that.c.greyscale) {
                els[0].addClass(Criteria.classes.greyscale);
                els[2].addClass(Criteria.classes.greyscale);
            }
            // If there is a preDefined value then add it
            if (preDefined !== null) {
                els[0].val(preDefined[0]);
                els[2].val(preDefined[1]);
            }
            // This is add responsive functionality to the logic button without redrawing everything else
            that.s.dt.one('draw.dtsb', function () {
                that.s.topGroup.trigger('dtsb-redrawLogic');
            });
            return els;
        };
        /**
         * Default initialisation function for date conditions
         */
        Criteria.initDate = function (that, fn, preDefined) {
            if (preDefined === void 0) { preDefined = null; }
            var searchDelay = that.s.dt.settings()[0].searchDelay;
            // Declare date element using DataTables dateTime plugin
            var el = $$3('<input/>')
                .addClass(Criteria.classes.value)
                .addClass(Criteria.classes.input)
                .dtDateTime({
                attachTo: 'input',
                format: that.s.dateFormat ? that.s.dateFormat : undefined
            })
                .on('change.dtsb', that._throttle(function () {
                return fn(that, this);
            }, searchDelay === null ? 100 : searchDelay))
                .on('input.dtsb keypress.dtsb', function (e) {
                that._throttle(function () {
                    var code = e.keyCode || e.which;
                    return fn(that, this, code);
                }, searchDelay === null ? 100 : searchDelay);
            });
            if (that.c.greyscale) {
                el.addClass(Criteria.classes.greyscale);
            }
            // If there is a preDefined value then add it
            if (preDefined !== null) {
                el.val(preDefined[0]);
            }
            // This is add responsive functionality to the logic button without redrawing everything else
            that.s.dt.one('draw.dtsb', function () {
                that.s.topGroup.trigger('dtsb-redrawLogic');
            });
            return el;
        };
        Criteria.initNoValue = function (that) {
            // This is add responsive functionality to the logic button without redrawing everything else
            that.s.dt.one('draw.dtsb', function () {
                that.s.topGroup.trigger('dtsb-redrawLogic');
            });
            return [];
        };
        Criteria.init2Date = function (that, fn, preDefined) {
            var _this = this;
            if (preDefined === void 0) { preDefined = null; }
            var searchDelay = that.s.dt.settings()[0].searchDelay;
            // Declare all of the date elements that are required using DataTables dateTime plugin
            var els = [
                $$3('<input/>')
                    .addClass(Criteria.classes.value)
                    .addClass(Criteria.classes.input)
                    .dtDateTime({
                    attachTo: 'input',
                    format: that.s.dateFormat ? that.s.dateFormat : undefined
                })
                    .on('change.dtsb', searchDelay !== null ?
                    that.s.dt.settings()[0].oApi._fnThrottle(function () {
                        return fn(that, this);
                    }, searchDelay) :
                    function () {
                        fn(that, _this);
                    })
                    .on('input.dtsb keypress.dtsb', function (e) {
                    that.s.dt.settings()[0].oApi._fnThrottle(function () {
                        var code = e.keyCode || e.which;
                        return fn(that, this, code);
                    }, searchDelay === null ? 0 : searchDelay);
                }),
                $$3('<span>')
                    .addClass(that.classes.joiner)
                    .html(that.s.dt.i18n('searchBuilder.valueJoiner', that.c.i18n.valueJoiner)),
                $$3('<input/>')
                    .addClass(Criteria.classes.value)
                    .addClass(Criteria.classes.input)
                    .dtDateTime({
                    attachTo: 'input',
                    format: that.s.dateFormat ? that.s.dateFormat : undefined
                })
                    .on('change.dtsb', searchDelay !== null ?
                    that.s.dt.settings()[0].oApi._fnThrottle(function () {
                        return fn(that, this);
                    }, searchDelay) :
                    function () {
                        fn(that, _this);
                    })
                    .on('input.dtsb keypress.dtsb', !that.c.enterSearch &&
                    !(that.s.dt.settings()[0].oInit.search !== undefined &&
                        that.s.dt.settings()[0].oInit.search["return"]) &&
                    searchDelay !== null ?
                    that.s.dt.settings()[0].oApi._fnThrottle(function () {
                        return fn(that, this);
                    }, searchDelay) :
                    function (e) {
                        var code = e.keyCode || e.which;
                        fn(that, _this, code);
                    })
            ];
            if (that.c.greyscale) {
                els[0].addClass(Criteria.classes.greyscale);
                els[2].addClass(Criteria.classes.greyscale);
            }
            // If there are and preDefined values then add them
            if (preDefined !== null && preDefined.length > 0) {
                els[0].val(preDefined[0]);
                els[2].val(preDefined[1]);
            }
            // This is add responsive functionality to the logic button without redrawing everything else
            that.s.dt.one('draw.dtsb', function () {
                that.s.topGroup.trigger('dtsb-redrawLogic');
            });
            return els;
        };
        /**
         * Default function for select elements to validate condition
         */
        Criteria.isInputValidSelect = function (el) {
            var allFilled = true;
            // Check each element to make sure that the selections are valid
            for (var _i = 0, el_1 = el; _i < el_1.length; _i++) {
                var element = el_1[_i];
                if (element.children('option:selected').length ===
                    element.children('option').length -
                        element.children('option.' + Criteria.classes.notItalic).length &&
                    element.children('option:selected').length === 1 &&
                    element.children('option:selected')[0] === element.children('option')[0]) {
                    allFilled = false;
                }
            }
            return allFilled;
        };
        /**
         * Default function for input and date elements to validate condition
         */
        Criteria.isInputValidInput = function (el) {
            var allFilled = true;
            // Check each element to make sure that the inputs are valid
            for (var _i = 0, el_2 = el; _i < el_2.length; _i++) {
                var element = el_2[_i];
                if (element.is('input') && element.val().length === 0) {
                    allFilled = false;
                }
            }
            return allFilled;
        };
        /**
         * Default function for getting select conditions
         */
        Criteria.inputValueSelect = function (el) {
            var values = [];
            // Go through the select elements and push each selected option to the return array
            for (var _i = 0, el_3 = el; _i < el_3.length; _i++) {
                var element = el_3[_i];
                if (element.is('select')) {
                    values.push(Criteria._escapeHTML(element.children('option:selected').data('sbv')));
                }
            }
            return values;
        };
        /**
         * Default function for getting input conditions
         */
        Criteria.inputValueInput = function (el) {
            var values = [];
            // Go through the input elements and push each value to the return array
            for (var _i = 0, el_4 = el; _i < el_4.length; _i++) {
                var element = el_4[_i];
                if (element.is('input')) {
                    values.push(Criteria._escapeHTML(element.val()));
                }
            }
            return values;
        };
        /**
         * Function that is run on each element as a call back when a search should be triggered
         */
        Criteria.updateListener = function (that, el, code) {
            // When the value is changed the criteria is now complete so can be included in searches
            // Get the condition from the map based on the key that has been selected for the condition
            var condition = that.s.conditions[that.s.condition];
            that.s.filled = condition.isInputValid(that.dom.value, that);
            that.s.value = condition.inputValue(that.dom.value, that);
            if (!that.s.filled) {
                if (!that.c.enterSearch &&
                    !(that.s.dt.settings()[0].oInit.search !== undefined &&
                        that.s.dt.settings()[0].oInit.search["return"]) ||
                    code === 13) {
                    that.s.dt.draw();
                }
                return;
            }
            if (!Array.isArray(that.s.value)) {
                that.s.value = [that.s.value];
            }
            for (var i = 0; i < that.s.value.length; i++) {
                // If the value is an array we need to sort it
                if (Array.isArray(that.s.value[i])) {
                    that.s.value[i].sort();
                }
                // Otherwise replace the decimal place character for i18n
                else if (that.s.type.includes('num') &&
                    (that.s.dt.settings()[0].oLanguage.sDecimal !== '' ||
                        that.s.dt.settings()[0].oLanguage.sThousands !== '')) {
                    var splitRD = [that.s.value[i].toString()];
                    if (that.s.dt.settings()[0].oLanguage.sDecimal !== '') {
                        splitRD = that.s.value[i].split(that.s.dt.settings()[0].oLanguage.sDecimal);
                    }
                    if (that.s.dt.settings()[0].oLanguage.sThousands !== '') {
                        for (var j = 0; j < splitRD.length; j++) {
                            splitRD[j] = splitRD[j].replace(that.s.dt.settings()[0].oLanguage.sThousands, ',');
                        }
                    }
                    that.s.value[i] = splitRD.join('.');
                }
            }
            // Take note of the cursor position so that we can refocus there later
            var idx = null;
            var cursorPos = null;
            for (var i = 0; i < that.dom.value.length; i++) {
                if (el === that.dom.value[i][0]) {
                    idx = i;
                    if (el.selectionStart !== undefined) {
                        cursorPos = el.selectionStart;
                    }
                }
            }
            if (!that.c.enterSearch &&
                !(that.s.dt.settings()[0].oInit.search !== undefined &&
                    that.s.dt.settings()[0].oInit.search["return"]) ||
                code === 13) {
                // Trigger a search
                that.s.dt.draw();
            }
            // Refocus the element and set the correct cursor position
            if (idx !== null) {
                that.dom.value[idx].removeClass(that.classes.italic);
                that.dom.value[idx].focus();
                if (cursorPos !== null) {
                    that.dom.value[idx][0].setSelectionRange(cursorPos, cursorPos);
                }
            }
        };
        // The order of the conditions will make eslint sad :(
        // Has to be in this order so that they are displayed correctly in select elements
        // Also have to disable member ordering for this as the private methods used are not yet declared otherwise
        // eslint-disable-next-line @typescript-eslint/member-ordering
        Criteria.dateConditions = {
            '=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.equals', i18n.conditions.date.equals);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    value = value.replace(/(\/|-|,)/g, '-');
                    return value === comparison[0];
                }
            },
            // eslint-disable-next-line sort-keys
            '!=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.not', i18n.conditions.date.not);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    value = value.replace(/(\/|-|,)/g, '-');
                    return value !== comparison[0];
                }
            },
            '<': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.before', i18n.conditions.date.before);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    value = value.replace(/(\/|-|,)/g, '-');
                    return value < comparison[0];
                }
            },
            '>': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.after', i18n.conditions.date.after);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    value = value.replace(/(\/|-|,)/g, '-');
                    return value > comparison[0];
                }
            },
            'between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.between', i18n.conditions.date.between);
                },
                init: Criteria.init2Date,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    value = value.replace(/(\/|-|,)/g, '-');
                    if (comparison[0] < comparison[1]) {
                        return comparison[0] <= value && value <= comparison[1];
                    }
                    else {
                        return comparison[1] <= value && value <= comparison[0];
                    }
                }
            },
            // eslint-disable-next-line sort-keys
            '!between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.notBetween', i18n.conditions.date.notBetween);
                },
                init: Criteria.init2Date,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    value = value.replace(/(\/|-|,)/g, '-');
                    if (comparison[0] < comparison[1]) {
                        return !(comparison[0] <= value && value <= comparison[1]);
                    }
                    else {
                        return !(comparison[1] <= value && value <= comparison[0]);
                    }
                }
            },
            'null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.empty', i18n.conditions.date.empty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return value === null || value === undefined || value.length === 0;
                }
            },
            // eslint-disable-next-line sort-keys
            '!null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.notEmpty', i18n.conditions.date.notEmpty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return !(value === null || value === undefined || value.length === 0);
                }
            }
        };
        // The order of the conditions will make eslint sad :(
        // Has to be in this order so that they are displayed correctly in select elements
        // Also have to disable member ordering for this as the private methods used are not yet declared otherwise
        // eslint-disable-next-line @typescript-eslint/member-ordering
        Criteria.momentDateConditions = {
            '=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.equals', i18n.conditions.date.equals);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    return moment()(value, that.s.dateFormat).valueOf() ===
                        moment()(comparison[0], that.s.dateFormat).valueOf();
                }
            },
            // eslint-disable-next-line sort-keys
            '!=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.not', i18n.conditions.date.not);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    return moment()(value, that.s.dateFormat).valueOf() !==
                        moment()(comparison[0], that.s.dateFormat).valueOf();
                }
            },
            '<': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.before', i18n.conditions.date.before);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    return moment()(value, that.s.dateFormat).valueOf() < moment()(comparison[0], that.s.dateFormat).valueOf();
                }
            },
            '>': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.after', i18n.conditions.date.after);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    return moment()(value, that.s.dateFormat).valueOf() > moment()(comparison[0], that.s.dateFormat).valueOf();
                }
            },
            'between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.between', i18n.conditions.date.between);
                },
                init: Criteria.init2Date,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    var val = moment()(value, that.s.dateFormat).valueOf();
                    var comp0 = moment()(comparison[0], that.s.dateFormat).valueOf();
                    var comp1 = moment()(comparison[1], that.s.dateFormat).valueOf();
                    if (comp0 < comp1) {
                        return comp0 <= val && val <= comp1;
                    }
                    else {
                        return comp1 <= val && val <= comp0;
                    }
                }
            },
            // eslint-disable-next-line sort-keys
            '!between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.notBetween', i18n.conditions.date.notBetween);
                },
                init: Criteria.init2Date,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    var val = moment()(value, that.s.dateFormat).valueOf();
                    var comp0 = moment()(comparison[0], that.s.dateFormat).valueOf();
                    var comp1 = moment()(comparison[1], that.s.dateFormat).valueOf();
                    if (comp0 < comp1) {
                        return !(+comp0 <= +val && +val <= +comp1);
                    }
                    else {
                        return !(+comp1 <= +val && +val <= +comp0);
                    }
                }
            },
            'null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.empty', i18n.conditions.date.empty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return value === null || value === undefined || value.length === 0;
                }
            },
            // eslint-disable-next-line sort-keys
            '!null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.notEmpty', i18n.conditions.date.notEmpty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return !(value === null || value === undefined || value.length === 0);
                }
            }
        };
        // The order of the conditions will make eslint sad :(
        // Has to be in this order so that they are displayed correctly in select elements
        // Also have to disable member ordering for this as the private methods used are not yet declared otherwise
        // eslint-disable-next-line @typescript-eslint/member-ordering
        Criteria.luxonDateConditions = {
            '=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.equals', i18n.conditions.date.equals);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    return luxon().DateTime.fromFormat(value, that.s.dateFormat).ts
                        === luxon().DateTime.fromFormat(comparison[0], that.s.dateFormat).ts;
                }
            },
            // eslint-disable-next-line sort-keys
            '!=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.not', i18n.conditions.date.not);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    return luxon().DateTime.fromFormat(value, that.s.dateFormat).ts
                        !== luxon().DateTime.fromFormat(comparison[0], that.s.dateFormat).ts;
                }
            },
            '<': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.before', i18n.conditions.date.before);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    return luxon().DateTime.fromFormat(value, that.s.dateFormat).ts
                        < luxon().DateTime.fromFormat(comparison[0], that.s.dateFormat).ts;
                }
            },
            '>': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.after', i18n.conditions.date.after);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    return luxon().DateTime.fromFormat(value, that.s.dateFormat).ts
                        > luxon().DateTime.fromFormat(comparison[0], that.s.dateFormat).ts;
                }
            },
            'between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.between', i18n.conditions.date.between);
                },
                init: Criteria.init2Date,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    var val = luxon().DateTime.fromFormat(value, that.s.dateFormat).ts;
                    var comp0 = luxon().DateTime.fromFormat(comparison[0], that.s.dateFormat).ts;
                    var comp1 = luxon().DateTime.fromFormat(comparison[1], that.s.dateFormat).ts;
                    if (comp0 < comp1) {
                        return comp0 <= val && val <= comp1;
                    }
                    else {
                        return comp1 <= val && val <= comp0;
                    }
                }
            },
            // eslint-disable-next-line sort-keys
            '!between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.notBetween', i18n.conditions.date.notBetween);
                },
                init: Criteria.init2Date,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    var val = luxon().DateTime.fromFormat(value, that.s.dateFormat).ts;
                    var comp0 = luxon().DateTime.fromFormat(comparison[0], that.s.dateFormat).ts;
                    var comp1 = luxon().DateTime.fromFormat(comparison[1], that.s.dateFormat).ts;
                    if (comp0 < comp1) {
                        return !(+comp0 <= +val && +val <= +comp1);
                    }
                    else {
                        return !(+comp1 <= +val && +val <= +comp0);
                    }
                }
            },
            'null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.empty', i18n.conditions.date.empty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return value === null || value === undefined || value.length === 0;
                }
            },
            // eslint-disable-next-line sort-keys
            '!null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.notEmpty', i18n.conditions.date.notEmpty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return !(value === null || value === undefined || value.length === 0);
                }
            }
        };
        // The order of the conditions will make eslint sad :(
        // Has to be in this order so that they are displayed correctly in select elements
        // Also have to disable member ordering for this as the private methods used are not yet declared otherwise
        // eslint-disable-next-line @typescript-eslint/member-ordering
        Criteria.numConditions = {
            '=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.equals', i18n.conditions.number.equals);
                },
                init: Criteria.initSelect,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidSelect,
                search: function (value, comparison) {
                    return +value === +comparison[0];
                }
            },
            // eslint-disable-next-line sort-keys
            '!=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.not', i18n.conditions.number.not);
                },
                init: Criteria.initSelect,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidSelect,
                search: function (value, comparison) {
                    return +value !== +comparison[0];
                }
            },
            '<': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.lt', i18n.conditions.number.lt);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return +value < +comparison[0];
                }
            },
            '<=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.lte', i18n.conditions.number.lte);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return +value <= +comparison[0];
                }
            },
            '>=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.gte', i18n.conditions.number.gte);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return +value >= +comparison[0];
                }
            },
            // eslint-disable-next-line sort-keys
            '>': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.gt', i18n.conditions.number.gt);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return +value > +comparison[0];
                }
            },
            'between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.between', i18n.conditions.number.between);
                },
                init: Criteria.init2Input,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    if (+comparison[0] < +comparison[1]) {
                        return +comparison[0] <= +value && +value <= +comparison[1];
                    }
                    else {
                        return +comparison[1] <= +value && +value <= +comparison[0];
                    }
                }
            },
            // eslint-disable-next-line sort-keys
            '!between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.notBetween', i18n.conditions.number.notBetween);
                },
                init: Criteria.init2Input,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    if (+comparison[0] < +comparison[1]) {
                        return !(+comparison[0] <= +value && +value <= +comparison[1]);
                    }
                    else {
                        return !(+comparison[1] <= +value && +value <= +comparison[0]);
                    }
                }
            },
            'null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.empty', i18n.conditions.number.empty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return value === null || value === undefined || value.length === 0;
                }
            },
            // eslint-disable-next-line sort-keys
            '!null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.notEmpty', i18n.conditions.number.notEmpty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return !(value === null || value === undefined || value.length === 0);
                }
            }
        };
        // The order of the conditions will make eslint sad :(
        // Has to be in this order so that they are displayed correctly in select elements
        // Also have to disable member ordering for this as the private methods used are not yet declared otherwise
        // eslint-disable-next-line @typescript-eslint/member-ordering
        Criteria.numFmtConditions = {
            '=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.equals', i18n.conditions.number.equals);
                },
                init: Criteria.initSelect,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidSelect,
                search: function (value, comparison) {
                    return Criteria.parseNumFmt(value) === Criteria.parseNumFmt(comparison[0]);
                }
            },
            // eslint-disable-next-line sort-keys
            '!=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.not', i18n.conditions.number.not);
                },
                init: Criteria.initSelect,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidSelect,
                search: function (value, comparison) {
                    return Criteria.parseNumFmt(value) !== Criteria.parseNumFmt(comparison[0]);
                }
            },
            '<': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.lt', i18n.conditions.number.lt);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return Criteria.parseNumFmt(value) < Criteria.parseNumFmt(comparison[0]);
                }
            },
            '<=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.lte', i18n.conditions.number.lte);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return Criteria.parseNumFmt(value) <= Criteria.parseNumFmt(comparison[0]);
                }
            },
            '>=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.gte', i18n.conditions.number.gte);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return Criteria.parseNumFmt(value) >= Criteria.parseNumFmt(comparison[0]);
                }
            },
            // eslint-disable-next-line sort-keys
            '>': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.gt', i18n.conditions.number.gt);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return Criteria.parseNumFmt(value) > Criteria.parseNumFmt(comparison[0]);
                }
            },
            'between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.between', i18n.conditions.number.between);
                },
                init: Criteria.init2Input,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    var val = Criteria.parseNumFmt(value);
                    var comp0 = Criteria.parseNumFmt(comparison[0]);
                    var comp1 = Criteria.parseNumFmt(comparison[1]);
                    if (+comp0 < +comp1) {
                        return +comp0 <= +val && +val <= +comp1;
                    }
                    else {
                        return +comp1 <= +val && +val <= +comp0;
                    }
                }
            },
            // eslint-disable-next-line sort-keys
            '!between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.notBetween', i18n.conditions.number.notBetween);
                },
                init: Criteria.init2Input,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    var val = Criteria.parseNumFmt(value);
                    var comp0 = Criteria.parseNumFmt(comparison[0]);
                    var comp1 = Criteria.parseNumFmt(comparison[1]);
                    if (+comp0 < +comp1) {
                        return !(+comp0 <= +val && +val <= +comp1);
                    }
                    else {
                        return !(+comp1 <= +val && +val <= +comp0);
                    }
                }
            },
            'null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.empty', i18n.conditions.number.empty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return value === null || value === undefined || value.length === 0;
                }
            },
            // eslint-disable-next-line sort-keys
            '!null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.notEmpty', i18n.conditions.number.notEmpty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return !(value === null || value === undefined || value.length === 0);
                }
            }
        };
        // The order of the conditions will make eslint sad :(
        // Has to be in this order so that they are displayed correctly in select elements
        // Also have to disable member ordering for this as the private methods used are not yet declared otherwise
        // eslint-disable-next-line @typescript-eslint/member-ordering
        Criteria.stringConditions = {
            '=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.string.equals', i18n.conditions.string.equals);
                },
                init: Criteria.initSelect,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidSelect,
                search: function (value, comparison) {
                    return value === comparison[0];
                }
            },
            // eslint-disable-next-line sort-keys
            '!=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.string.not', i18n.conditions.string.not);
                },
                init: Criteria.initSelect,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return value !== comparison[0];
                }
            },
            'starts': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.string.startsWith', i18n.conditions.string.startsWith);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return value.toLowerCase().indexOf(comparison[0].toLowerCase()) === 0;
                }
            },
            // eslint-disable-next-line sort-keys
            '!starts': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.string.notStartsWith', i18n.conditions.string.notStartsWith);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return value.toLowerCase().indexOf(comparison[0].toLowerCase()) !== 0;
                }
            },
            // eslint-disable-next-line sort-keys
            'contains': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.string.contains', i18n.conditions.string.contains);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return value.toLowerCase().includes(comparison[0].toLowerCase());
                }
            },
            // eslint-disable-next-line sort-keys
            '!contains': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.string.notContains', i18n.conditions.string.notContains);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return !value.toLowerCase().includes(comparison[0].toLowerCase());
                }
            },
            'ends': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.string.endsWith', i18n.conditions.string.endsWith);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return value.toLowerCase().endsWith(comparison[0].toLowerCase());
                }
            },
            // eslint-disable-next-line sort-keys
            '!ends': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.string.notEndsWith', i18n.conditions.string.notEndsWith);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return !value.toLowerCase().endsWith(comparison[0].toLowerCase());
                }
            },
            'null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.string.empty', i18n.conditions.string.empty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return value === null || value === undefined || value.length === 0;
                }
            },
            // eslint-disable-next-line sort-keys
            '!null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.string.notEmpty', i18n.conditions.string.notEmpty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return !(value === null || value === undefined || value.length === 0);
                }
            }
        };
        // The order of the conditions will make eslint sad :(
        // Also have to disable member ordering for this as the private methods used are not yet declared otherwise
        // eslint-disable-next-line @typescript-eslint/member-ordering
        Criteria.arrayConditions = {
            'contains': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.array.contains', i18n.conditions.array.contains);
                },
                init: Criteria.initSelectArray,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidSelect,
                search: function (value, comparison) {
                    return value.includes(comparison[0]);
                }
            },
            'without': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.array.without', i18n.conditions.array.without);
                },
                init: Criteria.initSelectArray,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidSelect,
                search: function (value, comparison) {
                    return value.indexOf(comparison[0]) === -1;
                }
            },
            // eslint-disable-next-line sort-keys
            '=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.array.equals', i18n.conditions.array.equals);
                },
                init: Criteria.initSelect,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidSelect,
                search: function (value, comparison) {
                    if (value.length === comparison[0].length) {
                        for (var i = 0; i < value.length; i++) {
                            if (value[i] !== comparison[0][i]) {
                                return false;
                            }
                        }
                        return true;
                    }
                    return false;
                }
            },
            // eslint-disable-next-line sort-keys
            '!=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.array.not', i18n.conditions.array.not);
                },
                init: Criteria.initSelect,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidSelect,
                search: function (value, comparison) {
                    if (value.length === comparison[0].length) {
                        for (var i = 0; i < value.length; i++) {
                            if (value[i] !== comparison[0][i]) {
                                return true;
                            }
                        }
                        return false;
                    }
                    return true;
                }
            },
            'null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.array.empty', i18n.conditions.array.empty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return value === null || value === undefined || value.length === 0;
                }
            },
            // eslint-disable-next-line sort-keys
            '!null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.array.notEmpty', i18n.conditions.array.notEmpty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return value !== null && value !== undefined && value.length !== 0;
                }
            }
        };
        // eslint will be sad because we have to disable member ordering for this as the
        // private static properties used are not yet declared otherwise
        // eslint-disable-next-line @typescript-eslint/member-ordering
        Criteria.defaults = {
            columns: true,
            conditions: {
                'array': Criteria.arrayConditions,
                'date': Criteria.dateConditions,
                'html': Criteria.stringConditions,
                'html-num': Criteria.numConditions,
                'html-num-fmt': Criteria.numFmtConditions,
                'luxon': Criteria.luxonDateConditions,
                'moment': Criteria.momentDateConditions,
                'num': Criteria.numConditions,
                'num-fmt': Criteria.numFmtConditions,
                'string': Criteria.stringConditions
            },
            depthLimit: false,
            enterSearch: false,
            filterChanged: undefined,
            greyscale: false,
            i18n: {
                add: 'Add Condition',
                button: {
                    0: 'Search Builder',
                    _: 'Search Builder (%d)'
                },
                clearAll: 'Clear All',
                condition: 'Condition',
                data: 'Data',
                "delete": '&times',
                deleteTitle: 'Delete filtering rule',
                left: '<',
                leftTitle: 'Outdent criteria',
                logicAnd: 'And',
                logicOr: 'Or',
                right: '>',
                rightTitle: 'Indent criteria',
                title: {
                    0: 'Custom Search Builder',
                    _: 'Custom Search Builder (%d)'
                },
                value: 'Value',
                valueJoiner: 'and'
            },
            logic: 'AND',
            orthogonal: {
                display: 'display',
                search: 'filter'
            },
            preDefined: false
        };
        return Criteria;
    }());

    var $$2;
    var dataTable$2;
    /**
     * Sets the value of jQuery for use in the file
     *
     * @param jq the instance of jQuery to be set
     */
    function setJQuery$1(jq) {
        $$2 = jq;
        dataTable$2 = jq.fn.dataTable;
    }
    /**
     * The Group class is used within SearchBuilder to represent a group of criteria
     */
    var Group = /** @class */ (function () {
        function Group(table, opts, topGroup, index, isChild, depth, serverData) {
            if (index === void 0) { index = 0; }
            if (isChild === void 0) { isChild = false; }
            if (depth === void 0) { depth = 1; }
            if (serverData === void 0) { serverData = undefined; }
            // Check that the required version of DataTables is included
            if (!dataTable$2 || !dataTable$2.versionCheck || !dataTable$2.versionCheck('1.10.0')) {
                throw new Error('SearchBuilder requires DataTables 1.10 or newer');
            }
            this.classes = $$2.extend(true, {}, Group.classes);
            // Get options from user
            this.c = $$2.extend(true, {}, Group.defaults, opts);
            this.s = {
                criteria: [],
                depth: depth,
                dt: table,
                index: index,
                isChild: isChild,
                logic: undefined,
                opts: opts,
                preventRedraw: false,
                serverData: serverData,
                toDrop: undefined,
                topGroup: topGroup
            };
            this.dom = {
                add: $$2('<button/>')
                    .addClass(this.classes.add)
                    .addClass(this.classes.button)
                    .attr('type', 'button'),
                clear: $$2('<button>&times</button>')
                    .addClass(this.classes.button)
                    .addClass(this.classes.clearGroup)
                    .attr('type', 'button'),
                container: $$2('<div/>')
                    .addClass(this.classes.group),
                logic: $$2('<button><div/></button>')
                    .addClass(this.classes.logic)
                    .addClass(this.classes.button)
                    .attr('type', 'button'),
                logicContainer: $$2('<div/>')
                    .addClass(this.classes.logicContainer)
            };
            // A reference to the top level group is maintained throughout any subgroups and criteria that may be created
            if (this.s.topGroup === undefined) {
                this.s.topGroup = this.dom.container;
            }
            this._setup();
            return this;
        }
        /**
         * Destroys the groups buttons, clears the internal criteria and removes it from the dom
         */
        Group.prototype.destroy = function () {
            // Turn off listeners
            this.dom.add.off('.dtsb');
            this.dom.logic.off('.dtsb');
            // Trigger event for groups at a higher level to pick up on
            this.dom.container
                .trigger('dtsb-destroy')
                .remove();
            this.s.criteria = [];
        };
        /**
         * Gets the details required to rebuild the group
         */
        // Eslint upset at empty object but needs to be done
        // eslint-disable-next-line @typescript-eslint/ban-types
        Group.prototype.getDetails = function (deFormatDates) {
            if (deFormatDates === void 0) { deFormatDates = false; }
            if (this.s.criteria.length === 0) {
                return {};
            }
            var details = {
                criteria: [],
                logic: this.s.logic
            };
            // NOTE here crit could be either a subgroup or a criteria
            for (var _i = 0, _a = this.s.criteria; _i < _a.length; _i++) {
                var crit = _a[_i];
                details.criteria.push(crit.criteria.getDetails(deFormatDates));
            }
            return details;
        };
        /**
         * Getter for the node for the container of the group
         *
         * @returns Node for the container of the group
         */
        Group.prototype.getNode = function () {
            return this.dom.container;
        };
        /**
         * Rebuilds the group based upon the details passed in
         *
         * @param loadedDetails the details required to rebuild the group
         */
        Group.prototype.rebuild = function (loadedDetails) {
            // If no criteria are stored then just return
            if (loadedDetails.criteria === undefined ||
                loadedDetails.criteria === null ||
                Array.isArray(loadedDetails.criteria) && loadedDetails.criteria.length === 0) {
                return;
            }
            this.s.logic = loadedDetails.logic;
            this.dom.logic.children().first().html(this.s.logic === 'OR'
                ? this.s.dt.i18n('searchBuilder.logicOr', this.c.i18n.logicOr)
                : this.s.dt.i18n('searchBuilder.logicAnd', this.c.i18n.logicAnd));
            // Add all of the criteria, be it a sub group or a criteria
            if (Array.isArray(loadedDetails.criteria)) {
                for (var _i = 0, _a = loadedDetails.criteria; _i < _a.length; _i++) {
                    var crit = _a[_i];
                    if (crit.logic !== undefined) {
                        this._addPrevGroup(crit);
                    }
                    else if (crit.logic === undefined) {
                        this._addPrevCriteria(crit);
                    }
                }
            }
            // For all of the criteria children, update the arrows incase they require changing and set the listeners
            for (var _b = 0, _c = this.s.criteria; _b < _c.length; _b++) {
                var crit = _c[_b];
                if (crit.criteria instanceof Criteria) {
                    crit.criteria.updateArrows(this.s.criteria.length > 1);
                    this._setCriteriaListeners(crit.criteria);
                }
            }
        };
        /**
         * Redraws the Contents of the searchBuilder Groups and Criteria
         */
        Group.prototype.redrawContents = function () {
            if (this.s.preventRedraw) {
                return;
            }
            // Clear the container out and add the basic elements
            this.dom.container.children().detach();
            this.dom.container
                .append(this.dom.logicContainer)
                .append(this.dom.add);
            // Sort the criteria by index so that they appear in the correct order
            this.s.criteria.sort(function (a, b) {
                if (a.criteria.s.index < b.criteria.s.index) {
                    return -1;
                }
                else if (a.criteria.s.index > b.criteria.s.index) {
                    return 1;
                }
                return 0;
            });
            this.setListeners();
            for (var i = 0; i < this.s.criteria.length; i++) {
                var crit = this.s.criteria[i].criteria;
                if (crit instanceof Criteria) {
                    // Reset the index to the new value
                    this.s.criteria[i].index = i;
                    this.s.criteria[i].criteria.s.index = i;
                    // Add to the group
                    this.s.criteria[i].criteria.dom.container.insertBefore(this.dom.add);
                    // Set listeners for various points
                    this._setCriteriaListeners(crit);
                    this.s.criteria[i].criteria.s.preventRedraw = this.s.preventRedraw;
                    this.s.criteria[i].criteria.rebuild(this.s.criteria[i].criteria.getDetails());
                    this.s.criteria[i].criteria.s.preventRedraw = false;
                }
                else if (crit instanceof Group && crit.s.criteria.length > 0) {
                    // Reset the index to the new value
                    this.s.criteria[i].index = i;
                    this.s.criteria[i].criteria.s.index = i;
                    // Add the sub group to the group
                    this.s.criteria[i].criteria.dom.container.insertBefore(this.dom.add);
                    // Redraw the contents of the group
                    crit.s.preventRedraw = this.s.preventRedraw;
                    crit.redrawContents();
                    crit.s.preventRedraw = false;
                    this._setGroupListeners(crit);
                }
                else {
                    // The group is empty so remove it
                    this.s.criteria.splice(i, 1);
                    i--;
                }
            }
            this.setupLogic();
        };
        /**
         * Resizes the logic button only rather than the entire dom.
         */
        Group.prototype.redrawLogic = function () {
            for (var _i = 0, _a = this.s.criteria; _i < _a.length; _i++) {
                var crit = _a[_i];
                if (crit.criteria instanceof Group) {
                    crit.criteria.redrawLogic();
                }
            }
            this.setupLogic();
        };
        /**
         * Search method, checking the row data against the criteria in the group
         *
         * @param rowData The row data to be compared
         * @returns boolean The result of the search
         */
        Group.prototype.search = function (rowData, rowIdx) {
            if (this.s.logic === 'AND') {
                return this._andSearch(rowData, rowIdx);
            }
            else if (this.s.logic === 'OR') {
                return this._orSearch(rowData, rowIdx);
            }
            return true;
        };
        /**
         * Locates the groups logic button to the correct location on the page
         */
        Group.prototype.setupLogic = function () {
            // Remove logic button
            this.dom.logicContainer.remove();
            this.dom.clear.remove();
            // If there are no criteria in the group then keep the logic removed and return
            if (this.s.criteria.length < 1) {
                if (!this.s.isChild) {
                    this.dom.container.trigger('dtsb-destroy');
                    // Set criteria left margin
                    this.dom.container.css('margin-left', 0);
                }
                return;
            }
            this.dom.clear.height('0px');
            this.dom.logicContainer.append(this.dom.clear);
            // Prepend logic button
            this.dom.container.prepend(this.dom.logicContainer);
            for (var _i = 0, _a = this.s.criteria; _i < _a.length; _i++) {
                var crit = _a[_i];
                if (crit.criteria instanceof Criteria) {
                    crit.criteria.setupButtons();
                }
            }
            // Set width, take 2 for the border
            var height = this.dom.container.outerHeight() - 1;
            this.dom.logicContainer.width(height);
            this._setLogicListener();
            // Set criteria left margin
            this.dom.container.css('margin-left', this.dom.logicContainer.outerHeight(true));
            var logicOffset = this.dom.logicContainer.offset();
            // Set horizontal alignment
            var currentLeft = logicOffset.left;
            var groupLeft = this.dom.container.offset().left;
            var shuffleLeft = currentLeft - groupLeft;
            var newPos = currentLeft - shuffleLeft - this.dom.logicContainer.outerHeight(true);
            this.dom.logicContainer.offset({ left: newPos });
            // Set vertical alignment
            var firstCrit = this.dom.logicContainer.next();
            var currentTop = logicOffset.top;
            var firstTop = $$2(firstCrit).offset().top;
            var shuffleTop = currentTop - firstTop;
            var newTop = currentTop - shuffleTop;
            this.dom.logicContainer.offset({ top: newTop });
            this.dom.clear.outerHeight(this.dom.logicContainer.height());
            this._setClearListener();
        };
        /**
         * Sets listeners on the groups elements
         */
        Group.prototype.setListeners = function () {
            var _this = this;
            this.dom.add.unbind('click');
            this.dom.add.on('click.dtsb', function () {
                // If this is the parent group then the logic button has not been added yet
                if (!_this.s.isChild) {
                    _this.dom.container.prepend(_this.dom.logicContainer);
                }
                _this.addCriteria();
                _this.dom.container.trigger('dtsb-add');
                _this.s.dt.state.save();
                return false;
            });
            for (var _i = 0, _a = this.s.criteria; _i < _a.length; _i++) {
                var crit = _a[_i];
                crit.criteria.setListeners();
            }
            this._setClearListener();
            this._setLogicListener();
        };
        /**
         * Adds a criteria to the group
         *
         * @param crit Instance of Criteria to be added to the group
         */
        Group.prototype.addCriteria = function (crit) {
            if (crit === void 0) { crit = null; }
            var index = crit === null ? this.s.criteria.length : crit.s.index;
            var criteria = new Criteria(this.s.dt, this.s.opts, this.s.topGroup, index, this.s.depth, this.s.serverData);
            // If a Criteria has been passed in then set the values to continue that
            if (crit !== null) {
                criteria.c = crit.c;
                criteria.s = crit.s;
                criteria.s.depth = this.s.depth;
                criteria.classes = crit.classes;
            }
            criteria.populate();
            var inserted = false;
            for (var i = 0; i < this.s.criteria.length; i++) {
                if (i === 0 && this.s.criteria[i].criteria.s.index > criteria.s.index) {
                    // Add the node for the criteria at the start of the group
                    criteria.getNode().insertBefore(this.s.criteria[i].criteria.dom.container);
                    inserted = true;
                }
                else if (i < this.s.criteria.length - 1 &&
                    this.s.criteria[i].criteria.s.index < criteria.s.index &&
                    this.s.criteria[i + 1].criteria.s.index > criteria.s.index) {
                    // Add the node for the criteria in the correct location
                    criteria.getNode().insertAfter(this.s.criteria[i].criteria.dom.container);
                    inserted = true;
                }
            }
            if (!inserted) {
                criteria.getNode().insertBefore(this.dom.add);
            }
            // Add the details for this criteria to the array
            this.s.criteria.push({
                criteria: criteria,
                index: index
            });
            this.s.criteria = this.s.criteria.sort(function (a, b) { return a.criteria.s.index - b.criteria.s.index; });
            for (var _i = 0, _a = this.s.criteria; _i < _a.length; _i++) {
                var opt = _a[_i];
                if (opt.criteria instanceof Criteria) {
                    opt.criteria.updateArrows(this.s.criteria.length > 1);
                }
            }
            this._setCriteriaListeners(criteria);
            criteria.setListeners();
            this.setupLogic();
        };
        /**
         * Checks the group to see if it has any filled criteria
         */
        Group.prototype.checkFilled = function () {
            for (var _i = 0, _a = this.s.criteria; _i < _a.length; _i++) {
                var crit = _a[_i];
                if (crit.criteria instanceof Criteria && crit.criteria.s.filled ||
                    crit.criteria instanceof Group && crit.criteria.checkFilled()) {
                    return true;
                }
            }
            return false;
        };
        /**
         * Gets the count for the number of criteria in this group and any sub groups
         */
        Group.prototype.count = function () {
            var count = 0;
            for (var _i = 0, _a = this.s.criteria; _i < _a.length; _i++) {
                var crit = _a[_i];
                if (crit.criteria instanceof Group) {
                    count += crit.criteria.count();
                }
                else {
                    count++;
                }
            }
            return count;
        };
        /**
         * Rebuilds a sub group that previously existed
         *
         * @param loadedGroup The details of a group within this group
         */
        Group.prototype._addPrevGroup = function (loadedGroup) {
            var idx = this.s.criteria.length;
            var group = new Group(this.s.dt, this.c, this.s.topGroup, idx, true, this.s.depth + 1, this.s.serverData);
            // Add the new group to the criteria array
            this.s.criteria.push({
                criteria: group,
                index: idx,
                logic: group.s.logic
            });
            // Rebuild it with the previous conditions for that group
            group.rebuild(loadedGroup);
            this.s.criteria[idx].criteria = group;
            this.s.topGroup.trigger('dtsb-redrawContents');
            this._setGroupListeners(group);
        };
        /**
         * Rebuilds a criteria of this group that previously existed
         *
         * @param loadedCriteria The details of a criteria within the group
         */
        Group.prototype._addPrevCriteria = function (loadedCriteria) {
            var idx = this.s.criteria.length;
            var criteria = new Criteria(this.s.dt, this.s.opts, this.s.topGroup, idx, this.s.depth, this.s.serverData);
            criteria.populate();
            // Add the new criteria to the criteria array
            this.s.criteria.push({
                criteria: criteria,
                index: idx
            });
            // Rebuild it with the previous conditions for that criteria
            criteria.s.preventRedraw = this.s.preventRedraw;
            criteria.rebuild(loadedCriteria);
            criteria.s.preventRedraw = false;
            this.s.criteria[idx].criteria = criteria;
            if (!this.s.preventRedraw) {
                this.s.topGroup.trigger('dtsb-redrawContents');
            }
        };
        /**
         * Checks And the criteria using AND logic
         *
         * @param rowData The row data to be checked against the search criteria
         * @returns boolean The result of the AND search
         */
        Group.prototype._andSearch = function (rowData, rowIdx) {
            // If there are no criteria then return true for this group
            if (this.s.criteria.length === 0) {
                return true;
            }
            for (var _i = 0, _a = this.s.criteria; _i < _a.length; _i++) {
                var crit = _a[_i];
                // If the criteria is not complete then skip it
                if (crit.criteria instanceof Criteria && !crit.criteria.s.filled) {
                    continue;
                }
                // Otherwise if a single one fails return false
                else if (!crit.criteria.search(rowData, rowIdx)) {
                    return false;
                }
            }
            // If we get to here then everything has passed, so return true for the group
            return true;
        };
        /**
         * Checks And the criteria using OR logic
         *
         * @param rowData The row data to be checked against the search criteria
         * @returns boolean The result of the OR search
         */
        Group.prototype._orSearch = function (rowData, rowIdx) {
            // If there are no criteria in the group then return true
            if (this.s.criteria.length === 0) {
                return true;
            }
            // This will check to make sure that at least one criteria in the group is complete
            var filledfound = false;
            for (var _i = 0, _a = this.s.criteria; _i < _a.length; _i++) {
                var crit = _a[_i];
                if (crit.criteria instanceof Criteria && crit.criteria.s.filled) {
                    // A completed criteria has been found so set the flag
                    filledfound = true;
                    // If the search passes then return true
                    if (crit.criteria.search(rowData, rowIdx)) {
                        return true;
                    }
                }
                else if (crit.criteria instanceof Group && crit.criteria.checkFilled()) {
                    filledfound = true;
                    if (crit.criteria.search(rowData, rowIdx)) {
                        return true;
                    }
                }
            }
            // If we get here we need to return the inverse of filledfound,
            //  as if any have been found and we are here then none have passed
            return !filledfound;
        };
        /**
         * Removes a criteria from the group
         *
         * @param criteria The criteria instance to be removed
         */
        Group.prototype._removeCriteria = function (criteria, group) {
            if (group === void 0) { group = false; }
            // If removing a criteria and there is only then then just destroy the group
            if (this.s.criteria.length <= 1 && this.s.isChild) {
                this.destroy();
            }
            else {
                // Otherwise splice the given criteria out and redo the indexes
                var last = void 0;
                for (var i = 0; i < this.s.criteria.length; i++) {
                    if (this.s.criteria[i].index === criteria.s.index &&
                        (!group || this.s.criteria[i].criteria instanceof Group)) {
                        last = i;
                    }
                }
                // We want to remove the last element with the desired index, as its replacement will be inserted before it
                if (last !== undefined) {
                    this.s.criteria.splice(last, 1);
                }
                for (var i = 0; i < this.s.criteria.length; i++) {
                    this.s.criteria[i].index = i;
                    this.s.criteria[i].criteria.s.index = i;
                }
            }
        };
        /**
         * Sets the listeners in group for a criteria
         *
         * @param criteria The criteria for the listeners to be set on
         */
        Group.prototype._setCriteriaListeners = function (criteria) {
            var _this = this;
            criteria.dom["delete"]
                .unbind('click')
                .on('click.dtsb', function () {
                _this._removeCriteria(criteria);
                criteria.dom.container.remove();
                for (var _i = 0, _a = _this.s.criteria; _i < _a.length; _i++) {
                    var crit = _a[_i];
                    if (crit.criteria instanceof Criteria) {
                        crit.criteria.updateArrows(_this.s.criteria.length > 1);
                    }
                }
                criteria.destroy();
                _this.s.dt.draw();
                _this.s.topGroup.trigger('dtsb-redrawContents');
                return false;
            });
            criteria.dom.right
                .unbind('click')
                .on('click.dtsb', function () {
                var idx = criteria.s.index;
                var group = new Group(_this.s.dt, _this.s.opts, _this.s.topGroup, criteria.s.index, true, _this.s.depth + 1, _this.s.serverData);
                // Add the criteria that is to be moved to the new group
                group.addCriteria(criteria);
                // Update the details in the current groups criteria array
                _this.s.criteria[idx].criteria = group;
                _this.s.criteria[idx].logic = 'AND';
                _this.s.topGroup.trigger('dtsb-redrawContents');
                _this._setGroupListeners(group);
                return false;
            });
            criteria.dom.left
                .unbind('click')
                .on('click.dtsb', function () {
                _this.s.toDrop = new Criteria(_this.s.dt, _this.s.opts, _this.s.topGroup, criteria.s.index, undefined, _this.s.serverData);
                _this.s.toDrop.s = criteria.s;
                _this.s.toDrop.c = criteria.c;
                _this.s.toDrop.classes = criteria.classes;
                _this.s.toDrop.populate();
                // The dropCriteria event mutates the reference to the index so need to store it
                var index = _this.s.toDrop.s.index;
                _this.dom.container.trigger('dtsb-dropCriteria');
                criteria.s.index = index;
                _this._removeCriteria(criteria);
                // By tracking the top level group we can directly trigger a redraw on it,
                //  bubbling is also possible, but that is slow with deep levelled groups
                _this.s.topGroup.trigger('dtsb-redrawContents');
                _this.s.dt.draw();
                return false;
            });
        };
        /**
         * Set's the listeners for the group clear button
         */
        Group.prototype._setClearListener = function () {
            var _this = this;
            this.dom.clear
                .unbind('click')
                .on('click.dtsb', function () {
                if (!_this.s.isChild) {
                    _this.dom.container.trigger('dtsb-clearContents');
                    return false;
                }
                _this.destroy();
                _this.s.topGroup.trigger('dtsb-redrawContents');
                return false;
            });
        };
        /**
         * Sets listeners for sub groups of this group
         *
         * @param group The sub group that the listeners are to be set on
         */
        Group.prototype._setGroupListeners = function (group) {
            var _this = this;
            // Set listeners for the new group
            group.dom.add
                .unbind('click')
                .on('click.dtsb', function () {
                _this.setupLogic();
                _this.dom.container.trigger('dtsb-add');
                return false;
            });
            group.dom.container
                .unbind('dtsb-add')
                .on('dtsb-add.dtsb', function () {
                _this.setupLogic();
                _this.dom.container.trigger('dtsb-add');
                return false;
            });
            group.dom.container
                .unbind('dtsb-destroy')
                .on('dtsb-destroy.dtsb', function () {
                _this._removeCriteria(group, true);
                group.dom.container.remove();
                _this.setupLogic();
                return false;
            });
            group.dom.container
                .unbind('dtsb-dropCriteria')
                .on('dtsb-dropCriteria.dtsb', function () {
                var toDrop = group.s.toDrop;
                toDrop.s.index = group.s.index;
                toDrop.updateArrows(_this.s.criteria.length > 1);
                _this.addCriteria(toDrop);
                return false;
            });
            group.setListeners();
        };
        /**
         * Sets up the Group instance, setting listeners and appending elements
         */
        Group.prototype._setup = function () {
            this.setListeners();
            this.dom.add.html(this.s.dt.i18n('searchBuilder.add', this.c.i18n.add));
            this.dom.logic.children().first().html(this.c.logic === 'OR'
                ? this.s.dt.i18n('searchBuilder.logicOr', this.c.i18n.logicOr)
                : this.s.dt.i18n('searchBuilder.logicAnd', this.c.i18n.logicAnd));
            this.s.logic = this.c.logic === 'OR' ? 'OR' : 'AND';
            if (this.c.greyscale) {
                this.dom.logic.addClass(this.classes.greyscale);
            }
            this.dom.logicContainer.append(this.dom.logic).append(this.dom.clear);
            // Only append the logic button immediately if this is a sub group,
            //  otherwise it will be prepended later when adding a criteria
            if (this.s.isChild) {
                this.dom.container.append(this.dom.logicContainer);
            }
            this.dom.container.append(this.dom.add);
        };
        /**
         * Sets the listener for the logic button
         */
        Group.prototype._setLogicListener = function () {
            var _this = this;
            this.dom.logic
                .unbind('click')
                .on('click.dtsb', function () {
                _this._toggleLogic();
                _this.s.dt.draw();
                for (var _i = 0, _a = _this.s.criteria; _i < _a.length; _i++) {
                    var crit = _a[_i];
                    crit.criteria.setListeners();
                }
            });
        };
        /**
         * Toggles the logic for the group
         */
        Group.prototype._toggleLogic = function () {
            if (this.s.logic === 'OR') {
                this.s.logic = 'AND';
                this.dom.logic.children().first().html(this.s.dt.i18n('searchBuilder.logicAnd', this.c.i18n.logicAnd));
            }
            else if (this.s.logic === 'AND') {
                this.s.logic = 'OR';
                this.dom.logic.children().first().html(this.s.dt.i18n('searchBuilder.logicOr', this.c.i18n.logicOr));
            }
        };
        Group.version = '1.1.0';
        Group.classes = {
            add: 'dtsb-add',
            button: 'dtsb-button',
            clearGroup: 'dtsb-clearGroup',
            greyscale: 'dtsb-greyscale',
            group: 'dtsb-group',
            inputButton: 'dtsb-iptbtn',
            logic: 'dtsb-logic',
            logicContainer: 'dtsb-logicContainer'
        };
        Group.defaults = {
            columns: true,
            conditions: {
                'date': Criteria.dateConditions,
                'html': Criteria.stringConditions,
                'html-num': Criteria.numConditions,
                'html-num-fmt': Criteria.numFmtConditions,
                'luxon': Criteria.luxonDateConditions,
                'moment': Criteria.momentDateConditions,
                'num': Criteria.numConditions,
                'num-fmt': Criteria.numFmtConditions,
                'string': Criteria.stringConditions
            },
            depthLimit: false,
            enterSearch: false,
            filterChanged: undefined,
            greyscale: false,
            i18n: {
                add: 'Add Condition',
                button: {
                    0: 'Search Builder',
                    _: 'Search Builder (%d)'
                },
                clearAll: 'Clear All',
                condition: 'Condition',
                data: 'Data',
                "delete": '&times',
                deleteTitle: 'Delete filtering rule',
                left: '<',
                leftTitle: 'Outdent criteria',
                logicAnd: 'And',
                logicOr: 'Or',
                right: '>',
                rightTitle: 'Indent criteria',
                title: {
                    0: 'Custom Search Builder',
                    _: 'Custom Search Builder (%d)'
                },
                value: 'Value',
                valueJoiner: 'and'
            },
            logic: 'AND',
            orthogonal: {
                display: 'display',
                search: 'filter'
            },
            preDefined: false
        };
        return Group;
    }());

    var $$1;
    var dataTable$1;
    /**
     * Sets the value of jQuery for use in the file
     *
     * @param jq the instance of jQuery to be set
     */
    function setJQuery(jq) {
        $$1 = jq;
        dataTable$1 = jq.fn.DataTable;
    }
    /**
     * SearchBuilder class for DataTables.
     * Allows for complex search queries to be constructed and implemented on a DataTable
     */
    var SearchBuilder = /** @class */ (function () {
        function SearchBuilder(builderSettings, opts) {
            var _this = this;
            // Check that the required version of DataTables is included
            if (!dataTable$1 || !dataTable$1.versionCheck || !dataTable$1.versionCheck('1.10.0')) {
                throw new Error('SearchBuilder requires DataTables 1.10 or newer');
            }
            var table = new dataTable$1.Api(builderSettings);
            this.classes = $$1.extend(true, {}, SearchBuilder.classes);
            // Get options from user
            this.c = $$1.extend(true, {}, SearchBuilder.defaults, opts);
            this.dom = {
                clearAll: $$1('<button type="button">' + table.i18n('searchBuilder.clearAll', this.c.i18n.clearAll) + '</button>')
                    .addClass(this.classes.clearAll)
                    .addClass(this.classes.button)
                    .attr('type', 'button'),
                container: $$1('<div/>')
                    .addClass(this.classes.container),
                title: $$1('<div/>')
                    .addClass(this.classes.title),
                titleRow: $$1('<div/>')
                    .addClass(this.classes.titleRow),
                topGroup: undefined
            };
            this.s = {
                dt: table,
                opts: opts,
                search: undefined,
                serverData: undefined,
                topGroup: undefined
            };
            // If searchbuilder is already defined for this table then return
            if (table.settings()[0]._searchBuilder !== undefined) {
                return;
            }
            table.settings()[0]._searchBuilder = this;
            // If using SSP we want to include the previous state in the very first server call
            if (this.s.dt.page.info().serverSide) {
                this.s.dt.on('preXhr.dtsb', function (e, settings, data) {
                    var loadedState = _this.s.dt.state.loaded();
                    if (loadedState && loadedState.searchBuilder) {
                        data.searchBuilder = _this._collapseArray(loadedState.searchBuilder);
                    }
                });
                this.s.dt.on('xhr.dtsb', function (e, settings, json) {
                    if (json && json.searchBuilder && json.searchBuilder.options) {
                        _this.s.serverData = json.searchBuilder.options;
                    }
                });
            }
            // Run the remaining setup when the table is initialised
            if (this.s.dt.settings()[0]._bInitComplete) {
                this._setUp();
            }
            else {
                table.one('init.dt', function () {
                    _this._setUp();
                });
            }
            return this;
        }
        /**
         * Gets the details required to rebuild the SearchBuilder as it currently is
         */
        // eslint upset at empty object but that is what it is
        // eslint-disable-next-line @typescript-eslint/ban-types
        SearchBuilder.prototype.getDetails = function (deFormatDates) {
            if (deFormatDates === void 0) { deFormatDates = false; }
            return this.s.topGroup.getDetails(deFormatDates);
        };
        /**
         * Getter for the node of the container for the searchBuilder
         *
         * @returns JQuery<HTMLElement> the node of the container
         */
        SearchBuilder.prototype.getNode = function () {
            return this.dom.container;
        };
        /**
         * Rebuilds the SearchBuilder to a state that is provided
         *
         * @param details The details required to perform a rebuild
         */
        SearchBuilder.prototype.rebuild = function (details) {
            this.dom.clearAll.click();
            // If there are no details to rebuild then return
            if (details === undefined || details === null) {
                return this;
            }
            this.s.topGroup.s.preventRedraw = true;
            this.s.topGroup.rebuild(details);
            this.s.topGroup.s.preventRedraw = false;
            this._checkClear();
            this._updateTitle(this.s.topGroup.count());
            this.s.topGroup.redrawContents();
            this.s.dt.draw(false);
            this.s.topGroup.setListeners();
            return this;
        };
        /**
         * Applies the defaults to preDefined criteria
         *
         * @param preDef the array of criteria to be processed.
         */
        SearchBuilder.prototype._applyPreDefDefaults = function (preDef) {
            var _this = this;
            if (preDef.criteria !== undefined && preDef.logic === undefined) {
                preDef.logic = 'AND';
            }
            var _loop_1 = function (crit) {
                // Apply the defaults to any further criteria
                if (crit.criteria !== undefined) {
                    crit = this_1._applyPreDefDefaults(crit);
                }
                else {
                    this_1.s.dt.columns().every(function (index) {
                        if (_this.s.dt.settings()[0].aoColumns[index].sTitle === crit.data) {
                            crit.dataIdx = index;
                        }
                    });
                }
            };
            var this_1 = this;
            for (var _i = 0, _a = preDef.criteria; _i < _a.length; _i++) {
                var crit = _a[_i];
                _loop_1(crit);
            }
            return preDef;
        };
        /**
         * Set's up the SearchBuilder
         */
        SearchBuilder.prototype._setUp = function (loadState) {
            var _this = this;
            if (loadState === void 0) { loadState = true; }
            // Register an Api method for getting the column type
            $$1.fn.DataTable.Api.registerPlural('columns().type()', 'column().type()', function () {
                return this.iterator('column', function (settings, column) {
                    return settings.aoColumns[column].sType;
                }, 1);
            });
            // Check that DateTime is included, If not need to check if it could be used
            // eslint-disable-next-line no-extra-parens
            if (!dataTable$1.DateTime) {
                var types = this.s.dt.columns().type().toArray();
                if (types === undefined || types.includes(undefined) || types.includes(null)) {
                    types = [];
                    for (var _i = 0, _a = this.s.dt.settings()[0].aoColumns; _i < _a.length; _i++) {
                        var colInit = _a[_i];
                        types.push(colInit.searchBuilderType !== undefined ? colInit.searchBuilderType : colInit.sType);
                    }
                }
                var columnIdxs = this.s.dt.columns().toArray();
                // If the types are not yet set then draw to see if they can be retrieved then
                if (types === undefined || types.includes(undefined) || types.includes(null)) {
                    $$1.fn.dataTable.ext.oApi._fnColumnTypes(this.s.dt.settings()[0]);
                    types = this.s.dt.columns().type().toArray();
                }
                for (var i = 0; i < columnIdxs[0].length; i++) {
                    var column = columnIdxs[0][i];
                    var type = types[column];
                    if (
                    // Check if this column can be filtered
                    (this.c.columns === true ||
                        Array.isArray(this.c.columns) &&
                            this.c.columns.includes(i)) &&
                        // Check if the type is one of the restricted types
                        (type.includes('date') ||
                            type.includes('moment') ||
                            type.includes('luxon'))) {
                        alert('SearchBuilder Requires DateTime when used with dates.');
                        throw new Error('SearchBuilder requires DateTime');
                    }
                }
            }
            this.s.topGroup = new Group(this.s.dt, this.c, undefined, undefined, undefined, undefined, this.s.serverData);
            this._setClearListener();
            this.s.dt.on('stateSaveParams.dtsb', function (e, settings, data) {
                data.searchBuilder = _this.getDetails();
                if (!data.scroller) {
                    data.page = _this.s.dt.page();
                }
                else {
                    data.start = _this.s.dt.state().start;
                }
            });
            this.s.dt.on('stateLoadParams.dtsb', function (e, settings, data) {
                _this.rebuild(data.searchBuilder);
            });
            this._build();
            this.s.dt.on('preXhr.dtsb', function (e, settings, data) {
                if (_this.s.dt.page.info().serverSide) {
                    data.searchBuilder = _this._collapseArray(_this.getDetails(true));
                }
            });
            this.s.dt.on('column-reorder', function () {
                _this.rebuild(_this.getDetails());
            });
            if (loadState) {
                var loadedState = this.s.dt.state.loaded();
                // If the loaded State is not null rebuild based on it for statesave
                if (loadedState !== null && loadedState.searchBuilder !== undefined) {
                    this.s.topGroup.rebuild(loadedState.searchBuilder);
                    this.s.topGroup.dom.container.trigger('dtsb-redrawContents');
                    // If using SSP we want to restrict the amount of server calls that take place
                    //  and this information will already have been processed
                    if (!this.s.dt.page.info().serverSide) {
                        if (loadedState.page) {
                            this.s.dt.page(loadedState.page).draw('page');
                        }
                        else if (this.s.dt.scroller && loadedState.scroller) {
                            this.s.dt.scroller().scrollToRow(loadedState.scroller.topRow);
                        }
                    }
                    this.s.topGroup.setListeners();
                }
                // Otherwise load any predefined options
                else if (this.c.preDefined !== false) {
                    this.c.preDefined = this._applyPreDefDefaults(this.c.preDefined);
                    this.rebuild(this.c.preDefined);
                }
            }
            this._setEmptyListener();
            this.s.dt.state.save();
        };
        SearchBuilder.prototype._collapseArray = function (criteria) {
            if (criteria.logic === undefined) {
                if (criteria.value !== undefined) {
                    criteria.value.sort(function (a, b) {
                        if (!isNaN(+a)) {
                            a = +a;
                            b = +b;
                        }
                        if (a < b) {
                            return -1;
                        }
                        else if (b < a) {
                            return 1;
                        }
                        else {
                            return 0;
                        }
                    });
                    criteria.value1 = criteria.value[0];
                    criteria.value2 = criteria.value[1];
                }
            }
            else {
                for (var i = 0; i < criteria.criteria.length; i++) {
                    criteria.criteria[i] = this._collapseArray(criteria.criteria[i]);
                }
            }
            return criteria;
        };
        /**
         * Updates the title of the SearchBuilder
         *
         * @param count the number of filters in the SearchBuilder
         */
        SearchBuilder.prototype._updateTitle = function (count) {
            this.dom.title.html(this.s.dt.i18n('searchBuilder.title', this.c.i18n.title, count));
        };
        /**
         * Builds all of the dom elements together
         */
        SearchBuilder.prototype._build = function () {
            var _this = this;
            // Empty and setup the container
            this.dom.clearAll.remove();
            this.dom.container.empty();
            var count = this.s.topGroup.count();
            this._updateTitle(count);
            this.dom.titleRow.append(this.dom.title);
            this.dom.container.append(this.dom.titleRow);
            this.dom.topGroup = this.s.topGroup.getNode();
            this.dom.container.append(this.dom.topGroup);
            this._setRedrawListener();
            var tableNode = this.s.dt.table(0).node();
            if (!$$1.fn.dataTable.ext.search.includes(this.s.search)) {
                // Custom search function for SearchBuilder
                this.s.search = function (settings, searchData, dataIndex) {
                    if (settings.nTable !== tableNode) {
                        return true;
                    }
                    return _this.s.topGroup.search(searchData, dataIndex);
                };
                // Add SearchBuilder search function to the dataTables search array
                $$1.fn.dataTable.ext.search.push(this.s.search);
            }
            this.s.dt.on('destroy.dtsb', function () {
                _this.dom.container.remove();
                _this.dom.clearAll.remove();
                var searchIdx = $$1.fn.dataTable.ext.search.indexOf(_this.s.search);
                while (searchIdx !== -1) {
                    $$1.fn.dataTable.ext.search.splice(searchIdx, 1);
                    searchIdx = $$1.fn.dataTable.ext.search.indexOf(_this.s.search);
                }
                _this.s.dt.off('.dtsb');
                $$1(_this.s.dt.table().node()).off('.dtsb');
            });
        };
        /**
         * Checks if the clearAll button should be added or not
         */
        SearchBuilder.prototype._checkClear = function () {
            if (this.s.topGroup.s.criteria.length > 0) {
                this.dom.clearAll.insertAfter(this.dom.title);
                this._setClearListener();
            }
            else {
                this.dom.clearAll.remove();
            }
        };
        /**
         * Update the count in the title/button
         *
         * @param count Number of filters applied
         */
        SearchBuilder.prototype._filterChanged = function (count) {
            var fn = this.c.filterChanged;
            if (typeof fn === 'function') {
                fn(count, this.s.dt.i18n('searchBuilder.button', this.c.i18n.button, count));
            }
        };
        /**
         * Set the listener for the clear button
         */
        SearchBuilder.prototype._setClearListener = function () {
            var _this = this;
            this.dom.clearAll.unbind('click');
            this.dom.clearAll.on('click.dtsb', function () {
                _this.s.topGroup = new Group(_this.s.dt, _this.c, undefined, undefined, undefined, undefined, _this.s.serverData);
                _this._build();
                _this.s.dt.draw();
                _this.s.topGroup.setListeners();
                _this.dom.clearAll.remove();
                _this._setEmptyListener();
                _this._filterChanged(0);
                return false;
            });
        };
        /**
         * Set the listener for the Redraw event
         */
        SearchBuilder.prototype._setRedrawListener = function () {
            var _this = this;
            this.s.topGroup.dom.container.unbind('dtsb-redrawContents');
            this.s.topGroup.dom.container.on('dtsb-redrawContents.dtsb', function () {
                _this._checkClear();
                _this.s.topGroup.redrawContents();
                _this.s.topGroup.setupLogic();
                _this._setEmptyListener();
                var count = _this.s.topGroup.count();
                _this._updateTitle(count);
                _this._filterChanged(count);
                // If using SSP we want to restrict the amount of server calls that take place
                //  and this information will already have been processed
                if (!_this.s.dt.page.info().serverSide) {
                    _this.s.dt.draw();
                }
                _this.s.dt.state.save();
            });
            this.s.topGroup.dom.container.unbind('dtsb-redrawContents-noDraw');
            this.s.topGroup.dom.container.on('dtsb-redrawContents-noDraw.dtsb', function () {
                _this._checkClear();
                _this.s.topGroup.s.preventRedraw = true;
                _this.s.topGroup.redrawContents();
                _this.s.topGroup.s.preventRedraw = false;
                _this.s.topGroup.setupLogic();
                _this._setEmptyListener();
                var count = _this.s.topGroup.count();
                _this._updateTitle(count);
                _this._filterChanged(count);
            });
            this.s.topGroup.dom.container.unbind('dtsb-redrawLogic');
            this.s.topGroup.dom.container.on('dtsb-redrawLogic.dtsb', function () {
                _this.s.topGroup.redrawLogic();
                var count = _this.s.topGroup.count();
                _this._updateTitle(count);
                _this._filterChanged(count);
            });
            this.s.topGroup.dom.container.unbind('dtsb-add');
            this.s.topGroup.dom.container.on('dtsb-add.dtsb', function () {
                var count = _this.s.topGroup.count();
                _this._updateTitle(count);
                _this._filterChanged(count);
            });
            this.s.dt.on('postEdit.dtsb postCreate.dtsb postRemove.dtsb', function () {
                _this.s.topGroup.redrawContents();
            });
            this.s.topGroup.dom.container.unbind('dtsb-clearContents');
            this.s.topGroup.dom.container.on('dtsb-clearContents.dtsb', function () {
                _this._setUp(false);
                _this._filterChanged(0);
                _this.s.dt.draw();
            });
        };
        /**
         * Sets listeners to check whether clearAll should be added or removed
         */
        SearchBuilder.prototype._setEmptyListener = function () {
            var _this = this;
            this.s.topGroup.dom.add.on('click.dtsb', function () {
                _this._checkClear();
            });
            this.s.topGroup.dom.container.on('dtsb-destroy.dtsb', function () {
                _this.dom.clearAll.remove();
            });
        };
        SearchBuilder.version = '1.4.2';
        SearchBuilder.classes = {
            button: 'dtsb-button',
            clearAll: 'dtsb-clearAll',
            container: 'dtsb-searchBuilder',
            inputButton: 'dtsb-iptbtn',
            title: 'dtsb-title',
            titleRow: 'dtsb-titleRow'
        };
        SearchBuilder.defaults = {
            columns: true,
            conditions: {
                'date': Criteria.dateConditions,
                'html': Criteria.stringConditions,
                'html-num': Criteria.numConditions,
                'html-num-fmt': Criteria.numFmtConditions,
                'luxon': Criteria.luxonDateConditions,
                'moment': Criteria.momentDateConditions,
                'num': Criteria.numConditions,
                'num-fmt': Criteria.numFmtConditions,
                'string': Criteria.stringConditions
            },
            depthLimit: false,
            enterSearch: false,
            filterChanged: undefined,
            greyscale: false,
            i18n: {
                add: 'Add Condition',
                button: {
                    0: 'Search Builder',
                    _: 'Search Builder (%d)'
                },
                clearAll: 'Clear All',
                condition: 'Condition',
                conditions: {
                    array: {
                        contains: 'Contains',
                        empty: 'Empty',
                        equals: 'Equals',
                        not: 'Not',
                        notEmpty: 'Not Empty',
                        without: 'Without'
                    },
                    date: {
                        after: 'After',
                        before: 'Before',
                        between: 'Between',
                        empty: 'Empty',
                        equals: 'Equals',
                        not: 'Not',
                        notBetween: 'Not Between',
                        notEmpty: 'Not Empty'
                    },
                    // eslint-disable-next-line id-blacklist
                    number: {
                        between: 'Between',
                        empty: 'Empty',
                        equals: 'Equals',
                        gt: 'Greater Than',
                        gte: 'Greater Than Equal To',
                        lt: 'Less Than',
                        lte: 'Less Than Equal To',
                        not: 'Not',
                        notBetween: 'Not Between',
                        notEmpty: 'Not Empty'
                    },
                    // eslint-disable-next-line id-blacklist
                    string: {
                        contains: 'Contains',
                        empty: 'Empty',
                        endsWith: 'Ends With',
                        equals: 'Equals',
                        not: 'Not',
                        notContains: 'Does Not Contain',
                        notEmpty: 'Not Empty',
                        notEndsWith: 'Does Not End With',
                        notStartsWith: 'Does Not Start With',
                        startsWith: 'Starts With'
                    }
                },
                data: 'Data',
                "delete": '&times',
                deleteTitle: 'Delete filtering rule',
                left: '<',
                leftTitle: 'Outdent criteria',
                logicAnd: 'And',
                logicOr: 'Or',
                right: '>',
                rightTitle: 'Indent criteria',
                title: {
                    0: 'Custom Search Builder',
                    _: 'Custom Search Builder (%d)'
                },
                value: 'Value',
                valueJoiner: 'and'
            },
            logic: 'AND',
            orthogonal: {
                display: 'display',
                search: 'filter'
            },
            preDefined: false
        };
        return SearchBuilder;
    }());

    /*! SearchBuilder 1.4.2
     * ©SpryMedia Ltd - datatables.net/license/mit
     */
    setJQuery($);
    setJQuery$1($);
    setJQuery$2($);
    var dataTable = $.fn.dataTable;
    // eslint-disable-next-line no-extra-parens
    DataTable.SearchBuilder = SearchBuilder;
    // eslint-disable-next-line no-extra-parens
    dataTable.SearchBuilder = SearchBuilder;
    // eslint-disable-next-line no-extra-parens
    DataTable.Group = Group;
    // eslint-disable-next-line no-extra-parens
    dataTable.Group = Group;
    // eslint-disable-next-line no-extra-parens
    DataTable.Criteria = Criteria;
    // eslint-disable-next-line no-extra-parens
    dataTable.Criteria = Criteria;
    // eslint-disable-next-line no-extra-parens
    var apiRegister = DataTable.Api.register;
    // Set up object for plugins
    DataTable.ext.searchBuilder = {
        conditions: {}
    };
    DataTable.ext.buttons.searchBuilder = {
        action: function (e, dt, node, config) {
            this.popover(config._searchBuilder.getNode(), {
                align: 'container',
                span: 'container'
            });
            var topGroup = config._searchBuilder.s.topGroup;
            // Need to redraw the contents to calculate the correct positions for the elements
            if (topGroup !== undefined) {
                topGroup.dom.container.trigger('dtsb-redrawContents-noDraw');
            }
            if (topGroup.s.criteria.length === 0) {
                $('.' + $.fn.dataTable.Group.classes.add.replace(/ /g, '.')).click();
            }
        },
        config: {},
        init: function (dt, node, config) {
            var sb = new DataTable.SearchBuilder(dt, $.extend({
                filterChanged: function (count, text) {
                    dt.button(node).text(text);
                }
            }, config.config));
            dt.button(node).text(config.text || dt.i18n('searchBuilder.button', sb.c.i18n.button, 0));
            config._searchBuilder = sb;
        },
        text: null
    };
    apiRegister('searchBuilder.getDetails()', function (deFormatDates) {
        if (deFormatDates === void 0) { deFormatDates = false; }
        var ctx = this.context[0];
        // If SearchBuilder has not been initialised on this instance then return
        return ctx._searchBuilder ?
            ctx._searchBuilder.getDetails(deFormatDates) :
            null;
    });
    apiRegister('searchBuilder.rebuild()', function (details) {
        var ctx = this.context[0];
        // If SearchBuilder has not been initialised on this instance then return
        if (ctx._searchBuilder === undefined) {
            return null;
        }
        ctx._searchBuilder.rebuild(details);
        return this;
    });
    apiRegister('searchBuilder.container()', function () {
        var ctx = this.context[0];
        // If SearchBuilder has not been initialised on this instance then return
        return ctx._searchBuilder ?
            ctx._searchBuilder.getNode() :
            null;
    });
    /**
     * Init function for SearchBuilder
     *
     * @param settings the settings to be applied
     * @param options the options for SearchBuilder
     * @returns JQUERY<HTMLElement> Returns the node of the SearchBuilder
     */
    function _init(settings, options) {
        var api = new DataTable.Api(settings);
        var opts = options
            ? options
            : api.init().searchBuilder || DataTable.defaults.searchBuilder;
        var searchBuilder = new SearchBuilder(api, opts);
        var node = searchBuilder.getNode();
        return node;
    }
    // Attach a listener to the document which listens for DataTables initialisation
    // events so we can automatically initialise
    $(document).on('preInit.dt.dtsp', function (e, settings) {
        if (e.namespace !== 'dt') {
            return;
        }
        if (settings.oInit.searchBuilder ||
            DataTable.defaults.searchBuilder) {
            if (!settings._searchBuilder) {
                _init(settings);
            }
        }
    });
    // DataTables `dom` feature option
    DataTable.ext.feature.push({
        cFeature: 'Q',
        fnInit: _init
    });
    // DataTables 2 layout feature
    if (DataTable.ext.features) {
        DataTable.ext.features.register('searchBuilder', _init);
    }

})();


return DataTable;
}));


/*! Bootstrap 5 ui integration for DataTables' SearchBuilder
 * © SpryMedia Ltd - datatables.net/license
 */

(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net-bs5', 'datatables.net-searchbuilder'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		var jq = require('jquery');
		var cjsRequires = function (root, $) {
			if ( ! $.fn.dataTable ) {
				require('datatables.net-bs5')(root, $);
			}

			if ( ! $.fn.dataTable.SearchBuilder ) {
				require('datatables.net-searchbuilder')(root, $);
			}
		};

		if (typeof window !== 'undefined') {
			module.exports = function (root, $) {
				if ( ! root ) {
					// CommonJS environments without a window global must pass a
					// root. This will give an error otherwise
					root = window;
				}

				if ( ! $ ) {
					$ = jq( root );
				}

				cjsRequires( root, $ );
				return factory( $, root, root.document );
			};
		}
		else {
			cjsRequires( window, jq );
			module.exports = factory( jq, window, window.document );
		}
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


$.extend(true, DataTable.SearchBuilder.classes, {
    clearAll: 'btn btn-light dtsb-clearAll'
});
$.extend(true, DataTable.Group.classes, {
    add: 'btn btn-light dtsb-add',
    clearGroup: 'btn btn-light dtsb-clearGroup',
    logic: 'btn btn-light dtsb-logic'
});
$.extend(true, DataTable.Criteria.classes, {
    condition: 'form-select dtsb-condition',
    data: 'dtsb-data form-select',
    "delete": 'btn btn-light dtsb-delete',
    input: 'form-control dtsb-input',
    left: 'btn btn-light dtsb-left',
    right: 'btn btn-light dtsb-right',
    select: 'form-select',
    value: 'dtsb-value'
});


return DataTable;
}));


